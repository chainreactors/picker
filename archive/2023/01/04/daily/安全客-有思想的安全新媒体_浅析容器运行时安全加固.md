---
title: 浅析容器运行时安全加固
url: https://www.anquanke.com/post/id/284713
source: 安全客-有思想的安全新媒体
date: 2023-01-04
fetch_date: 2025-10-04T02:56:46.989689
---

# 浅析容器运行时安全加固

首页

阅读

* [安全资讯](https://www.anquanke.com/news)
* [安全知识](https://www.anquanke.com/knowledge)
* [安全工具](https://www.anquanke.com/tool)

活动

社区

学院

安全导航

内容精选

* [专栏](/column/index.html)
* [精选专题](https://www.anquanke.com/subject-list)
* [安全KER季刊](https://www.anquanke.com/discovery)
* [360网络安全周报](https://www.anquanke.com/week-list)

# 浅析容器运行时安全加固

阅读量**408805**

发布时间 : 2023-01-03 12:00:53

**x**

##### 译文声明

本文是翻译文章

译文仅供参考，具体内容表达以及含义原文为准。

![]()

// 文丨支叶盛

美团安全研究员，主要从事 Linux 内核安全及二进制程序安全等方向的研究，当前负责美团内部操作系统安全、云原生安全等方向的安全建设。

随着云计算的蓬勃发展，云原生的概念于2013年被提出，Pivotal 公司的 Matt Stine 在概念中提出了云原生的4个要点：DevOps、持续交付、微服务、容器。而在 2015 年 Google 主导成立了云原生计算基金会（CNCF），CNCF 也给出了对云原生（Cloud Native）的定义，其中包含三个方面：1）应用容器化；2）面向微服务架构；3）应用支持容器的编排调度。

随着近几年来云原生生态的不断壮大，所有主流云计算供应商都加入了该基金会， CNCF 基金会中的会员以及容纳的项目越来越多，原先的定义已经限制了云原生生态的发展，到了 2018 年 CNCF 为云原生进行了重新定位，同时指出云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式 API。围绕这些概念、定义和代表技术，最为基础的就是容器和微服务。在容器应用之前，相关的云计算的应用多数运行于虚拟机上，但虚拟机会有额外的资源浪费和维护成本，并且其启动速度较慢。正是容器技术所具有的占用资源少、部署速度快和便于迁移等特点，助力了云原生生态的蓬勃发展，其中 Docker 和 Kubernetes 是企业容器运行时和容器编排的首要选择。

而于此同时，如何保证云原生环境的安全性也在不断受到挑战。在云原生技术应用的过程中，大多数企业都遇到过不同程度的安全问题，无论是前两年爆出的某著名车企的容器集群入侵事件，还是容器官方镜像仓库 Docker Hub 存在恶意镜像，用户在享受云原生相关技术便利的同时，也产生了极大的安全担忧。而作为云原生的基石——容器的安全性更是重中之重，为了满足云原生业务上对安全防护工具的全面性、便捷性以及性能上的要求，围绕着容器运行时安全的多个内核安全特性也在不断发展，本文将对近年来针对容器运行过程中的安全加固技术进行逐一介绍。（在本文中，若无特殊说明，容器指代 Docker 容器）

## 01容器安全概述

在实现云原生的主要技术中，容器作为支撑应用运行的重要载体，为应用的运行提供了隔离和封装，成为云原生应用的基础设施底座。与虚拟机不同的是，虚拟机模拟了硬件系统，每个虚拟机都运行在独立的 Guest OS 上，而容器之间却共享操作系统内核，并未实现完全的隔离。若虚拟化软件存在缺陷，或宿主机内核被攻击，将会造诸多的安全问题，包括隔离资源失效、容器逃逸等，影响宿主机上的其他容器甚至整个内网环境的安全（下图展示了 VM 和容器在系统架构上的差异）。

据《Sysdig 2022 云原生安全和使用报告》显示，超过75%的运行容器存在高危或严重漏洞、62%的容器被检测出包含 shell 命令、76%的容器使用 root 权限运行。鉴于云原生的攻击手段的独特性， 安全组织 MITRE 的对抗战术和技术知识库（ATT&CK 框架）在2021年推出了专门针对容器的攻击模型。云原生安全在近年来获得了大量的关注。

![]()

Google 在其 GCP 上讨论容器安全风险时，依据容器风险的来源，将其分为了三个方面：

1. 基础架构安全：主要是指容器管理平台能够提供的基本功能的安全。
2. 软件供应链安全：主要是指容器镜像安全。
3. 运行时安全：确保安全响应团队能够检测到环境中运行的容器所面临的安全威胁。

而 Google 的这个分类方法，其实也可以归结抽象为对容器生命周期中三个过程的安全：

1. 构建时安全：在容器镜像构建过程中，分析构建镜像时所使用的命令和配置参数，还原镜像文件构建过程，掌握命令使用的敏感操作，以及分析镜像文件是否包含密码、令牌、密钥和用户机密信息等敏感信息。同时，分析镜像的软件组成，发现镜像文件中包含的恶意文件、病毒和木马，以及所使用的依赖库和组件存在的安全漏洞，避免镜像本身存在的安全风险。
2. 部署时安全：分析镜像无风险后，镜像被提交至镜像仓库。在该阶段，将检查容器环境的镜像仓库配置，确保使用加密方式连接镜像仓库。当镜像仓库中新增镜像或使用镜像创建容器时，自动化校验镜像签名或MD5值，确保镜像来源可信且未被篡改，一旦发现镜像来源不可信或被篡改，禁止使用该镜像创建容器。
3. 运行时安全：当确认镜像安全后，进入到容器运行阶段。该阶段主要是是保证容器运行环境的安全，防止容器出现异常行为，这其中就包括主机环境配置安全、容器守护进程配置安全、容器应用的运行安全。

在容器生命周期的三个过程中，攻击者往往是在前两个阶段部署相关的恶意代码，在容器运行时对环境真正执行相关的攻击指令。因此，容器运行时相比于其他两个阶段更直接、也更容易分析出环境中的恶意行为。与其他虚拟化技术类似，逃逸也是针对容器运行时存在的漏洞最为严重的攻击利用行为。攻击者可通过利用漏洞“逃逸”出自身拥有的权限范围，实现对宿主机或者宿主机上其他容器的访问，其中最为简单的就是造成宿主机的资源耗尽，往往会直接危害底层宿主机和整个云原生系统的安全。根据风险所在层次的不同，可以进一步展开为：危险配置导致的容器安全风险、危险挂载导致的容器安全风险、相关程序漏洞导致的容器安全风险、内核漏洞导致的容器安全风险：

1. 危险配置导致的容器安全风险：用户可以通过修改容器环境配置或在启动容器时指定参数来改变容器的相关约束，但如果用户为一些不完全受控的容器配置了某些危险的配置参数，就为攻击者提供了一定程度的可以攻击利用的安全漏洞，例如未授权访问带来的容器安全风险，特权模式运行带来的容器安全风险。
2. 危险挂载导致的容器安全风险：将宿主机上的敏感文件或目录挂载到容器内部，尤其是那些不完全受控的容器内部，往往也会带来安全风险。这种挂载行为可以通过环境配置来设定，也可以在运行时进行动态挂载，因此这里单独地归为一类。随着应用的逐渐深化，挂载操作变得愈加广泛，甚至为了实现特定功能或方便操作，使用者会选择将外部敏感资源或文件系统直接挂载入容器，由此而来的安全问题也呈现上升趋势。例如：挂载 Docker Socket 引入的容器安全风险、挂载宿主机 procfs、sysfs 引入的容器安全问题等。
3. 相关程序漏洞导致的容器安全风险：所谓相关程序漏洞，指的是那些参与到容器运行、管理的服务端以及客户端程序自身存在的漏洞。例如，CVE-2019-5736、CVE-2021-30465、CVE-2020-15257等存在于 Container Daemon、runC 上的容器安全漏洞。
4. 内核漏洞导致的容器安全风险：Linux 内核漏洞的危害之大、影响范围之广，使得它在各种攻防话题下都占有一席之地，特别是在容器环境中由于容器与宿主机共享了内核，攻击者可以直接在容器中对内核漏洞进行利用攻击。近年来，Linux 系统曝出过无数内核漏洞，例如最有名气的漏洞之一——脏牛（CVE-2016-5195）漏洞也能用来进行容器逃逸。

安全容器的漏洞

安全容器是为了解决内核共享问题导致的安全风险所研发的一种运行时技术，它为容器应用提供一个完整的操作系统执行环境（常常是 Linux ABI），将应用的执行环境与宿主机操作系统隔离开，避免应用直接访问主机资源，从而可以在容器主机之间或容器之间提供额外的保护。例如，Kata Containers 就是为每一个容器运行一个独立虚拟机，从而避免其与宿主机共享内核。无论是理论上，还是实践中，安全容器都具有非常高的安全性。然而在 2020 年 Black Hat 北美会议上，Yuval Avrahami 分享了利用多个漏洞成功从 Kata containers 逃逸的议题，安全容器首次被发现存在逃逸可能性，他使用发现的三个漏洞（CVE-2020-2023、CVE-2020-2025 和 CVE-2020-2026）组成漏洞利用链先后进行容器逃逸和虚拟机逃逸，成功从容器内部逃逸到宿主机上。

为缓解甚至消除这些容器运行时的安全隐患，社区提供了一系列强化配置并且多年来也研发了相关的加固工具。CIS 发布的 Docker 基线已成为 Linux 主机配置和 Docker 主机加固的最佳实践。同样，CIS也发布了 Kubernetes 基线，传统的漏洞扫描工具、独立的容器安全产品（如 Aqua Security 和 NeuVector）和私有维护人员已经在 GitHub 上发布了脚本，可实现自动化的 Kubernetes 安全检查。接下来，我们将着重介绍一些行而有效的容器运行时的安全加固技术以及近年来的一些发展。

## 02容器运行时安全加固

运行时安全是在容器运行时通过检测和防止恶意行为来提供主动保护，可以说是整个容器生命周期中的最后一道安全屏障。其核心思想就是监控并限制容器中高危的行为，缩小容器进程的能力和权限。容器本身是利用了 Namespace 和 Cgroup 技术，将容器和宿主机之间的资源进行了隔离并加以限制。

> Namespace

> Namespace 即命名空间，也被称为名称空间，这是 Linux 提供的一种内核级别的环境隔离功能，它的主要用途是对容器提供资源的访问隔离，这些资源包括文件系统挂载 、主机名和域名、进程间通信 、进程访问、网络隔离、用户和组隔离等。容器充分利用了 Namespace 的技术，使其达到尽可能地隔离容器之间以及对宿主机的影响。

> Cgroup

> Cgroup全称为 Control Group，它也是容器的重要特性。如果说 Namespace 是用于隔离，那么 Cgroup 则是限制容器对于资源的占用，如CPU、内存、磁盘 I/O 等。这个特性可以有效地避免某个容器因为被 DDOS 攻击或者自身程序的问题导致对资源的不断占用，并最终影响到宿主机及上面运行的其他容器，出现“雪崩”的灾难 。

虽然这种隔离限制从资源层面实现了对容器和宿主机之间的环境独立，宿主机的资源对容器不再可见，但是这种方式并没有达到真正意义上的安全隔离。由于容器的内核与宿主内核共享，一旦容器中通过恶意行为进行一些高危的操作权限，或者是利用内核漏洞，往往就可以突破这种资源上的隔离，造成容器逃逸，重新危害到宿主机及上面运行的其他容器。

目前 Linux 内核提供了一系列的安全能力可以对这些攻击行为进行有效防护。结合内核安全技术的能力，这些技术的作用范围可以简单地分为两种：一种是限制是限制行为本身，另一种则是限制行为作用的对象范围。首先我们介绍如果有效切断这些造成逃逸的恶意行为，如何去限制发起行为的能力。

### **2.1 Capabilities 和 Seccomp**

在 Linux 系统中 Root 用户作为超级用户拥有全部的操作权限，以 Root 身份运行容器，相当于将打开容器资源限制大门的钥匙交给了容器自身，这是十分危险的。但如果以非 Root 身份在后台运行容器的话，由于缺少权限容器中的应用进程容易处处受限。为了适应这种复杂的权限需求，Linux 细化了 Root 权限的管控能力，从 2.2 版本起 Linux 内核能够进一步将超级用户的权限分解为细颗粒度的单元，这些单元称为 Capabilities。例如，CAP\_CHOWN 允许用户对文件的 UID 和 GID 进行任意修改，即执行 chown 命令。

\*Capabilities 详细信息可通过 Linux Programmer’s Manual 进行查看：https://man7.org/linux/man-pages/man7/capabilities.7.html

几乎所有与超级用户相关的特权都被分解成了单独的 Capability，可以分别启用或禁用。这种系统权限机制提供了细粒度的操作权限的访问控制，控制容器运行所需的 Capabilities 范围，可以有效切断容器中攻击者的行为操作。即使容器攻击者取得了 Root 权限，由于不能获得主机的完全的操作权限，也进一步限制了攻击对宿主机的破坏。Docker 在容器管理中默认限制了容器的 Capabilities， 其中仅开启如下部分：

![]()

但是基于 Capabilities 的权限访问管理，有时候并不能很好地限制住容器的操作权限。例如，SYS\_ADMIN 管理了 mount，umount，pivot\_root，swapon，swapoff，sethostname，setdomainname 等等系统调用的访问权限，一旦应用进程因为需要进行 sethostname 这样的操作而在容器中开启了 SYS\_ADMIN 组的 Capabilities，那么也就让容器具有了 mount 这类可以挂载系统资源的操作权限，导致容器存在逃逸的风险。Seccomp（Secure Computing Mode）同样也是一种 Linux 内核提供的安全特性，它可以以白名单或黑名单的方式限制进程进行系统调用。相对于 Capabilities 将系统调用以组的形式进行分类管理，Seccomp 是对系统调用更细粒度的单点控制。

Seccomp 首次于内核 2.6.12 版合入 Linux 主线。早期的 Seccomp 只支持过滤使用四个系统调用：read，write，\_exit，sigreturn。在这种安全模式下，除了已打开的文件描述符和允许的四种系统调用，一旦进程尝试访问其他系统调用，内核就会使用 SIGKILL 或 SIGSYS 信号来终止该进程。由于这种限制太过于严格，在实际应用中作用并不大。

为了解决此问题，2012 年的内核 3.5 版本引入了一种新的 Seccomp 模式，叫做 SECCOMP\_MODE\_FILTER。这个功能允许用户使用可配置的策略过滤系统调用，该策略使用 Berkeley Packet Filter（BPF）规则实现，从而使 Seccomp 可以对任意的系统调用及其参数（仅常数，无法指针解引用）进行过滤。因此使用这种模式的的 Seccomp 也被称之为 Seccomp-BPF。而程序在 fork/clone 或 execve 时，BPF 过滤规则是可以从父进程继承到子进程，因此 Seccomp 机制可以很好地用于限制容器的权限。

> seccomp 设定的系统调用过滤规则能传递给子程序的关键在于 prctl 系统调用：

> prctl(PR\_SET\_NO\_NEW\_PRIVS, 1, 0, 0, 0);

> prctl 的 No New Privileges Flag 可以避免类似 execve 的系统调用授予父进程没有的权限。详见：https://man7.org/linux/man-pages/man2/prctl.2.html

目前 docker 在运行容器时会使用默认配置，其中禁止了约 44 个系统调用，当然也可以使用 –security-opt 选项将默认的配置文件替换为自定义的配置文件。

\*docker默认配置详见：https://github.com/moby/moby/blob/master/profiles/seccomp/default.json

在 5.0 版本内核中又加入了新的 seccomp-unotify 模式。Seccomp-BPF 模式对系统调用的判断过程是由加载到内核的 BPF 程序来完成的，而 Seccomp-unotify 机制可以将这一判断过程移交给另一个用户态的进程来完成。同时，利用该模式 Filter 进程不仅可以检测系统调用的参数，还可以对指针参数进行解引用，查看指针所指向的内存。这就方便了判断程序对调用行为的分析判断，大大扩充了 Seccomp 机制的过滤能力。作为一种新增特性，Seccomp-unotify 模式更为强大的过滤能力相信后续会在容器安全加固中拥有比较大的使用空间。

需要注意的是，这种位于 syscall 入口处的检查判断是存在 TOCTTOU（Time Of Check To Time Of Use）风险的——风险就在于此时的一些内存数据依旧保存在用户空间，从入口检测到实际使用还需要一定的时间，攻击者完全可以在这段时间内通过其他并发线程对用户空间上的数据进行修改。因此 Seccomp 以及 Capabilities 的优势不在于限制容器中的进程能否通过 syscall 去访问一些特定的资源，而在于直接去排除容器中进程发起这类 syscall 行为的能力。接下来我们也将讨论如何更有效地限制这些行为的作用对象，以及阻断逃逸后的攻击者对宿主机中其他资源的访问。

### **2.2 MAC 和 LSM**

Namespace 机制让容器和宿主机之间实现了资源上的隔离，让宿主机上的其他资源对容器不再可见。但是这种虚拟隔离并没有限制容器中进程的访问权限，资源访问权限的管理却是由 Linux DAC（Discretionary Access Control，自主访问控制，以下简称 DAC）机制来完成的，它主要依赖的进程的 uid 和 gid 来进行管理。因此一旦容器中的攻击者突破了 Namespace 的界限，往往就可以对容器外的资源进行访问。而解决这一安全风险的关键就是——强制访问控制（Mandatory Access Control——MAC，以下简称MAC）。其中最为熟知的 MAC 访问控制安全模块，就是 SELinux、AppArmor等。

**SELinux**

早期的操作系统几乎没有考虑安全问题，系统中只有一个用户并且可以访问系统任何资源。而随着多用户系统的发展，为了有效限制用户的访问权限，确保用户只能访问他们需要的资源，出现了访问控制机制来增强安全性。其中主要的访问控制就是 DAC 机制。DAC 通常允许授权用户自主改变客体的访问控制属性，这样就可指定其他用户是否有权访问该客体。然而，DAC 机制只约束了用户、同用户组内的用户、其他用户对文件的可读、可写、可执行权限，这对系统的保护作用非常有限。

> Linux 系统中所有内容都是以文件的形式保存和管理的，即一切皆文件。

为了克服这种脆弱性，出现了 MAC 机制，其基本原理...