---
title: Multi Agent 的快速构建以及在自动化演练的应用
url: https://wjlshare.com/archives/1793
source: 天下大木头
date: 2025-09-02
fetch_date: 2025-10-02T19:30:59.119148
---

# Multi Agent 的快速构建以及在自动化演练的应用

[天下大木头](https://wjlshare.com)

* [主页](http://www.wjlshare.com)
* [友情链接](https://wjlshare.com/%E5%8F%8B%E9%93%BE)
* [关于我](https://wjlshare.com/%E5%85%B3%E4%BA%8E%E6%88%91)
* [归档](https://wjlshare.com/%E5%BD%92%E6%A1%A3)

##### 搜索

×

搜索

天下大木头

夜间模式暗黑模式

字体

Sans SerifSerif

阴影

浅阴影深阴影

滤镜

关闭
日落
暗化
灰度

圆角

0%

天下大木头

搜索

* [文章目录](#leftbar_tab_catalog)
* [站点概览](#leftbar_tab_overview)

![avatar](http://wjlshare.com/wp-content/uploads/2021/05/111.jpg)

###### 天下大木头

176
文章

19
分类

1
标签

##### 分类

×

[CTF 3](https://wjlshare.com/archives/category/ctf)[Java 23](https://wjlshare.com/archives/category/java)[php 5](https://wjlshare.com/archives/category/php)[python 8](https://wjlshare.com/archives/category/python)[SQL 17](https://wjlshare.com/archives/category/sql)[web安全 34](https://wjlshare.com/archives/category/web)[云安全 5](https://wjlshare.com/archives/category/%E4%BA%91%E5%AE%89%E5%85%A8)[代码审计 26](https://wjlshare.com/archives/category/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1)[供应链 1](https://wjlshare.com/archives/category/%E4%BE%9B%E5%BA%94%E9%93%BE)[内网渗透 4](https://wjlshare.com/archives/category/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F)[小问题解决 3](https://wjlshare.com/archives/category/%E7%B3%BB%E5%88%97%E5%B0%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3)[应急响应 1](https://wjlshare.com/archives/category/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94)[思考总结 45](https://wjlshare.com/archives/category/%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93)[未分类 62](https://wjlshare.com/archives/category/uncategorized)[漏洞复现分析 20](https://wjlshare.com/archives/category/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90)[漏洞学习笔记 6](https://wjlshare.com/archives/category/%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86)[漏洞挖掘 6](https://wjlshare.com/archives/category/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98)[计算机基础 2](https://wjlshare.com/archives/category/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80)[逆向 1](https://wjlshare.com/archives/category/%E9%80%86%E5%90%91)

##### 标签

×

[SQL 0](https://wjlshare.com/archives/tag/sql)

* [CTF](https://wjlshare.com/archives/category/ctf)
* [Java](https://wjlshare.com/archives/category/java)
* [php](https://wjlshare.com/archives/category/php)
* [python](https://wjlshare.com/archives/category/python)
* [SQL](https://wjlshare.com/archives/category/sql)
* [web安全](https://wjlshare.com/archives/category/web)
* [云安全](https://wjlshare.com/archives/category/%E4%BA%91%E5%AE%89%E5%85%A8)
* [代码审计](https://wjlshare.com/archives/category/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1)
* [供应链](https://wjlshare.com/archives/category/%E4%BE%9B%E5%BA%94%E9%93%BE)
* [内网渗透](https://wjlshare.com/archives/category/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F)
* [小问题解决](https://wjlshare.com/archives/category/%E7%B3%BB%E5%88%97%E5%B0%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3)
* [应急响应](https://wjlshare.com/archives/category/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94)
* [思考总结](https://wjlshare.com/archives/category/%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93)
* [未分类](https://wjlshare.com/archives/category/uncategorized)
* [漏洞复现分析](https://wjlshare.com/archives/category/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90)
* [漏洞学习笔记](https://wjlshare.com/archives/category/%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86)
* [漏洞挖掘](https://wjlshare.com/archives/category/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98)
* [计算机基础](https://wjlshare.com/archives/category/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80)
* [逆向](https://wjlshare.com/archives/category/%E9%80%86%E5%90%91)

###### 近期文章

* [Multi Agent 的快速构建以及在自动化演练的应用](https://wjlshare.com/archives/1793)
* [阿里云反入侵团队招人了！！！](https://wjlshare.com/archives/1789)
* [供应链投毒：NPM](https://wjlshare.com/archives/1784)
* [恶意代码分析实战 – Lab 5](https://wjlshare.com/archives/1779)
* [容器学习（一）：进程](https://wjlshare.com/archives/1776)

[Multi Agent 的快速构建以及在自动化演练的应用](https://wjlshare.com/archives/1793)

2025-9-01 21:30

|

309

|

0

|

[未分类](https://wjlshare.com/archives/category/uncategorized)

6507 字

|

25 分钟

## 背景

2025年被称为 Agent 元年，AI 的发展逐渐来到了新的临界点，Agent 凭借其独特的自主理解、感知、规划、记忆、和工具使用能力，实现在处理复杂任务时所展现出来的灵活性和效率。

现今业务场景逐渐复杂多样化，单 Agent 形式框架逐步被效果更好的 Multi Agent 所取代，Multi Agent 凭借其任务拆分、精细化分工的能力，通过分层来优化性能、提升效率

![image.png](data:image/png;base64...)

## Agent vs Multi Agent

一张简单的架构图来看清 Single Agent System（SAS） 和 Multi Agent System（MAS） 之间的区别

![image.png](data:image/png;base64...)

从架构图里可以很容易的看出来，SAS 和 MAS 在处理任务的时候一个是单一 agent 循环 loop 进行执行，另一个则是将任务进行拆解来处理。这两种架构并没有完全好与不好的说法，并且随着底层 LLM 能力不断的提升，SAS 也能够解决复杂问题。但是在某些具体场景的应用下还是存在一些差异，同时彼此之间也有优势和缺点。

**Single Agent System**

局限性：

* SAS 在复杂问题处理上必然会遇到 Context Windows 长度限制的问题，并且过长的上下文也会影响实际效果

优势：

* 上下文较为连贯，解决问题的时候能保证完成的上下文，通常用于处理单一简单场景的问题

**Multi Agent System**

局限性：

* MAS 在解决同类型问题时消耗的 Token 成本较高
* MAS 需要解决跨 Agent 之间的 Context 共享的问题，并且确保共享信息的精度，如果关键信息丢失那么就有可能导致最终实际效果反而更差

优势：

* 通过将任务拆解，可以通过不同的 Prompt 、Rag 等信息实现团队化问题解决，适合解决多场景的复杂问题

这其实非常像「单兵作战 vs 团队协作」的问题

1. 单兵作战效率最高，同时没有沟通成本，但是在实现过程中存在体力和时间的上限
2. 团队协作可以能够处理更大更多场景的问题，但是需要付出更多协作、沟通的成本，有时错误的沟通最终会导致效果的降低

在具体实现过程中可以根据实际业务场景来选择，SAS 和 MAS 没有更好一说，能更好的解决实际问题那么就选择哪一种，甚者将两者[混合使用](https://arxiv.org/pdf/2505.18286)也是可以的

## Multi Agent 实现思路

前面提到了 Agent 的两种 SAS 和 MAS ，SAS 这类的 Single Agent System 其实理解起来和实现大家都非常的了解，在百炼上就可以快速进行创建，我们只需要提供 prompt 、rag 索引、工具等信息就可以快速创建一个 Agent

![image.png](data:image/png;base64...)

那么如果需要构建 MAS 的时候和 SAS 的差异是什么，其实最大的差异就是不同 Agent 之间的上下文共享、以及任务分配处理的问题，我下面举例一个最常见的 MAS 的实现逻辑

1. 需要一个全局的 Context 上下文，用于将任务进行存储，通常将**任务list、已完成任务、历史任务执行结果**等需要共享的信息进行存放
2. 子agent 构建对应的 prompt 形成专家 agent 来获取 全局上下文，并进行循环问题解决，解决之后将任务更新到全局上下文
3. 如此往复执行，直至 todolist 中的任务被解决，则代表任务执行完成

![image](data:image/png;base64...)

## LangGraph：面向状态与循环的编排框架

LangGraph是一个专门用于构建、管理和部署**长期运行、有状态智能体**的底层编排框架。专注于解决复杂、非线性的任务流。

前面提到，在实现 MAS 的时候需要做好跨 Agent 之间的上下文以及信息要素的协调，Langgraph 就很好的在底层实现了这一特性，基于图结构来管理所有 agent 执行的任务流，可以实现将 agent 之间进行快速编排，同时 图结构 也是跨 agent 之间共享，所以我们可以基于 langgraph 来快速开发适合我们自己的 MAS 系统

* **核心理念**：它基于**图结构**来管理任务流，将智能体（Agent）和各种工具看作图中的节点（Node），将它们之间的交互看作边（Edge）。这种设计使其非常适用于需要**动态决策**和**循环往复**的复杂场景。

### 4.1 核心概念

* **Graph（图）**：这是LangGraph的核心。它允许我们构建复杂的任务流程，其中各个Agent都是图中的节点，**过程信息可以实现所有Agent共享**。值得注意的是，与传统有向无环图（DAG）不同，LangGraph最强大的地方在于它能够支持**循环（Cycle）**，这正是我们自动化演练中处理重试、循环探测等场景所必需的。
* **Node（节点）**：图中的基本单元，通常代表一个具体的Agent、一个工具调用、或是一个逻辑分支。
* **Edge（边）**：连接节点之间的连接。它们可以是简单的顺序执行，也可以是**并行**处理，或是根据条件进行**动态转换**，这极大地增强了流程的灵活性。

### 4.2 优势

1. **低成本实现记忆与上下文管理：**

通过内置的 GraphState 图状态管理机制，所有 Agent 都能访问、共享、更新过程中的状态，以低成本的方式实现了多个 Agent 之间记忆共享和上下文管理的问题

2. **复杂场景的良好支持**

基于 Graph 可以构建条件边，针对 Agent 执行的不同状态进入不同的路由，下面是一个简单的路由边的例子

![image](data:image/png;base64...)

### 4.3 快速构建

我这里以之前构建的一个自动化演练 demo 来介绍 Langgraph 如何实现快速构建基于 React 模式的 Multi Agent 框架

1. 定义图状态信息, 图状态中的所有信息都可被各 Agent 实现信息共享

前面所说的全局上下文，在 Langgraph 中只需要定义 图状态就可以了

```
class GraphState(TypedDict):
    initial_goal: str  # 最初的演练目标
    plan: List[Task]   # 主 Agent 生成的计划（ToDoList）
    current_task_id: int # 当前正在执行的任务索引
    completed_tasks: Annotated[list[Task], operator.add] # 已完成任务的结果列表
    final_summary: str # 最终的演练总结报告
```

2. 构建项目中所需要的 Agent

Planner Agent： 这个很简单，编写对应合适的 Prompt 就可以了

![image.png](data:image/png;base64...)

直接返回即可，返回之后 GraphState 中的 plan 就会自动更新

![image.png](data:image/png;base64...)

返回之后 langgraph 中的 图节点中我们定义的 plan 就会存在数据

例：GraphState:  = {task1, task2, task3}

Executor Agent：因为是具体执行的 Agent 所以实现会比 Planner 步骤要稍微多一些，我们需要做如下的调整，本质还是为 Agent 提供工具，加强对环境以及上下文内容的感知

* Agent 上下文的传入（上一个子任务的执行情况、执行结果、过程信息的传递）
* Executor Agent 能够使用的工具注册（工具的注册、字段的描述等信息）
* 历史交互（当前子Agent流程中的问答记录）

![image.png](data:image/png;base64...)

子Agent执行的时候可以从 Graph 图中获取到计划任务、以及之前执行的结果信息

从全局共享的 GraphStat 中获取执行任务，并进行子 Agent 的循环执行

![image.png](data:image/png;base64...)

下面这个执行流程就是子 agent 执行的实例，会调用各类我们注册的工具，并且把任务结果重新追加到 prompt 中进行重复追问，最终直至 agent 觉得当前子任务执行完成，便退出，交给下一个 agent 来消费下一个 任务

![image.png](data:image/png;base64...)

3. 根据我们想要编排的流程确定对应的入口、结束点、以及条件转移边

在实际情况中，因为大模型肯定会出现幻觉的问题，所以我们可以写路由的方式来根据 agent 返回的结果来决定下一步如何走，在 langgraph中提供了边路由函数的实现，从而实现基于内容来判断是再次执行还是状态转移等...

在 Langgraph 中可以通过对 Start 和 End 节点的设置，来快速编排 Agent

![image.png](data:image/png;base64...)

构建条件边路由信息，图基于 agent 返回的内容来判断是否需要继续执行、或状态转移

![image.png](data:image/png;base64...)

...