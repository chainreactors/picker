---
title: Gregor Samsa: Exploiting Java's XML Signature Verification
url: https://googleprojectzero.blogspot.com/2022/11/gregor-samsa-exploiting-java-xml.html
source: Project Zero
date: 2022-11-03
fetch_date: 2025-10-03T21:39:53.606514
---

# Gregor Samsa: Exploiting Java's XML Signature Verification

# [Project Zero](https://googleprojectzero.blogspot.com/)

News and updates from the Project Zero team at Google

## Wednesday, November 2, 2022

### Gregor Samsa: Exploiting Java's XML Signature Verification

By Felix Wilhelm, Project Zero

Earlier this year, I discovered a surprising attack surface hidden deep inside Java’s standard library: A custom JIT compiler processing untrusted XSLT programs, exposed to remote attackers during XML signature verification. This post discusses [CVE-2022-34169](https://bugs.chromium.org/p/project-zero/issues/detail?id=2290&q=reporter%3Ame&can=1), an integer truncation bug in this JIT compiler resulting in arbitrary code execution in many Java-based web applications and identity providers that support the SAML single-sign-on standard.

OpenJDK fixed the discussed issue in [July 2022](https://openjdk.org/groups/vulnerability/advisories/2022-07-19). The Apache BCEL project used by Xalan-J, the origin of the vulnerable code, released a patch in [September 2022](https://github.com/apache/commons-bcel/commit/f3267cbcc900f80851d561bdd16b239d936947f5).

While the vulnerability discussed in this post has been patched , vendors and users should expect further vulnerabilities in SAML.

From a security researcher's perspective, this vulnerability is an example of an integer truncation issue in a memory-safe language, with an exploit that feels very much like a memory corruption. While less common than the typical memory safety issues of C or C++ codebases, weird machines still exist in memory safe languages and will keep us busy even after we move into a bright memory safe future.

Before diving into the vulnerability and its exploit, I’m going to give a quick overview of XML signatures and SAML. What makes XML signatures such an interesting target and why should we care about them?

## Introduction

XML Signatures are a typical example of a security protocol invented in the early 2000’s. They suffer from high complexity, a large attack surface and a wealth of configurable features that can weaken or break its security guarantees in surprising ways. Modern usage of XML signatures is mostly restricted to somewhat obscure protocols and legacy applications, but there is one important exception: SAML. SAML, which stands for Security Assertion Markup Language, is one of the two main Single-Sign-On standards used in modern web applications. While its alternative, the OAuth based OpenID Connect (OIDC) is gaining popularity, SAML is still the de-facto standard for large enterprises and complex integrations.

SAML relies on XML signatures to protect messages forwarded through the browser. This turns XML signature verification into a very interesting external attack surface for attacking modern multi-tenant SaaS applications. While you don’t need a detailed understanding of SAML to follow this post, interested readers can take a look at Okta's [Understanding SAML](https://developer.okta.com/docs/concepts/saml/) writeup or the [SAML 2.0 wiki](https://en.wikipedia.org/wiki/SAML_2.0) entry to get a better understanding of the protocol.

SAML SSO logins work by exchanging XML documents between the application, known as service provider (SP), and the identity provider (IdP). When a user tries to login to an SP, the service provider creates a SAML request. The IdP looks at the SAML request, tries to authenticate the user and sends a SAML response back to the SP. A successful response will contain information about the user, which the application can then use to grant access to its resources.

In the most widely used SAML flow (known as SP Redirect Bind / IdP POST Response) these documents are forwarded through the user's browser using HTTP redirects and POST requests. To protect against modification by the user, the security critical part of the SAML response (known as Assertion) has to be cryptographically signed by the IdP. In addition, the IdP might require SPs to also sign the SAML request to protect against impersonation attacks.

This means that both the IdP and the SP have to parse and verify XML signatures passed to them by a potential malicious actor. Why is this a problem? Let's take a closer look at the way XML signatures work:

## XML Signatures

Most signature schemes operate on a raw byte stream and sign the data as seen on the wire. Instead, the XML signature standard (known as XMLDsig) tries to be robust against insignificant changes to the signed XML document. This means that changing whitespaces, line endings or comments in a signed document should not invalidate its signature.

An XML signature consists of a special Signature element, an example of which is shown below:

|  |
| --- |
| <Signature>    <SignedInfo>      <CanonicalizationMethod Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"/>      <SignatureMethod Algorithm="http://www.w3.org/2000/09/xmldsig#rsa-sha1" />      <Reference URI="#signed-data">         <Transforms>         …         </Transforms>         <DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#sha1" />         <DigestValue>9bc34549d565d9505b287de0cd20ac77be1d3f2c</DigestValue>      </Reference>    </SignedInfo>    <SignatureValue>....</SignatureValue>    <KeyInfo><X509Certificate>....</X509Certificate></KeyInfo>  </Signature> |

* The  SignedInfo child contains  CanonicalizationMethod and SignatureMethod elements as well as one or more Reference elements describing the integrity protected data.
* KeyInfo describes the signer key and can contain a raw public key, a X509 certificate or just a key id.
* SignatureValue contains the cryptographic signature (using SignatureMethod) of the SignedInfo element after it has been canonicalized using CanonicalizationMethod.

At this point, only the integrity of the SignedInfo element is protected. To understand how this protection is extended to the actual data, we need to take a look at the way Reference elements work: In theory the Reference URI attribute can either point to an external document (detached signature), an element embedded as a child (enveloping signature) or any element in the outer document (enveloped signature). In practice, most SAML implementations use enveloped signatures and the Reference URI will point to the signed element somewhere in the current document tree.

When a Reference is processed during verification or signing, the referenced content is passed through a chain of Transforms. XMLDsig supports a number of transforms ranging from canonicalization, over base64 decoding to XPath or even XSLT. Once all transforms have been processed the resulting byte stream is passed into the cryptographic hash function specified with the DigestMethod element and the result is stored in DigestValue.

This way, as the whole Reference element is part of SignedInfo, its integrity protection gets extended to the referenced element as well.

Validating a XML signature can therefore be split into two separate steps:

* Reference Validation: Iterate through all embedded references and for each reference fetch the referenced data, pump it through the Transforms chain and calculate its hash digest. Compare the calculated Digest with the stored DigestValue and fail if they differ.
* Signature Validation: First canonicalize the SignedInfo element using the specified CanonicalizationMethod algorithm. Calculate the signature of SignedInfo using the algorithm specified in SignatureMethod and the signer key described in KeyInfo. Compare the result with SignatureValue and fail if they differ.

Interestingly, the order of these two steps can be implementation specific. While the XMLDsig RFC lists Reference Validation as the first step, performing Signature Validation first can have security advantages as we will see later on.

Correctly validating XML signatures and making sure the data we care about is protected, is very difficult in the context of SAML. This will be a topic for later blog posts, but at this point we want to focus on the reference val...