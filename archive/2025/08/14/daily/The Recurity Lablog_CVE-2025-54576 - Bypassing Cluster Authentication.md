---
title: CVE-2025-54576 - Bypassing Cluster Authentication
url: http://blog.recurity-labs.com/2025-08-13/CVE-2025-54576
source: The Recurity Lablog
date: 2025-08-14
fetch_date: 2025-10-07T00:47:53.626534
---

# CVE-2025-54576 - Bypassing Cluster Authentication

[## The Recurity Lablog](/)

* [Posts](/)

computer security, research, reverse engineering and high level considerations

Written by Jennifer

on August 13, 2025

# CVE-2025-54576 - Bypassing Cluster Authentication

*Editorâs note: [Jennifer](https://www.linkedin.com/in/jennifer-gehrke-27109b35b/) is a former Recurity Labs employee who now works as a freelancer, continuing to contribute to many of our projects. We are grateful to still have her expertise and insight on board, and her contributions remain highly valued and appreciated. The following post was written by Jennifer.*

The correct operation and security auditing of microservice architectures is one of the challenges one faces with modern products. While it is not the only area of application, this design scheme is very common in the context of web applications. This blog post describes how a typical web application audit led to identifying a critical authentication bypass in the widespread [OAuth2-Proxy](https://github.com/oauth2-proxy/oauth2-proxy) tool.

For those who are primarily interested in the [issueâs details](#the-bug), there is also a detailed advisory available on [GitHub](https://github.com/oauth2-proxy/oauth2-proxy/security/advisories/GHSA-7rh7-c77v-6434), filed under the [CVE-2025-54576](https://nvd.nist.gov/vuln/detail/CVE-2025-54576). If you are running OAuth2-Proxy with a regex-based whitelist for public endpoints, you might be affected by this issue.

## High Resolution Architectures

Fifteen years ago, even complex web applications were commonly realized by one big monolithic code base. Most prominently, Java-based solutions spread over numerous JAR files, each larger than anyone would like to maintain.

Next came the era of microservices. The business logic of an application is split into *meaningful* parts, each developed and maintained by a separate team. Gone are the days of digging through hundreds of megabytes of source code. Great!

But wait, that would be too good to be true. Each microservice is now pretty simple on its own, so where did the magic disappear? You might have guessed it: it hides in the correct integration of the services with each other.

## The Bigger Picture

Recently, I had the luck to be tasked with a source code audit of various microservices for one of our customers. This is pretty uncommon, since what is developed separately is usually tested separately as well. But didnât we just say that integration aspects are essential for this type of architecture? This inadvertently leaves out significant parts of the architecture and often results in wrong assumptions about the guarantees another service provides.

I hope that this article will provide you with a high-impact attack scenario, where the exploitability for each involved microservice on its own is pretty limited. So letâs have a look at the setup:

Parts of the authentication for the numerous services were moved to a central componentâan instance of the OAuth2-Proxy tool. It can be configured as authentication middleware for a Kubernetes cluster by using annotations such as `nginx.ingress.kubernetes.io/auth-signin` and `nginx.ingress.kubernetes.io/auth-url` for the corresponding Ingress resource. In short, incoming requests are checked for valid authentication material and only forwarded to the clusterâs services afterward. If no such material is found, users can automatically be forwarded to a login page.

Actually, this centralized setup was not in scope. On the one hand, it had already been audited shortly before; on the other hand, a source code review targeting custom codeâand not an infrastructure auditâwas commissioned. But in the end, the objective is still the evaluation of the servicesâ security, and that is fundamentally linked to this component.

## Regex, A Never Ending Story

So, besides reviewing the service-specific source code, I started digging through the Ingress and OAuth2-Proxy configuration. From the usage of the services, I already knew that specific paths were excluded from the access restrictions applied by the OAuth2-Proxy. At some point, I stumbled across definitions like the following:

```
skip_auth_routes = [
    ...
    "^/service_one/public_endpoint$",
    "^/service_two/.*/status$",
    ...
]
```

The [documentation](https://oauth2-proxy.github.io/oauth2-proxy/configuration/overview#proxy-options) for this option states the following:
![Excerpt from OAuth2-Proxy documentation](/img/2025-08-13-CVE-2025-54576-skip-auto-route.png)

It is obvious that one will get into huge trouble if the line `^/service_two/.*/status$` is more permissive than expected. From my personal experience, this happens in situations where developers make use of regular expressions with wildcards quite regularly. So, intuition told me to have a short look at the OAuth2-Proxy code base.

## The Bug

Ok, so what does the code flow responsible for excluding certain URL paths from the authentication process look like?

The function [`IsAllowedRequest`](https://github.com/oauth2-proxy/oauth2-proxy/blob/f4b33b64bd66ad28e9b0d63bea51837b83c00ca1/oauthproxy.go#L573) is responsible for evaluating whether authentication can be skipped for an incoming request. One of the supported cases depends on the `skip_auth_routes` option and is realized in the [âisAllowedPathâ](https://github.com/oauth2-proxy/oauth2-proxy/blob/f4b33b64bd66ad28e9b0d63bea51837b83c00ca1/oauthproxy.go#L582) function:

```
func isAllowedPath(req *http.Request, route allowedRoute) bool {
	matches := route.pathRegex.MatchString(requestutil.GetRequestURI(req))

	if route.negate {
		return !matches
	}

	return matches
}
```

One can observe that the configured regex is applied to the return value of [`requestutil.GetRequestURI(req)`](https://github.com/oauth2-proxy/oauth2-proxy/blob/f4b33b64bd66ad28e9b0d63bea51837b83c00ca1/pkg/requests/util/util.go#L37-L44) that takes the incoming request as argument.

```
func GetRequestURI(req *http.Request) string {
	uri := req.Header.Get(XForwardedURI)
	if !IsProxied(req) || uri == "" {
		// Use RequestURI to preserve ?query
		uri = req.URL.RequestURI()
	}
	return uri
}
```

The included comment should directly set everyoneâs alarm bells ringing. It was intended to match the requestâs URL path, not the path AND query component. A short inspection of the values expected to be provided by the `X-Forwarded-URI` HTTP header, and the documentation for the [RequestURI function](https://pkg.go.dev/net/url#URL.RequestURI), confirms that this intention is not met.

Letâs go back to our configuration example. Authentication will be skipped not only for requests to URL paths such as `/service_two/v1/status`, but also for endpoints such as `/service_two/admin` when one adds a suitable final query parameter, e.g., `nonexistingparam=/status`. The above implementation will then try to perform the regex match against the full string `/service_two/admin?nonexistingparam=/status`. Since it is quite common for web applications to ignore unknown query parameters, it is assumed that one can do so without running into problems.

One question remains to be answered, now that requests can be sent to arbitrary endpoints under `/service_two/` without being rejected due to missing authentication: How does the final service determine the user context, since we are not authenticated? This depends on the implementations of the final services and cannot be answered universally. The following sections will therefore assume the test environment present in the original audit. Some aspects of this setup are quite common, so maybe you will identify similarities to environments you know.

## Hello Security In-Depth

The use case of the OAuth2-Proxy tool is quite security-sensitive, and it has to be positively noted that further exploitation of the authentication *bypass* was significantly hindered by one of its defense-in-depth measures. To describe this, I first have to briefly depict the specific s...