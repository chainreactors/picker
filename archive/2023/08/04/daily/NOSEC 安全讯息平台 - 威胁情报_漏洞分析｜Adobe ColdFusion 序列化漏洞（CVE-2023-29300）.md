---
title: 漏洞分析｜Adobe ColdFusion 序列化漏洞（CVE-2023-29300）
url: https://nosec.org/home/detail/5099.html
source: NOSEC 安全讯息平台 - 威胁情报
date: 2023-08-04
fetch_date: 2025-10-04T12:02:26.880282
---

# 漏洞分析｜Adobe ColdFusion 序列化漏洞（CVE-2023-29300）

[![](https://nosec.org/home/image/logo.png)](/)

[登录/注册](https://nosec.org/home/caslogin)

[投稿](https://nosec.org/home/caslogin)

[首页](/home/index)
[威胁情报](/home/index/threaten.html)
[安全动态](/home/index/security.html)
[漏洞预警](/home/index/hole.html)

数据泄露

* [新闻浏览](/home/index/leakage.html)
* [图表统计](/home/index/graphshtml)

[专题报告](/home/index/speech.html)
[技术分析](/home/index/skill.html)
[安全工具](/home/index/tool.html)

# 漏洞分析｜Adobe ColdFusion 序列化漏洞（CVE-2023-29300）

![](https://nosec.org/home/image/headImg.png)GobySec  793天前

# ![goby技术分享.png](/avatar/uploads/attach/image/387eb946f8262c98c6ff4d4a5369356b/goby技术分享.png)

# 0x01 概述

近期，Adobe ColdFusion 发布了多个安全更新，引起了我们的关注。Adobe ColdFusion 是一款基于 Java 的商业应用程序服务器，2023 年 7 月 13 日，ProjectDiscovery 发布了分析文章，我们通过研究 CVE-2023-29300 发现这其实是一个未公开且非常有趣的漏洞，此时官方尚未发布安全补丁，因此我们立即开始寻找新的利用方式。不久之后，ProjectDiscovery 意识到自己公布了 0day 漏洞，紧急删除了分析文章，并等待官方发布安全补丁，具体的时间可参考下文的漏洞时间线。

ProjectDiscovery 公布的利用方式受 JDK 小于 9 的限制，经过测试，这条已公开的 JNDI 利用链成功利用率为 0.6%。其中提到了关于 commons-beanutils 的利用链，经过我们的分析，实际上并不需要使用它，并且还存在其它的利用链。**本文将从 ColdFusion 2023 发布版的 Update 1 安全更新内容入手，详细分析 CVE-2023-29300 的漏洞成因，并提出一些后续的研究方向。****我们在 Goby 中已经集成了 CVE-2023-29300 漏洞的 JNDI 利用链（CVE-2023-38204），实现了命令执行回显和自定义 ldap 服务器地址的功能。**演示效果如下：
![Image](https://s3.bmp.ovh/imgs/2023/07/24/514d4dd7f7e3b52c.gif)

# 0x02 漏洞环境

我们已经在 vulfocus 中集成了开箱即用的环境，版本为 Ubuntu 20.04 + JDK 8u60 + Apache Tomcat 9.0.78 + ColdFusion Release 2023.0.0.330468。拉取镜像：

```
docker pull vulfocus/vcpe-1.0-a-adobe-coldfusion:2023.0.0.330468-openjdk-release
```

启动环境：

```
docker run -d -P vulfocus/vcpe-1.0-a-adobe-coldfusion:2023.0.0.330468-openjdk-release
```

# 0x03 漏洞分析

### **3.1 补丁分析**

7 月 12 日，Adobe 发布了 ColdFusion (2023 release) Update 1 更新。将 patch 包反编译后的代码与更新前的代码进行比对，可以发现 coldfusion.wddx.DeserializerWorker#startElement() 方法中的明显变化：

![patch.png](/avatar/uploads/attach/image/1de0c194c8c8f9214a67338a5d108e3b/patch.png)

新增的 validateWddxFilter() 方法如下。

```
private void validateWddxFilter(AttributeList atts) throws InvalidWddxPacketException {

    String attributeType = atts.getValue("type");

    if (attributeType.endsWith(";")) {

        attributeType = attributeType.replace(";", "");

    }

    if (attributeType.startsWith("L")) {

        String attributeTypeCopy = attributeType;

        validateBlockedClass(attributeTypeCopy.replaceFirst("L", ""));

    }

    validateBlockedClass(attributeType);

}

private void validateBlockedClass(String attributeType) throws InvalidWddxPacketException {

    if (attributeType != null && !attributeType.toLowerCase().startsWith("coldfusion") && !attributeType.equalsIgnoreCase(StructTypes.ORDERED.getValue()) && !attributeType.equalsIgnoreCase(StructTypes.CASESENSITIVE.getValue()) && !attributeType.equalsIgnoreCase(StructTypes.ORDEREDCASESENSITIVE.getValue()) && WddxFilter.invoke(attributeType)) {

        throw new InvalidWddxPacketException();

    }

}
```

搜索相关文档可知，ColdFusion 实现了一种叫做 WDDX（Web Distributed Data Exchange，Web 分布式数据交换）的古老的 xm l 技术。通过实现 WDDX，可以使变量（包括名称，数据类型和值）序列化成一个 xm l 文档，应用程序可通过反序列化此 xm l 文档，来重新建立这些变量。

## **3.2 WDDX 序列化**

实现了 coldfusion.wddx.Wddxob jectSerializer 接口的各个序列化器能够对数据进行 WDDX 序列化，如 StringSerializer，NumberSerializer，BeanSerializer 等等。我们尝试使用 BeanSerializer 对自定义的 Java Bean 进行序列化，调试过程中也可以看到对象类型与序列化器默认的映射关系。

![serializer.png](/avatar/uploads/attach/image/80f6e08724c5bae363b1bfaaeefdc178/serializer.png)输出的序列化结果格式如下。

```
<wddxPacket version='1.0'>

    <header/>

    <data>

        <struct type='LJavaBean;'>

            <var name='age'>

                <number>233.0</number>

            </var>

            <var name='name'>

                <string>233</string>

            </var>

        </struct>

    </data>

</wddxPacket>
```

对应地，反序列化由 coldfusion.wddx.WddxDeserializer 类实现。对于 ColdFusion 来说，WDDX 中的每个元素都是一个 WddxElement，不同的元素对应着不同的 Handler 处理类，例如 <string> 标签中的元素与属性将由 StringHandler 处理，<struct> 标签会由 StructHandler 处理。其中我们关注 on startElement() 和 onEndElement() 方法。

```
public void on startElement(String name, AttributeList attributes) throws WddxDeserializationException {

    this.m_strictType = attributes.getValue("type");

    //...

}
```

```
public void onEndElement() throws WddxDeserializationException {

    if (this.m_strictType == null) {

        // ...

    } else {

        Class beanClass = null;

        ob ject bean = null;

        try {

            beanClass = getClassBySignature(this.m_strictType);

            bean = beanClass.getDeclaredConstructor().newInstance();

            this.setBeanProperties(bean, this.m_ht);

            this.setTypeAndValue(bean);

        } catch (Exception var6) {

            // ...

        }

    }

}
```

on startElement() 和 onEndElement() 是 SAX 解析器（Simple API for xm l）中的回调方法，分别在解析到 xm l 元素的开始和结束标签时被调用。可以看到 <struct> 标签的 type 属性将在 on startElement() 方法中被赋值给变量 m\_strictType。跟进 getClassBySignature() 方法。

```
private static Class getClassBySignature(String jniTypeSig) throws ClassNotFoundException {

    int index = 0;

    char c = jniTypeSig.charAt(index);

    String className;

    switch (c) {

        // ...

        default:

            className = jniTypeSig.substring(index + 1, jniTypeSig.length() - 1);

            return Class.forName(className);

        // ...

    }

}
```

很明显，这里首先会截掉 type 属性的前后两字符，然后将剩下的字符串视作类名，调用 Class.forName() 方法进行类加载，并紧接着在 onEndElement() 方法中调用其无参构造。接下来 StructHandler#setBeanProperties() 方法中存在明显的 Method#invoke() 操作，目的是调用目标对象的 setter 方法，为刚刚被实例化的对象属性赋值。由于代码片段较长，这里就不贴出了。

至此，我们可以得出结论：ColdFusion 的 WDDX 序列化与反序列化机制和 FastJson 很相似，都是基于目标对象的 getter 和 setter 方法，并在序列化和反序列化阶段自动调用。回头看安全更新的内容，如果没有过滤传入的 type 属性，那就类似于 FastJson 1.2.24 版本的情况，攻击者可以利用这个漏洞，实例化任意存在无参构造方法的类，并进一步调用其指定的 setter 方法，而且还可以控制参数。这无疑是存在漏洞利用的风险的。

## **3.3 参数传入分析**

为了寻找传入序列化 payload 并触发反序列化的途径，我们在 Jadx 中全局搜索 WddxDeserializer#deserialize() 方法的引用，据此跟进 coldfusion.filter.FilterUtils#WDDXDeserialize()。

```
public static ob ject WDDXDeserialize(String str) throws Throwable {

    WddxDeserializer deserializer = new WddxDeserializer();

    InputSource source = new InputSource(new StringReader(str));

    return deserializer.deserialize(source);

}
```

继续搜索 WDDXDeserialize() 的引用，跟进 FilterUtils#GetArgumentCollection()

```
public static Map GetArgumentCollection(FusionContext context) throws Throwable {

    ServletRequest request = context.request;

    String attr = (String)context.pageContext.findAttribute("url.argumentCollection");

    if (attr == null) {

        attr = (String)context.pageContext.findAttribute("form.argumentCollection");

    }

    Struct argumentCollection;

    if (attr == null) {

        // ...

    } else {

        attr = attr.trim();

        if (attr.charAt(0) == '{') {

            // ...

        } else {

            argumentCollection = (Struct)WDDXDeserialize(attr);

        }

    }

    // ...

    return argumentCollection;

}
```

分析 findAttribute() 方法可知，参数为 url.xxx 表示从请求的 URL 中获取 xxx 的参数值，form.yyy 表示从上传的表单中获取 yyy 的参数值。继续向上追溯，最终定位到 coldfusion.filter.ComponentFilter#invoke() 方法中。ComponentFilter 是一个继承了 FusionFilter 抽象类的过滤器，既然和过滤器扯上了关系，第一步肯定就是检查 web.xm l 配置文件了。

```
<servlet-mapping id="coldfusion_mapping_4">    <servlet-name>CFCServlet</servlet-name>    <url-pattern>*.cfc</url-pattern></servlet-mapping>
```

可知解析 .cfc 页面的 Servlet 即 CFCServlet。跟进 CFCServlet 的 getCFCFilterChain() 方法。

```
private FusionFilter getCFCFilterChain(ServletRequest request) {

  FusionFilter filter = new ComponentFilter();

  FusionFilter filter = new ApplicationFilter(filter, 3);

  // ...

  FusionFilter filter = new MonitoringFilter((FusionFilter)filter, "CFC REQUEST");

  filter = new PathFilter(filter, this);

  // ...

  FusionFilter filter = new ExceptionFilter((FusionFilter)filter);

  FusionFilter filter = new ClientScopePersistenceFilter(filter);

  FusionFilter filter = new BrowserFilter(filter);

  FusionFilter filter = new NoCacheFilter(filter);

  boolean needsFormScope = true;

  FusionFilter filter = new GlobalsFilter(filter, true);

  FusionFilter filter = new DatasourceFilter(filter);

  r...