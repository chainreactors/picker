---
title: 铸网-2025”山东省工业互联网网络安全职业技能竞赛wp（职工组） - 渗透测试中心
url: https://www.cnblogs.com/backlion/p/19089846
source: 博客园 - 渗透测试中心
date: 2025-09-14
fetch_date: 2025-10-02T20:09:06.590607
---

# 铸网-2025”山东省工业互联网网络安全职业技能竞赛wp（职工组） - 渗透测试中心

[![](https://img2024.cnblogs.com/blog/35695/202509/35695-20250929100304557-587378723.jpg)](https://qoder.com/)

* [![博客园logo](//assets.cnblogs.com/logo.svg)](https://www.cnblogs.com/ "开发者的网上家园")
* [会员](https://cnblogs.vip/)
* [众包](https://www.cnblogs.com/cmt/p/18500368)
* [新闻](https://news.cnblogs.com/)
* [博问](https://q.cnblogs.com/)
* [闪存](https://ing.cnblogs.com/)
* [赞助商](https://www.cnblogs.com/cmt/p/19081960)
* [HarmonyOS](https://harmonyos.cnblogs.com/)
* [Chat2DB](https://chat2db-ai.com/)

* ![搜索](//assets.cnblogs.com/icons/search.svg)
  ![搜索](//assets.cnblogs.com/icons/enter.svg)
  + ![搜索](//assets.cnblogs.com/icons/search.svg)

    所有博客
  + ![搜索](//assets.cnblogs.com/icons/search.svg)

    当前博客
* [![写随笔](//assets.cnblogs.com/icons/newpost.svg)](https://i.cnblogs.com/EditPosts.aspx?opt=1 "写随笔")
  [![我的博客](//assets.cnblogs.com/icons/myblog.svg)](https://passport.cnblogs.com/GetBlogApplyStatus.aspx "我的博客")
  [![短消息](//assets.cnblogs.com/icons/message.svg)](https://msg.cnblogs.com/ "短消息")
  ![简洁模式](//assets.cnblogs.com/icons/lite-mode-on.svg)

  [![用户头像](//assets.cnblogs.com/icons/avatar-default.svg)](https://home.cnblogs.com/)

  [我的博客](https://passport.cnblogs.com/GetBlogApplyStatus.aspx)
  [我的园子](https://home.cnblogs.com/)
  [账号设置](https://account.cnblogs.com/settings/account)
  [会员中心](https://vip.cnblogs.com/my)
  简洁模式 ...
  退出登录

  [注册](https://account.cnblogs.com/signup)
  登录

[![返回主页](/skins/custom/images/logo.gif)](https://www.cnblogs.com/backlion/)

# [渗透测试中心](https://www.cnblogs.com/backlion)

##

* [博客园](https://www.cnblogs.com/)
* [首页](https://www.cnblogs.com/backlion/)
* [新随笔](https://i.cnblogs.com/EditPosts.aspx?opt=1)
* [联系](https://msg.cnblogs.com/send/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%BF%83)
* [管理](https://i.cnblogs.com/)
* 订阅
  [![订阅](/skins/coffee/images/xml.gif)](https://www.cnblogs.com/backlion/rss/)

# [铸网-2025”山东省工业互联网网络安全职业技能竞赛wp（职工组）](https://www.cnblogs.com/backlion/p/19089846 "发布于 2025-09-13 23:14")

# ICS

## 失窃的工艺

下载后test.PCZ文件，需要使用力控软件打开。

但电脑没有安装这个软件，尝试把后缀名改为.zip，解压后直接搜索flag文本：

![image-20250909163733777](https://img2024.cnblogs.com/blog/1049983/202509/1049983-20250913231429931-1816624985.png)

成功在文件中找到flag：flag{D076-4D7E-92AC-A05ACB788292}。

## 工控协议分析

WireShark打开分析，追踪TCP流，flag被逐字符藏在流量中：

![image-20250909165641380](https://img2024.cnblogs.com/blog/1049983/202509/1049983-20250913231430736-1222887581.png)

拼凑起来得到flag：flag{c93650241853da240f9760531a79cbcf}。

# Misc

## 总线流量分析

> 一辆汽车在试验道路上行驶，测试人员监控了一段时间的车内通信报文，报文抓取时间间隔为36s，尝试找出与仪表显示车速相关的CAN通信报文，估算车辆在这段时间的行驶路程（m）得到flag。已知车速在80千米每小时左右，车速信息只占用1字节长度，且具备较高优先级。flag{行驶路程距离}

打开后按ID分组观察，根据题目提示找只有1字节变化的can报文：

![image-20250909163749620](https://img2024.cnblogs.com/blog/1049983/202509/1049983-20250913231431499-1374372094.png)

发现ID=0x0000280的can报文数据只有1字节在变化且在0x50左右浮动，说明速度为80km/h左右。

编写脚本计算即可：

```
speeds_hex = ["46","48","50","50","55","58","52","5A","58","58",
              "56","54","55","4F","4F","4F","4D","4D","4D","4E",
              "4E","53","56","56","59","59","51","52","4F","46"]

speeds = [int(h,16) for h in speeds_hex]
delta_t = 36

distance_km = 0
for v in speeds:
    distance_km += v * delta_t / 3600

distance_m = distance_km * 1000
print(distance_km, distance_m)

# 24.469999999999995 24469.999999999996
# flag{24470}
```

## OTA流量分析

车机/IOT设备的OTA（Over-The-Air）流程：

1. 设备发起请求到服务器，比如 /api/v1/vehicle/handshake，带上设备信息。
2. 服务器生成一个 会话密钥 session\_key，通过 HTTPS 或者加密通道下发给设备。
3. 后续敏感数据（固件包、授权信息）会用这个 session\_key 进行对称加密（常见 AES-CBC/CTR）。
4. 设备用 session\_key 解密得到明文，然后执行升级或拿到控制指令。

编写脚本：

```
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
extract_ota_flag.py
Usage:
  pip install scapy pycryptodome
  python3 extract_ota_flag.py ota.pcapng

What it does:
  - 尝试用 scapy 读取 pcap 并抽取 TCP/UDP payload（若 scapy 不可用则直接读取原始 pcap 字节进行搜索）
  - 搜索 HTTP 区段、提取 session_key、查找长 base64 段并 decode
  - 假设 decoded blob 为 IV(16) + AES-CBC(ciphertext)，使用每个 session_key (hex -> bytes) 作为 AES-256 key 遍历解密
  - 尝试移除 PKCS#7 填充并解析为文本，输出含 'flag{' 的解密文本
"""
import sys
import os
import re
import json
import base64
from pathlib import Path

pcap_path = Path(sys.argv[1]) if len(sys.argv) > 1else Path("ota.pcapng")
ifnot pcap_path.exists():
    print("pcap not found:", pcap_path)
    sys.exit(1)

# helpers
def find_session_keys(text):
    keys = set()
    # match "session_key": "hex..."
    for m in re.finditer(r'"session_key"\s*:\s*"([0-9a-fA-F]{32,128})"', text):
        keys.add(m.group(1))
    return keys

def find_long_base64(text, min_len=80):
    # return unique base64-like substrings (alnum+/ and optional padding)
    found = set()
    for m in re.finditer(r'([A-Za-z0-9+/]{%d,}={0,2})' % min_len, text):
        found.add(m.group(1))
    return list(found)

# Try scapy first (if installed)
payload_blobs = []  # list of bytes objects
http_texts = []     # list of decoded http-like text blocks
try:
    from scapy.all import rdpcap, TCP, UDP, Raw
    pkts = rdpcap(str(pcap_path))
    sessions = pkts.sessions()
    for s, pkts in sessions.items():
        data = bytearray()
        for p in pkts:
            if p.haslayer(Raw):
                data.extend(bytes(p[Raw].load))
        if data:
            # try decode for text
            try:
                txt = data.decode('utf-8', errors='replace')
                if"HTTP"in txt or"POST"in txt or"GET "in txt or"session_key"in txt:
                    http_texts.append(txt)
            except Exception:
                pass
            payload_blobs.append(bytes(data))
    print("scapy path used: extracted %d payload blobs, %d http text blocks" % (len(payload_blobs), len(http_texts)))
except Exception as e:
    # fallback: raw bytes search (robust when scapy not installed)
    print("scapy not available or failed (%s). Falling back to raw-byte scan." % e)
    raw = pcap_path.read_bytes()
    # extract long printable runs (likely HTTP payloads)
    runs = []
    cur = bytearray()
    for b in raw:
        if32 <= b < 127:
            cur.append(b)
        else:
            if len(cur) >= 40:
                runs.append(bytes(cur))
            cur = bytearray()
    if len(cur) >= 40:
        runs.append(bytes(cur))
    for r in runs:
        try:
            txt = r.decode('utf-8', errors='replace')
            http_texts.append(txt)
        except:
            pass
    # also keep raw as one blob for base64 search
    payload_blobs.append(raw)
    print("raw scan found %d printable runs, payload_blobs=%d" % (len(runs), len(payload_blobs)))

# gather session keys from http_texts
session_keys = set()
for t in http_texts:
    session_keys |= find_session_keys(t)

print("session_key candidates found:", session_keys)

# gather base64 candidates from http_texts and from raw payload blobs (text decode)
b64_candidates = set()
for t in http_texts:
    for b in find_long_base64(t):
        b64_candidates.add(b)
# also scan payload blobs as text for base64
for blob in payload_blobs:
    try:
        txt = blob.decode('utf-8', errors='replace')
        for b in find_long_base64(txt):
            b64_candidates.add(b)
    except:
        pass

print("base64 candidates found:", len(b64_candidates))

# decode base64 candidates to binary blobs
decoded_blobs = []
for b64 in b64_candidates:
    try:
        data = base64.b64decode(b64)
        if data:
            decoded_blobs.append(data)
    except Exception:
        continue

print("decoded binary blobs:", len(decoded_blobs))

# AES decryption attempts using session_keys
try:
    from Crypto.Cipher import AES
    have_crypto = True
except Exception:
    have_crypto = False
    print("PyCryptodome not found. Install with: pip install pycryptodome")

found = []
if have_crypto and decoded_blobs and session_keys:
    for blob in decoded_blobs:
        if len(blob) <= 16:
            continue
        iv = blob[:16]
        ct = blob[16:]
        for keyhex in session_keys:
            try:
                key = bytes.fromhex(keyhex)
                if len(key) notin (16,24,32):
                    # try require 3...