---
title: Exploiting a Quarantine UAF Mitigation on a Custom Allocator Challenge
url: https://www.hacktivesecurity.com/index.php/2024/11/12/exploiting-a-quarantine-uaf-mitigation-on-a-custom-allocator-challenge/
source: Over Security - Cybersecurity news aggregator
date: 2024-12-03
fetch_date: 2025-10-06T19:41:41.724455
---

# Exploiting a Quarantine UAF Mitigation on a Custom Allocator Challenge

* info@hacktivesecurity.com
* Mon - Fri: 9.00 am - 6.00 pm

Advanced Security Solutions to protect the Cyberspace.

[Twitter](https://x.com/hacktivesec)

[Facebook-f](https://www.facebook.com/hacktivesec)

[Linkedin-in](https://www.linkedin.com/company/hacktive-security/)

[Instagram](https://www.instagram.com/hacktivesec/)

[![Hacktive Security](https://www.hacktivesecurity.com/wp-content/uploads/2024/10/logo_hs-1.png)](https://www.hacktivesecurity.com/)

* [Home](https://www.hacktivesecurity.com/)
* [About Us](https://www.hacktivesecurity.com/about-us/)
* Services
  + [Penetration Testing](https://www.hacktivesecurity.com/penetration-testing/)
  + [Red Teaming](https://www.hacktivesecurity.com/red-teaming/)
  + [Secure Code Review](https://www.hacktivesecurity.com/secure-code-review/)
  + [Training](https://www.hacktivesecurity.com/training/)
  + [Compliance](https://www.hacktivesecurity.com/compliance/)
* [Blog](https://www.hacktivesecurity.com/blog/)
* [Careers](https://www.hacktivesecurity.com/careers/)
* [Contacts](https://www.hacktivesecurity.com/contacts/)

Search for:

### Have Any Questions?

+39-06-8773-8747

[free quote](https://www.hacktivesecurity.com/index.php/contacts/)

[![Hacktive Security](https://www.hacktivesecurity.com/wp-content/uploads/2024/10/logo_hs-1.png)](https://www.hacktivesecurity.com/)

Search for:

* [Home](https://www.hacktivesecurity.com/)
* [About Us](https://www.hacktivesecurity.com/about-us/)
* Services
  + [Penetration Testing](https://www.hacktivesecurity.com/penetration-testing/)
  + [Red Teaming](https://www.hacktivesecurity.com/red-teaming/)
  + [Secure Code Review](https://www.hacktivesecurity.com/secure-code-review/)
  + [Training](https://www.hacktivesecurity.com/training/)
  + [Compliance](https://www.hacktivesecurity.com/compliance/)
* [Blog](https://www.hacktivesecurity.com/blog/)
* [Careers](https://www.hacktivesecurity.com/careers/)
* [Contacts](https://www.hacktivesecurity.com/contacts/)

[![Hacktive Security](http://176.31.202.211/wp-content/uploads/2024/10/logo_hs-1.png)](https://www.hacktivesecurity.com/)

Over 10 years we help companies reach their financial and branding goals. Engitech is a values-driven technology agency dedicated.

#### Gallery

[![](https://www.hacktivesecurity.com/wp-content/uploads/2019/11/project11-720x720.jpg)](https://www.hacktivesecurity.com/wp-content/uploads/2019/11/project11.jpg)

[![](https://www.hacktivesecurity.com/wp-content/uploads/2019/11/project10-720x720.jpg)](https://www.hacktivesecurity.com/wp-content/uploads/2019/11/project10.jpg)

[![](https://www.hacktivesecurity.com/wp-content/uploads/2019/11/project4-720x720.jpg)](https://www.hacktivesecurity.com/wp-content/uploads/2019/11/project4.jpg)

[![](https://www.hacktivesecurity.com/wp-content/uploads/2019/11/project6-720x720.jpg)](https://www.hacktivesecurity.com/wp-content/uploads/2019/11/project6.jpg)

[![](https://www.hacktivesecurity.com/wp-content/uploads/2019/11/project2-720x720.jpg)](https://www.hacktivesecurity.com/wp-content/uploads/2019/11/project2.jpg)

[![](https://www.hacktivesecurity.com/wp-content/uploads/2019/11/project1-720x720.jpg)](https://www.hacktivesecurity.com/wp-content/uploads/2019/11/project1.jpg)

#### Contacts

Via Giosuè Carducci, 21 - Pomigliano d'Arco (Italy)
Paseo Montjuic, número 30 - Barcelona (Spain)

info@hacktivesecurity.com

+39 06 8773 8747

[Twitter](#hacktivesec)

Facebook-f

Pinterest-p

Instagram

# Hacktive Blog

* [Home](https://www.hacktivesecurity.com)
* [Blog](https://www.hacktivesecurity.com/blog/)
* [Exploitation](https://www.hacktivesecurity.com/blog/category/expl/)
* Exploiting a Quarantine UAF Mitigation on a Custom Allocator Challenge

[Exploitation](https://www.hacktivesecurity.com/blog/category/expl/)

![](https://www.hacktivesecurity.com/wp-content/uploads/2024/11/free.jpg)

\_ [November 12, 2024](https://www.hacktivesecurity.com/blog/2024/11/12/exploiting-a-quarantine-uaf-mitigation-on-a-custom-allocator-challenge/)\_ [Alessandro Groppo](https://www.hacktivesecurity.com/blog/author/kiks/)\_ [0 Comments](https://www.hacktivesecurity.com/blog/2024/11/12/exploiting-a-quarantine-uaf-mitigation-on-a-custom-allocator-challenge/#respond)

### Exploiting a Quarantine UAF Mitigation on a Custom Allocator Challenge

## Introduction

In the previous blog post ([A Reverse Engineering Walkthrough Journey](https://blog.hacktivesecurity.com/index.php/2024/11/04/a-reverse-engineering-walkthrough-journey/)) we have covered a walkthrough guide to solve the Reverse Engineering challenge written for the [NoHat24](https://www.nohat.it/) security conference. In this blog post, we are going to cover the binary exploitation challenge that involves a custom userland allocator that has been specifically developed for this challenge. Writing our own allocator, remotely inspired from the kernel SLUB allocator, was a really fun and educational experience. We have implemented an Use-After-Free quarantine mitigation to prevent its exploitation, was it good enough?

## Introducing the Custom Allocator

The custom allocator source code was available through an HTTP web interface and can now be download directly from [here](https://github.com/hacktivesec/nohat24-blog-references/tree/main/pwn). Two files, `hmalloc.h` and `hmalloc.c`, contains the whole implementation of the custom allocator that replaces the standard glibc malloc. The following diagram and structs describes the allocator design:

![](http://www2.hacktivesecurity.com/wp-content/uploads/2024/10/image-1-1.png)

```
struct list_head{
  struct list_head* next;
  struct list_head* prev;
};

struct bucket{
  struct list_head  buckets;
  /* Offset of the available alloc inside the bucket */
  uint16_t  offset;
  /* How many allocs are freed */
  uint8_t   freelist_count;
  uint8_t   freelist[MAX_ALLOCS];
  void*     allocs[];
};

/* Single allocations just contain the size of the alloc as metadata */
struct alloc{
  uint16_t size;
  void*   user[];
} __attribute__((packed));
```

The target allocator, inspired from the kernel SLUB allocator, has a simple “bucket” concept. Each allocation size (from 16 to 1024) has its own memory region retrieved from `mmap` (through `__init_bucket`) and it is considered a `SMALL_BUCKET`, while larger buckets (`LARGE_BUCKETS`) are not handled from the allocator. A Bucket Master Control (`bucket_master_ctrl` global variable inside `hmalloc.c`) is used to store buckets’ addresses using an offset that can be used to retrieve the requested bucket for the needed size. The size of the allocation is the offset minus the size of a pointer. For example, the bucket address for 32 bytes allocations is at offset 24 (32-8).

When `malloc` is called the first time with a specific size, that is always rounded to the nearest power of two starting from 32 (e.g. 32, 64, 128, 256, 512, 1024), the bucket is allocated through `__init_bucket` and referred to as the `current_bucket`. The current bucket is the bucket from where we try to initially allocate from. It can be retrieved, once allocated, using `__get_bucket`. Each allocation, named `alloc` inside the source code, contains just the size of the allocation as metadata and `alloc->user` is the returned `malloc` pointer. When an `alloc` is allocated from a `bucket`, the `bucket->offset` is incremented by one and used for the next allocations to return subsequent memory addresses (it is always multiplied with the allocation size). The offset does not just provides the capability to return new allocations but also marks and identifies freed allocations inside the bucket. A freelist is implemented to first return freed memory (to avoid fragmentation) with a LIFO mechanism. `bucket->freelist` is an array of freed `allocs` (based on their offsets) that can be accessed with the `bucket->freelist_count` that is incremented every time an `alloc` is freed and decremented when a freed allocation is returned back to the user. This “dynamic” array permits to handle the fr...