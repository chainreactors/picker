---
title: DataCon2024解题报告WriteUp—漏洞分析赛道
url: https://mp.weixin.qq.com/s?__biz=MzU5Njg1NzMyNw==&mid=2247489123&idx=1&sn=228fa0630cebdc58c6b961b96752dc2f&chksm=fe5d0ee3c92a87f539db8736eee19d3b20b91e5cf731b6a9630bc1339b0cd1dfb5e2e9ecca66&scene=58&subscene=0#rd
source: DataCon大数据安全分析竞赛
date: 2025-01-19
fetch_date: 2025-10-06T20:09:03.780176
---

# DataCon2024解题报告WriteUp—漏洞分析赛道

![cover_image](https://mmbiz.qpic.cn/mmbiz_jpg/RicNZQMn3FU6oqoiaQrhDPSFO0eaZFhqNfFFxSB1dYib9jutia1KQZfQhictq4Lds4AmibmYnVaQRxwc4oziaictTFxwuQ/0?wx_fmt=jpeg)

# DataCon2024解题报告WriteUp—漏洞分析赛道

​0817iotg战队

DataCon大数据安全分析竞赛

2024年11月28日，DataCon2024大数据安全分析竞赛落下帷幕。比赛共吸引706支战队、1556人报名参与。在历经多日的激烈角逐后，最终诞生了五大赛道的冠军、亚军和季军。来自**武汉大学的“0817iotg”战队荣获漏洞分析赛道冠军**，本期为大家分享**“0817iotg”战队的解题报告。**

![](https://mmbiz.qpic.cn/mmbiz_png/RicNZQMn3FU6oqoiaQrhDPSFO0eaZFhqNffmGEFbAMNod38RXMcdKZe04O4MtlxicczyCib5hSurL4PnodY2dWasGg/640?wx_fmt=png&from=appmsg)[篇幅较长，建议点赞收藏]

**一、大模型应用——情报提取**

**1.1 题目背景**

在进行漏洞挖掘工作时，对特定目标的历史漏洞挖掘经验的学习是至关重要的一步。然而，传统的搜索引擎在面对海量数据时往往显得效率低下，难以快速有效地获取所需的关键信息。近年来，随着人工智能大模型技术的发展及其在自然语言处理方面的显著进步，利用大模型从海量漏洞分析文章中提取关键知识已经成为一种可行的方法。本挑战要求选手利用大模型技术，对漏洞分析文章进行高效梳理，从中提取出有价值的摘要信息，任务包括但不限于：文献整理、文本预处理、关键信息提取、摘要生成、结果验证等。

**1.2 实验/项目环境**

* **操作系统：**Ubuntu 22.04 / Windows 10
* **开发语言：**Python 3.10
* **第三方库：**langchain、BeautifulSoup4、paddle

**1.3 技术实现的核心思路**

* 使用BeautifulSoup4解析html文件，去除图片等无用信息。
* 运用提示工程方法生成精细化提示，拆分输出维度，使用两次大模型调用分别判定不同输出维度。
* 运用投票模型检查结果，减少大模型输出内容的不确定性，并且去除不合理结果。
* 扩展框架功能与识别范围，使其能够识别版本、修复建议；提取POC/EXP代码；以及支持图片内容识别。

![](https://mmbiz.qpic.cn/mmbiz_png/RicNZQMn3FU6oqoiaQrhDPSFO0eaZFhqNfapwoqEvBQZQ0jXtaibBykzWRnLxDx4B9sWQVuWaCrA4cCc4VUzWeiaXw/640?wx_fmt=png&from=appmsg)

**1.4 技术实现的具体步骤**

**1.4.1 步骤1：环境配置**

**python或python虚拟环境运行****：**使用pip安装langchain、langchain\_openai、BeautifulSoup4、paddle（仅被用于读取HTML中图片信息），配置test.py中的data\_dir、answer\_dir、key\_env和base\_env，然后使用python调用test.py运行

**使用docker运行****：**使用下述代码导入镜像，挂载数据集目录与输出目录，提供API\_key并运行镜像

![](https://mmbiz.qpic.cn/mmbiz_png/RicNZQMn3FU6oqoiaQrhDPSFO0eaZFhqNfUfSUW6VtXR3EX0L1FoxcFZZ0cbnCDia8rJ5uGDNI64jBHDqB7ic9iasXQ/640?wx_fmt=png&from=appmsg)

**1.4.2 步骤2：html文件信息提取**

在提取html文件信息内容时，我们主要关注以下几点：（1）如何完整提取文本的具体内容与相关代码；（2）在提取的过程中尽可能筛除无关信息，来防止提示词超出token上限；（3）如果超出了8000词的token上限，该如何处理；（4）如何在不丢失完整文本语义的情况下，处理长文本内容。**接下来是我们解决方案的详细介绍：**

**简单的文件信息提取：**通过BeautifulSoup库来进行html文件内容的解析

![](https://mmbiz.qpic.cn/mmbiz_png/RicNZQMn3FU6oqoiaQrhDPSFO0eaZFhqNfkUV3gWaKibYY43PfDypDiajZHcibichJLhkBqKJqApK88IewKD6QsQDM0g/640?wx_fmt=png&from=appmsg)

在解析之后，我们主要关注html中更具价值的<p>、<code>等标签的提取，而html文件中的无关内容，如<script>、<style>、<noscript>、<header>、<footer>等标签，则进行排除。接下来通过soup.get\_text()来获取html文件中的主要文本内容，经过这一步后，获取到的文本已经能够完整的包含题目所要求的具体信息。

**超过token上限的处理:** 在题目所给的大语言模型api中，单次提问仅支持8k token的上限，而提示词的设计往往便需要占据将近2k个token，因此，如果简单把上一步提取的文本和提示词进行拼接，再喂给大模型，很容易超出token上限，从而导致运行报错，因此需要进一步对文本进行处理，**这里我们主要实现了三种思路：**

* **利用 tiktoken库根据token数截取：**在超过8k token的上限后，截掉超过8000的内容，由于一个token并没有对应的字符数，因此很难通过字符串长度来判定，这里我们具体通过tiktoken库来实现，通过分词器来对传入的提示内容进行统计，并按照`token`划分标准进行切分，最后统计前8k个token来作为完整的提示内容调用大模型api，但是这样处理存在的问题在于，程序每次运行前，均需要联网下载编码库cl100k\_base，从而在后续能够根据编码标准进行具体的token划分。然而，本题最终需要在不联网的环境下运行，因此我们后来发现上述思路并不适用。
* **自适应截取：**在前一种思路不可行的前提下，我们选择设定字符串长度上限，来防止token数超过提示上限，同时初步设置字符串上限长度为18000，但是这样在处理存在大量反汇编代码等占用token数过多的案例时，仍然不能完全覆盖，因此我们最终设计了函数check\_output\_regex，根据提问后的报错输出，来调整字符串长度，在每次案例提问中，设置一个初始长度上限18000，后续每一次报错，长度上限减2000，直至不再报错。
* **文本与代码分离进行分标签提取：**为了保证文本内容的完整性，以及分析的有效性，我们同样设计了将文本标签<p>和代码标签<code>分开提取，同时将原先文本中的内容用一个占位标识符来替代，这样可以大模型的记忆功能，先只提供具体文本内容给大模型分析，并提示大模型，如果分析需要，请告诉我需要的代码片段编号，然后我们再根据编号返回特定的代码片段。

**1.4.3 步骤3：运用提示工程的大模型情报提取**

**输出维度拆分：**如数据说明所述，此部分共需利用大模型提取7个维度（除去文件名）的信息，分别是：

* 文件名、漏洞编号、厂商或产品名、编程语言、是否有漏洞成因分析、危险函数名、是否有POC/EXP、是否有POC/EXP解释

  由于单次分析过于复杂的任务时，大模型的分析能力可能会降低，我们对上述输出维度进行了拆分。经过分析发现，漏洞成因部分需要通过分析相应代码及漏洞危险函数获得，同时漏洞危险函数确定则相应的编程语言也随之确定。而是否存在POC/EXP以及是否有POC/EXP解释两个维度也相应高度绑定且与前面漏洞语言等维度并无直接关联。因此决定7个维度划分成两部分：
* 文件名、漏洞编号、厂商或产品名、编程语言、是否有漏洞成因分析、危险函数名
* 是否有POC/EXP、是否有POC/EXP解释

**提示词设计原则：**设计提示词时，我们主要考虑了以下原则

* 分步设计：将分析规则拆分为不同步骤，确保分析流程清晰，每个关键点都被充分覆盖。
* 优先级规则：针对单一输出维度设置优先级规则，确保在多种可能情况下，始终提取最相关的内容。
* 提供具体案例：面对`是否存在解释`类型的任务时，大模型总倾向于认为解释是存在的，我们需要给定更加精细化的案例，告诉模型什么程度的解释才是足够的。
* 临时输出维度：针对某些复杂规则，增加一些临时输出维度辅助判断。
* 规范化输出：提供结构化的 JSON 输出，便于脚本进一步处理。

下面依次对这两部分的提示工程模块进行分析。

**1.4.3.1 第一部分提示词撰写**

需要分析的内容包含以下字段：

1.Vulnerability ID：漏洞编号（CVE ID）。
2.Vendor or Product Name：供应商或产品名称。
3.Programming Language：使用的编程语言。
4.Backtrace Lanuage：调用栈中的编程语言（可选）。
5.Is Cause Analysis：是否包含漏洞原因分析。
6.Dangerous Function：危险函数。

有的文章中不提供危险函数，但是提供了POC代码和stack trace调用栈信息。此时，大模型倾向于认为POC代码语言是漏洞触发点语言；还有一些危险函数表明是C语言函数，但是调用栈中却存在C++特征；为了规避这些误区，让大模型检测出存在漏洞的代码的实际编程语言，我们在此处多定义了一项Backtrace Lanuage字段，用于分析调用栈中的编程语言信息。

![](https://mmbiz.qpic.cn/mmbiz_png/RicNZQMn3FU6oqoiaQrhDPSFO0eaZFhqNfoF6ibaliahnFOKlowiaDKxn96qvDOfuXL9P71IGpl5gkYlWiauAPKw1oPw/640?wx_fmt=png&from=appmsg)

接下来，我们要求大模型必须**按照我们设计的步骤一步一步进行分析**，否则模型可能在单词分析中“囫囵吞枣”，漏掉某些步骤与信息，然后是提供给大模型的具体判断规则：

**分析文章内容中包含的漏洞编号（Vulnerability ID）：**1、如果有多个 CVE ID，选择与上下文最相关的。2、如果没有明确的 CVE ID，输出 NULL。以及判断相关性时，需关注 CVE ID 所在段落与漏洞描述是否一致。

**确定文章内容中漏洞的供应商或产品名称（Vendor or Product Name）：**1、从 vender\_list 中匹配。2、若有多个供应商，选择最靠近 CVE ID 信息的供应商。3、如果找不到供应商，输出 NULL。4、根据出题规则在大模型返回运行结果后进行进一步处理，对于vender\_list中存在依赖关系的项目，优先选择涵盖范围更大的厂商名或者原文中有直接引用的厂商名。

**确定文章内容中漏洞的编程语言（Programming Language）：**1、从 language\_list 中匹配。2、如果涉及多个语言，选择最接近漏洞触发点或危险函数的语言。3、IoT 产品的默认语言为 "C"。

**确定文章内容中漏洞的调用栈语言（可选）（Bactracek Lanuage）：**1、如果调用栈包含 C++ 特征（如 :: 或 .cpp 文件名），输出 C++。2、默认值为 `NULL`，表示没有后端。

**判断文章内容中是否存在危险函数（Dangerous Function）：**1、优先考虑代码中直接提到的危险函数（如 strcpy, memmove）。2、如果没有直接提到，尝试寻找相关信息。3、若无危险函数信息，输出 NULL。

**判断文章内容中是否有漏洞原因分析（Is Cause Analysis）：**1、如果文章描述了靠近危险函数的代码，输出 TRUE。2、如果仅有攻击代码（如 PoC），没有漏洞成因点相关描述，输出 FALSE。

**1.4.3.2 第二部分提示词撰写**

在开始分析之前先对大模型的输出进行相关定义，需要分析的内容包含以下字段：

**1. Is Related：**是否与漏洞挖掘相关。
**2. POC/EXP Presence：**是否包含漏洞概念验证代码或漏洞利用代码。
**3. POC/EXP Explanation：**是否包含独立的漏洞代码解释。

这里添加了一个**Is Related**维度，对应题目中 **“若文章与漏洞挖掘无关或者不涉及具体的漏洞，则全部为NULL”**这一要求，如果**Is Related**为**FALSE**，则所有维度全部置NULL。增加维度是由于我们发现如果在其他输出维度中增加这一要求，不同规则的要求将会互相干扰竞争，造成非预期输出效果。然后与前述步骤相似地，**要求大模型，按照我们设计的步骤一步一步进行分析。**

![](https://mmbiz.qpic.cn/mmbiz_png/RicNZQMn3FU6oqoiaQrhDPSFO0eaZFhqNffzLILtaEoib5ImfheANk5FzibcamJyRngTpJK8d1UOQK15FLic1rnXWbA/640?wx_fmt=png&from=appmsg)

然后是提供给大模型的具体判断规则：

**分析文章内容是否与漏洞挖掘相关 (Is Related)：**判断文章是否与漏洞挖掘相关。如果文章未涉及漏洞或漏洞挖掘技术，后续关于 **POC/EXP** 的分析将失去意义。

* **相关：**如果文章讨论了某个具体漏洞（例如，提到 CVE ID），或者探讨了漏洞的发现、利用或缓解的技术，则返回TRUE。
* **不相关：**如果文章仅讨论网络安全的其他内容（如病毒传播）而未涉及具体漏洞或漏洞挖掘，则返回FALSE。

**检查是否包含 POC/EXP (POC/EXP Presence)：**

* 包含：如果文章包含功能性代码段、指令或命令，且这些内容能够演示如何利用漏洞、执行攻击或导致系统崩溃，则返回TRUE。
* 不包含：如果文章不包含这些内容，则返回FALSE。

**检查是否存在 POC/EXP 的解释 (POC/EXP Explanation)：**

* **包含：解释需满足以下条件：**

1.字段解释：明确描述 POC/EXP 中的多个字段或参数，例如 HTTP 头、输入参数、函数参数等。
2.与代码块分离：解释必须独立于代码块，不能把代码本身当作解释。
3.全面性：涉及 POC/EXP 的多个字段，不能只解释单个字段或依赖通用命令（如 curl 或 telnet）。
4.代码注释：若注释为逐字段解释，也可视为解释。

* **不包含：如果解释不满足上述条件，或完全没有解释。**

**1.4.4 步骤4：投票模型与结果复核**

**为什么使用投票模型：**大模型存在一个普遍问题**幻觉现象**。即指模型在生成内容时，可能会提供不准确、不真实甚至完全虚构的信息。反映在本题中，在**POC、EXP**等内容的判定时，大模型的判定结果会出现极大偶然性与随机性

投票模型的引入：可以有效提高准确性与一致性，一方面，可以针对大模型的误判，通过多次提问，取多数结果，来增加提示工程的稳定性。另一方面，部分隐藏性内容（如是否存在对**POC**的解释）在单次提问中不一定显示准确结果，需要多次提问来进行复核。

**我们的策略**主要包括以下几点：

1. 针对较为直观的漏洞信息如CVE编号等，首先进行两次提问，如果两次提问不一致，进行第三次提问，并最终选择第三次结果，以此降低不确定性。
2. 关于是否存在POC以及对POC的解释，由于这一部分大模型的判定显示了更大的随机性，我们进行了四次判定。根据实际尝试经验，大模型倾向于将牵强的POC与解释算作存在解释，只有较低概率下能够正常判断出解释牵强不算解释这样的情况，因此，我们这里选取了带优先级的投票模型：进行四次投票，大模型的判定结果只要出现一次有POC但无解释，优先输出此结果，如果出现没有`POC`但有解释的悖论情况，将有解释矫正为无解释（以防万一，实际测试时并未出现悖论情况）。
3. 针对文章是否与漏洞相关，考虑到判断与漏洞无关时全部输出维度都将为NULL，将会遗漏很多重要信息，我们要求四次投票中至少存在两票时才判断与漏洞无关。

除此之外，我们发现大模型在一些输出维度上可能超额完成任务，比如寻找危险函数时找到例如反序列化函数formatter.Deserialize、任意文件读写危险函数fopen等出题时并未被考虑到的函数。为了匹配题目情况，我们也对结果进行了进一步复核，如果厂商、编程语言与危险函数的输出结果不再预期列表之内，判定这一结果并不被赛题需要，并将输出结果修改为NULL。

**1.4.5 步骤5：赛题要求之外的额外信息提取**

考虑到在实际漏洞分析和漏洞利用过程中使用到的信息远不止步骤2中所述7个维度，在此部分我们对分析维度进行扩展，进一步利用大模型提取版本号、缓解建议、提取PoC或EXP等信息，从而有效提升我们提取的信息量。首先定义维度信息：

1.Software Version Number: 受影响的软件版本号。
2.Mitigation Recommendations: 漏洞的缓解措施。
3.Extracted POC/EXP: 文章中的漏洞概念验证代码（POC）或漏洞利用代码（EXP）。

![](https://mmbiz.qpic.cn/mmbiz_png/RicNZQMn3FU6oqoiaQrhDPSFO0eaZFhqNfb7YjiahZoKIDSfeIeHKw35BB5j88yal96eH4q4ofh5sI1XCKibibq2k9g/640?wx_fmt=png&from=appmsg)

**分析文章中受漏洞影响的软件版本号（Software Version Number）：**软件版本信息是确认漏洞是否影响特定系统的重要依据。如果文章中存在 **"Affected Version(s)"或"Tested Version(s)"**，那么：

* 仅有一个字段：直接使用该字段的内容。
* 两个字段同时存在：优先使用 "Affected Version(s)"。
* 如果两个字段都不存在，返回 NULL。

**提取/总结文章中的漏洞缓解措施（Mitigation Recommendations）：**提供缓解建议有助于快速采取防护措施。如果文章包含**"Suggested Mitigations"**字段...