---
title: Digging Inside Azure Functions: HyperV Is the Last Line of Defense
url: https://buaq.net/go-140181.html
source: unSafe.sh - 不安全
date: 2022-12-16
fetch_date: 2025-10-04T01:38:59.021908
---

# Digging Inside Azure Functions: HyperV Is the Last Line of Defense

* [unSafe.sh - 不安全](https://unsafe.sh)
* [我的收藏](/user/collects)
* [今日热榜](/?hot=true)
* [公众号文章](/?gzh=true)
* [导航](/nav/index)
* [Github CVE](/cve)
* [Github Tools](/tools)
* [编码/解码](/encode)
* [文件传输](/share/index)
* [Twitter Bot](https://twitter.com/buaqbot)
* [Telegram Bot](https://t.me/aqinfo)
* [Search](/search/search)

[Rss](/rss.xml)

[ ]
黑夜模式

![](https://8aqnet.cdn.bcebos.com/4b57c7a77b3d3485360944e8a241c32f.jpg)

Digging Inside Azure Functions: HyperV Is the Last Line of Defense

This post is also available i
*2022-12-15 22:0:21
Author: [unit42.paloaltonetworks.com(查看原文)](/jump-140181.htm)
阅读量:29
收藏*

---

![A pictorial representation of many storage containers stacked together](https://unit42.paloaltonetworks.com/wp-content/uploads/2022/12/Containers.png)

This post is also available in:
[日本語 (Japanese)](https://unit42.paloaltonetworks.jp/azure-functions-hyperv-defense/)

## Executive Summary

Unit 42 researchers investigated Azure’s serverless architecture and found that we were able to break out of the serverless function to the underlying host. We also discovered that our host was actually a HyperV virtual machine that hosted several other serverless functions.

Azure serverless functions (commonly referred to as Azure Functions) is a serverless compute service that enables users to run event-triggered code without having to provision or manage the infrastructure. Being a trigger-based service, it runs code in response to a variety of events. In the case of our research, this event was a web page request.

We found out that for each function, a new container is generated by the host. Each container will be terminated and deleted after several minutes, to differentiate serverless function from traditional containers as a service.

The host in question hosted only functions that our Azure user had access to anyway, so no real damage could be done. It is clear Microsoft went to great lengths to stop people from getting to the host, so it is possible there are other findings yet to be uncovered there. There could be important information on the virtual machine that shouldn’t be visible, which could be discovered by a sufficiently motivated attacker.

Microsoft often uses containers to strengthen security but – because containers inherently aren’t as secure as virtual machines – they usually do not treat them as a security boundary. In this case, they implemented additional layers of security, which proved to be effective.

[Prisma’s serverless solution](https://www.paloaltonetworks.com/prisma/cloud/serverless-security) has function discovery and vulnerability scanning for most cloud providers. These features effectively put another set of eyes on the organization’s serverless functions, alerting you in case known vulnerabilities are observed in those functions.

## Table of Contents

[Technical Overview](#post-126061-_5gaa8f4ok4im)

## Technical Overview

### What Are Serverless Functions

Serverless functions are a feature of serverless computing (commonly shortened to ”serverless”), where the cloud provider supplies all computing resources for its customers on demand and manages all architectures, including cloud infrastructure.

A great example of an ideal application for serverless is a chatbot. Slack, for instance, uses a serverless application called [marbot](https://marbot.io/) to send notifications to DevOps teams through Slack.

The name “serverless” is a bit misleading. Despite what its name implies, serverless computing still requires physical servers to execute the code. The major difference from traditional computing is that serverless abstracts away anything that isn’t directly related to the code itself, from the operating system the code runs on to the hardware of the machine actually running the code.

### The Internals of Serverless Functions

The first question you might be asking yourself is how one starts to research a serverless platform. Anyone who has ever used Azure Serverless Functions knows that there are not many places to poke around. You can upload some code or change a few settings, as shown in Figure 1, but that’s about it.

![Image 1 is a screenshot of Azure Serverless Functions displaying form fields for different runtimes. The two sections of the field are Instance Details and Operation system. ](https://unit42.paloaltonetworks.com/wp-content/uploads/2022/12/word-image-37.png)

Figure 1. All the different runtimes available through Azure Functions.

We decided to start our research with a Python function over Linux, triggered by an HTTP request. (As a side note: For some runtimes, Windows is also available.)

Our next step was to get a working interactive shell inside the function, to better understand what we are dealing with, and to get some information about the machine running our code. We decided to go with a reverse shell for ease of use. We also decided to use the data transfer tool socat (shown in Figure 2) rather than netcat, as it supports a wider range of the protocols we deemed necessary for the rest of our research.

![Image 3 is a screenshot of the Visual Studio Code program showing where the code to launch the reverse shell is stored in socat.](https://unit42.paloaltonetworks.com/wp-content/uploads/2022/12/word-image-38.png)

Figure 2. The socat binary in our project, in Visual Studio Code.

We simply dropped the socat binary in our project directory in Visual Studio Code and deployed the entire thing into the serverless function that we created earlier. The code to actually launch the reverse shell was very simple, as the entire logic lies in the socat application, as shown in Figure 3.

![Image 3 is a screenshot of the Visual Studio Code program showing where the code to launch the reverse shell is stored in socat.](https://unit42.paloaltonetworks.com/wp-content/uploads/2022/12/word-image-39.png)

Figure 3. Our simple function code connecting to the reverse shell listener.

Executing our reverse shell landed us inside the function directory under a user-named app. We immediately found out we were running inside a container by using the

|  |  |
| --- | --- |
|  | cat /proc/1/cgroupp\_last\_cap |

command. The machine hostname, which started with SandboxHost (shown in Figure 4), also hinted at that.

![Image 4 is a screenshot of many lines of code showing a shell inside the serverless function. ](https://unit42.paloaltonetworks.com/wp-content/uploads/2022/12/word-image-40.png)

Figure 4. A shell inside the serverless function.

There was nothing too interesting in the working directory we landed in. This directory included all the files we uploaded plus one additional lib folder, which contained the necessary libraries for Python to communicate with Azure.

### The Container

This research started without a specific goal in mind, other than to improve Prisma serverless protections. However, after learning more about the architecture, we were eager to break out of the container and see how deep the rabbit hole goes.

After familiarizing ourselves with the container and its files, as well as our user permissions and such, we decided to check the environment variables because they often include interesting pieces of information. This time was no different. Among other interesting things, we noted the environment variables gave away the image name (shown in Figure 5).

![Image 5 is a screenshot of 3 lines of code showing environment variables displaying an image name. ](https://unit42.paloaltonetworks.com/wp-content/uploads/2022/12/word-image-41.png)

Figure 5. Image name in the environment variables.

Searching this image name in Google led us to a Microsoft official [catalog that listed image names](https://mcr.microsoft.com/v2/_catalog), which led to an official repository that provided all of Microsoft images, including the one we were looking at.

Having the image and being able to research it locally made our life much easier. We were eager to pull the image to our local machine and start...