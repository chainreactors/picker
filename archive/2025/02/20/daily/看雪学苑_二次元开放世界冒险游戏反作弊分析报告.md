---
title: 二次元开放世界冒险游戏反作弊分析报告
url: https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458589844&idx=1&sn=5c110678c7c705f727e2647393fecbb9&chksm=b18c2a1e86fba308ee530712c1b4ce20283198e111ed5fc9aa1c8862cbcce7d69a52dfd0be97&scene=58&subscene=0#rd
source: 看雪学苑
date: 2025-02-20
fetch_date: 2025-10-06T20:35:08.738626
---

# 二次元开放世界冒险游戏反作弊分析报告

![cover_image](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8Fm5LDGBg63J3rC9p25bMUY2EuVCa0VWddD4TSlho40uZklPaSibuGOO0fL3uK931GPoLMiaUGUARYA/0?wx_fmt=jpeg)

# 二次元开放世界冒险游戏反作弊分析报告

xi@0ji233

看雪学苑

好久没碰某二次元开放世界冒险游戏了，听说新升级了反作弊，故来一探究竟，并尝试实现一些简单的功能。

## 基本保护分析

这种级别的游戏首先不考虑静态分析，直接跑起来。不出意外肯定不能直接内存读写，想附加调试器也是附加不上的，所以选择先从驱动入手，游戏加载时会加载驱动。

先尝试简单的拦截，方法很多：注册 LoadImage 回调拦截，改驱动名等等等。后者比较好实现，但是运行游戏一段时间会弹窗强制退出。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Fm5LDGBg63J3rC9p25bMUYIaugve7iaeVgy4Uoq796Eicx3Ml2KxTjFUuicIlZpswCbBkzvPBOZnpQw/640?wx_fmt=png&from=appmsg)

而如果说让保护加载，自己起一个句柄提权的驱动，则会被弹窗退出。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Fm5LDGBg63J3rC9p25bMUYicIAxX9pLtZoFGM2YBy4GFCLTibvJxp3fXGRxffDNGQlJbExYT2NEDjg/640?wx_fmt=png&from=appmsg)

尝试过在虚拟机里直接启动游戏，不出意外也是弹窗。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Fm5LDGBg63J3rC9p25bMUYa2vgZ3HJYH0BCulsNlmDsFqnGKZv8F9HvEytZ9vGlO8DaLaQ6VM7xQ/640?wx_fmt=png&from=appmsg)

使用启动时注入的方式，手动 Create 进程挂起，再远线程注入，可以将 DLL 注入，因为游戏刚运行的时候是没有驱动保护的，自然可以获得正常的游戏句柄。

## 注入功能测试

DLL 直接用 imgui 做 hook 就行，网上框架巨多，先浅浅尝试一下改锁帧的功能，由于这个游戏锁 60 帧，因此玩的很难受，尝试找一下这个值。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Fm5LDGBg63J3rC9p25bMUYQWiaibOHXHf1zz8McbiaXcaJ2wjicVuRZp9hdWsKmvupb8dMwFIaIaicDibg/640?wx_fmt=png&from=appmsg)

反复修改反复找可以找到四个值，地址较小的那个是真实值。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Fm5LDGBg63J3rC9p25bMUYw5fb4lHRrEHY6hg3Libq9mLcWdgSMXEYnsBE1V2MjsDvM2ONa1l6Kmg/640?wx_fmt=png&from=appmsg)

imgui里面直接用这个值绑定滑动条，实现帧率解锁。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Fm5LDGBg63J3rC9p25bMUYK78DicyYOsLtEnrW4ZC2Et1IQ7Ric9NI6kfkic7AOwYDzsTzn3eooKAZA/640?wx_fmt=png&from=appmsg)

##

## R3分析

面临的难点主要是反调试和反虚拟机。

###

### 反虚拟机

先说结论：R3程序使用了多种类型的反虚拟机技术，大部分通过hook api 的形式可以直接过掉。

◆虚拟机设备检测——Hook CreateFileA 和 CreateFileW 拦截常见的虚拟设备

◆虚拟机系统文件检测（sys和dll）——Hook CreateFileA 和 CreateFileW 虚拟机的 sys 和 dll 文件

◆进程检测——Hook ProcessNextW 跳过虚拟机中才会存在的进程

◆驱动目录检测——Hook NtQueryDirectory 拦截虚拟机中的驱动服务，改成其它任意名字即可

◆计时器检测——Hook GetTickCount 在监测点修改返回值降低时间间隔

◆MAC地址检测——Hook GetAdaptersInfo 将MAC地址的厂商号替换为非虚拟机厂商的厂商号

◆注册表检测——暂时是配合 sys 文件一起做检测的，可以不用拦截，实际上也可以 Hook OpenKey 之类的注册表函数

◆模块检测——Hook ModuleNextW 跳过虚拟机相关模块

#### 虚拟设备检测

Hook`CreateFileW`和`CreateFileA`这两个 API，可以看出在尝试打开如下的设备和文件。

```
\\.\vmmemctl
C:\Windows\system32\DRIVERS\vm3dmp.sys
C:\Windows\system32\drivers\vm3dmp_loader.sys
...
```

不用想，游戏打开这些文件肯定是在检测虚拟机，这里将文件添加到一个 set 中，每次打开遍历一遍，遇到它检测的文件就直接返回无效句柄。

```
HANDLE gh_CreateFileW(...) {
    for (auto it : DeviceFileBlacklist) {
        if (CaseInsensitiveContains(lpFileName, it)) {
            DBG_PRINT("black device \"%ws\" not allowed to open\n", lpFileName);
            return INVALID_HANDLE_VALUE;
        }
    }
    HANDLE hFile = CreateFileW(...);
    bool flag = true;
    for(auto it:FileBlacklist){
        if (CaseInsensitiveContains(lpFileName,it)) {
            flag = false;
            break;
        }
    }
    DBG_PRINT("CreateFileW called with %ws return value %p\n", lpFileName, hFile);
    return hFile;
}
```

只需要对`yxxxshen.exe`和`mxxxbase.dll`两个模块做 IAT hook 即可。下面是拦截成功的一些日志，实际上还有更多的设备，这里不一一展示：

```
[Debug Info]black device "\\.\vmmemctl" not allowed to open
[Debug Info]black device "C:\Windows\system32\DRIVERS\vm3dmp.sys" not allowed to open
[Debug Info]black device "C:\Windows\system32\drivers\vm3dmp_loader.sys" not allowed to open
...
```

####

#### 进程检测

运行过程中会有一段调用了进程遍历的关键函数`Process32NextW`，应该是检测虚拟机的相关进程，这里直接匹配当前虚拟机存在的一些虚拟机特有的进程不让它返回即可。

```
BOOL gh_ProcessNextW(HANDLE hSnapshot, LPPROCESSENTRY32W lppe) {
    BOOL ret = Process32NextW(hSnapshot, lppe);
    WCHAR *szExeFile = lppe->szExeFile;
    while (CaseInsensitiveContains(szExeFile, L"vm")||CaseInsensitiveContains(szExeFile,L"VGAuthService") && ret) {
        DBG_PRINT("Found Vm in Process name %ws,try to execute again\n", szExeFile);
        ret = Process32NextW(hSnapshot, lppe);
        szExeFile = lppe->szExeFile;
        DBG_PRINT("new Process Name %ws pid=%d ret=%d\n", lppe->szExeFile, lppe->th32ProcessID, ret);
    }
    DBG_PRINT("ProcessNextW called with %ws pid=%d ret=%d\n", lppe->szExeFile,lppe->th32ProcessID ,ret);
    return ret;
}
```

如果找到 vm 相关进程则持续调用，直到进程名不包含 vm 或者为`VGAuthService`即可。下面是一些拦截成功的日志：

```
[Debug Info]Found Vm in Process name vm3dservice.exe,try to execute again
[Debug Info]new Process Name vmtoolsd.exe pid=3916 ret=1
[Debug Info]Found Vm in Process name vmtoolsd.exe,try to execute again
[Debug Info]new Process Name svchost.exe pid=3928 ret=1
[Debug Info]ProcessNextW called with svchost.exe pid=3928 ret=1
```

####

#### 驱动目录检测

游戏调用了`NtOpenDirectoryObject`和`NtQueryDirectoryObject`两个 API，经过测试发现它打开了`\Device`路径，也就是开始遍历了驱动对象。

这两个 api 可以先hook打印，但是单纯绕过检测 hook 后者即可。

```
NTSTATUS gh_NtQueryDirectoryObject(...) {
    auto ret = NtQueryDirectoryObject(...);
    auto info = (POBJECT_DIRECTORY_INFORMATION)Buffer;
    for(auto it:DeviceBlackList){
        if(CaseInsensitiveEqual(info->Name.Buffer,it)){
            DBG_PRINT("NtQueryDirectoryObject name=\"%wZ\" return %d Deny to open!\n",
            info->Name, info->TypeName, ret);
            info->Name = DeniedDevice;
            return 0;
        }
    }
    DBG_PRINT("NtQueryDirectoryObject name=\"%wZ\",Type=\"%wZ\" return %d\n",
    info->Name, info->TypeName, ret);
    return ret;
}
```

这里也给出一些拦截成功的日志：

```
[Debug Info]NtQueryDirectoryObject name="gpuenergydrv",Type="Device" return 0
[Debug Info]NtQueryDirectoryObject name="VMCIHostDev" return 697297488 Deny to open!
[Debug Info]NtQueryDirectoryObject name="00000068",Type="Device" return 0
```

####

#### 计时器检测

注意到 mxxxbase.dll 的一个函数

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Fm5LDGBg63J3rC9p25bMUYdt2Qsb99Chp0fJCic4wlg36MIQ5rHgwIDvdUYcgBczKFlYibSXHR04iaw/640?wx_fmt=png&from=appmsg)

GetTickCount64 获取系统启动以来经过的毫秒数。

它做了 10 次测试，每次测试 10000 条 cpuid 指令运行所需的时间，在虚拟机里，它很大，物理机中几乎每次都为 0。

那么便可以：

强制将两次运行的 cpuid 的时间设为一致。

```
ULONGLONG st=40000;

ULONGLONG gh_GetTickCount64() {
    auto ret = GetTickCount64();
    if (st == 0) {
        DBG_PRINT("GetTickCount64 called %lld\n", ret);
        st = ret;
    }
    else {
        DBG_PRINT("GetTickCount64 called change %lld to %lld\n", ret, st);
        ret = st;
        st = 0;
    }
    return ret;
}
```

下面是日志：

```
[Debug Info]GetTickCount64 called 4117687
[Debug Info]GetTickCount64 called change 4117718 to 4117687
[Debug Info]GetTickCount64 called 4117734
[Debug Info]GetTickCount64 called change 4117812 to 4117734
```

可以对比得到，hook 前和 hook 后的差距大概是有几十毫秒的，这里会被检测到，通常物理机的间隔都是 0。

#### MAC地址检测

该函数调用了，但是没进行检测，提前写好以免后面加这个检测，检测的方式通常是检查 MAC 地址前三字节的信息看厂商是否为 Vmware 之类的。

```
ULONG gh_GetAdaptersInfo(...) {
    auto ret = GetAdaptersInfo(AdapterInfo, SizePointer);
    DBG_PRINT("GetAdaptersInfo called with %p %p return %d\n",...);
    //换成intel的MAC地址60:45:2E
    AdapterInfo->Address[0] = 0x60;
    AdapterInfo->Address[1] = 0x45;
    AdapterInfo->Address[2] = 0x2E;
    return ret;
}
```

####

#### 注册表检测

hook 注册表相关的 api，拦截对应 open 的 key 的名字，实际上也是有调用没检测。

这里输出了一些相关log：

```
[Debug Info]RegOpenKeyExA called with FFFFFFFF80000002 "SYSTEM\CurrentControlSet\services\vm3dmp_loader" 0 131353 000000702B0FF5B0 return 0
[Debug Info]CreateFileW called with C:\Program Files (x86)\mihoyo\games\Genshin Impact Game\yuanshen_Data\Persistent\base_res_version_hash return value 0000000000000CDC
[Debug Info]black device "C:\Windows\system32\drivers\vm3dmp_loader.sys" not allowed to open
```

但是预计可能是两个一起检测的，即：注册表判断服务是否存在，再判断驱动文件是否存在，有一样不成立就不认为检测到了虚拟机。

#### 最终效果

过完这些虚拟机检测之后，也是成功可以在虚拟机中启动 yxxxshen.exe 了。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Fm5LDGBg63J3rC9p25bMUYouVGs6vKDqgAEOTyyy6usbHcAsRr3QiaDfJab5JurCgstHhIx4wTpzQ/640?wx_fmt=png&from=appmsg)

###

### 反调试

R3的反调试相对比较简单，除了众所周知的`IsDebuggerPresent`之外，早期的版本似乎`hook`了`DbgBreakPoint`和`DbgUiRemoteBreakin`两个 API 来防止调试器附加，现在仍有`hook`，不过只`hook`了`DbgBreak`，并且同样也有`ThreadHideFromDebugger`检测。

◆`IsDebuggerPresent`：hook 返回 0 即可。

◆`ThreadHideFromDebugger`：需要根据参数和调用的时机合理地选择返回，稍有不慎就会crash，具体看下文分析。

◆`API hook`：目前无须绕过。

#### ThreadHideFromDebugger

`NtSetInformationThread`这个 API 本意是设置线程优先级的，其中有一个...