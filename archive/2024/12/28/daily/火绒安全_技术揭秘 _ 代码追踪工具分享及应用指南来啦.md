---
title: 技术揭秘 | 代码追踪工具分享及应用指南来啦
url: https://mp.weixin.qq.com/s?__biz=MzI3NjYzMDM1Mg==&mid=2247521279&idx=1&sn=32b588221868c09f84f0d521c70bae7e&chksm=eb704dc0dc07c4d664935b3035488a248ad6ed4248c342bae4ac7616ca44e9f7d3e11dbcba3a&scene=58&subscene=0#rd
source: 火绒安全
date: 2024-12-28
fetch_date: 2025-10-06T19:40:00.654921
---

# 技术揭秘 | 代码追踪工具分享及应用指南来啦

![cover_image](https://mmbiz.qpic.cn/sz_mmbiz_jpg/0icdicRft8tz7GIMbgTO1vZDjzgDhAneT7y8tXaqiciaCOZ2xfCapQBjedaRW6asoDeofO0sDWWqcvTrIE3mrEUXrw/0?wx_fmt=jpeg)

# 技术揭秘 | 代码追踪工具分享及应用指南来啦

火绒安全

火绒安全

自从绒绒与大家分享病毒分析报告以来，评论区的相关讨论不仅让绒绒成就感满满，也下定决心（暗暗攥拳）要和大家分享更多有意义的文章。总览评论后，绒绒发现大家不仅对病毒本身充满探究精神，也对工程师是通过什么方式对病毒进行分析以及在分析过程中使用什么工具感到好奇。那么今天就不讲病毒！让我们讲一讲如何“研究”病毒——特别是追踪技术在病毒分析中的应用。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/0icdicRft8tz7GIMbgTO1vZDjzgDhAneT7MeBCebwamMlgKLGarGqxMSlMgO7n5nEB0s3ib6aYlLibvmjqDYURoNrw/640?wx_fmt=png&from=appmsg)

随着网络环境的不断变化，恶意软件与病毒变种开始层出不穷，给安全研究和病毒分析工作带来了不小的挑战。比如在病毒逆向分析过程中，有高效代码保护能力的强壳加密技术，这种技术通常通过加密、压缩和虚拟化等手段隐藏或混淆程序代码，导致分析人员难以获得有效的解密方法，进而使得对病毒样本的调试、分析和修改工作变得复杂。常见的强壳如Themida、VMProtect，以及越来越广泛的自定义混淆壳(代码虚拟化)，通常采用多种复杂的保护策略，包括但不限于代码加密、API钩子、反调试、反虚拟机技术等，这些都一定程度上增加了病毒逆向分析的难度。

病毒在升级，但我们的技术手段也在不断升级。比如在病毒逆向分析的过程中，分析者可通过**追踪**解析被保护程序或加壳程序。通过追踪程序的执行过程，分析者可以观察到程序运行时的行为，逐步揭示其加壳或加密的方式。追踪可通过多种方法进行，例如调试器、动态分析工具、代码注入等，这些方法有助于分析者跟踪程序的调用栈、数据流以及了解加壳后的解密过程，进而破除壳保护，恢复程序的原始功能和代码。

以下分享几种我们常用的代码追踪工具。

**一、**

**Pin**

![](https://mmbiz.qpic.cn/sz_mmbiz_gif/0icdicRft8tz7GIMbgTO1vZDjzgDhAneT7f51Vaib9icDQtjibdvDMoPjeGZFO41iaZOd5ZLI5uGXiacib5qgGROXRGM9w/640?wx_fmt=gif&from=appmsg)

Pin 是 Intel 推出的一款适用于 IA-32 和 x86-64 架构的动态二进制插桩框架，支持包括指令级、基本块级、镜像级和函数级插桩在内的多种插桩方式。同时 Pin 拥有丰富的 API，这使得 Pin 能够抽象底层指令集的特性，并允许将上下文信息（如寄存器内容）作为参数传递给注入的代码。Pin 会自动保存和恢复被注入代码覆盖的寄存器内容，从而确保应用程序能够继续正常运行。此外，Pin 还可提供有限的符号及具有调试信息访问功能。作为一种前端工具，Pin 能够有效支持代码逆向分析，尤其在数据提取方面表现出色。

同时，Pin 也可视为一种即时翻译器（JIT），与其他翻译器不同的是，其输入的内容并非是字节码，而是常规的可执行文件，当文件在执行第一条指令时，Pin 会进行拦截控制，并为该指令及其后续代码序列生成新的“翻译”代码。之后，控制权被转交到新生成的中间代码序列，该序列与原始代码几乎一致。每当程序执行到分支退出时，Pin 会重新获得控制权，并为分支目标生成新的代码，继续执行后续操作。通过将所有生成的代码保留在内存中，Pin 提高了执行效率，使得代码可以被重复使用，并允许程序从一个序列直接跳转到另一个序列。

**在 JIT 模式下，实际运行的是新生成的中间代码。原始代码仅作为参考，在生成代码时，Pin 给用户提供了注入自己代码（插桩）的机会。**

![](https://mmbiz.qpic.cn/sz_mmbiz_png/0icdicRft8tz7GIMbgTO1vZDjzgDhAneT7Lz9LXlOBPibx0RA8Xk6mkBbV7uAGarP64tRTmaaHKNcibVibicfRia06mkA/640?wx_fmt=png&from=appmsg)

Pin 原理

**回调函数**

![](https://mmbiz.qpic.cn/sz_mmbiz_gif/0icdicRft8tz7GIMbgTO1vZDjzgDhAneT7f51Vaib9icDQtjibdvDMoPjeGZFO41iaZOd5ZLI5uGXiacib5qgGROXRGM9w/640?wx_fmt=gif&from=appmsg)

Pin 提供了一系列回调函数，用于实现程序的动态插桩。通过这些回调函数，可以对指令级、基本块级和函数级的程序进行插桩分析，并允许通过编写自定义的 Pintool 对程序进行不同程度的干预。这些功能使得 Pin 能够执行多种分析任务，例如代码性能分析、内存访问分析、代码覆盖率评估，以及检测潜在的漏洞或恶意代码。

* INS\_AddInstrumentFunction (INSCALLBACK fun, VOID \*val) 注册以指令粒度插桩的函数
* TRACE\_AddInstrumentFunction (TRACECALLBACK fun, VOID \*val) 注册以 trace 粒度插桩的函数 （基本块插桩）
* RTN\_AddInstrumentFunction (RTNCALLBACK fun, VOID \*val) 注册以 routine 粒度插桩的函数，函数级别的插桩需要符号信息
* IMG\_AddInstrumentFunction (IMGCALLBACK fun, VOID \*val) 注册以 image 粒度插桩的函数
* PIN\_AddFiniFunction (FINICALLBACK fun, VOID \*val) 注册在应用程序退出前执行的回调函数
* PIN\_AddDetachFunction (DETACHCALLBACK fun, VOID \*val) 注册在 Pin 通过PIN\_Detach()函数放弃对应用程序的控制权限之前执行的函数，一个进程只调用一次，可以被任何线程调用

**BLL（基本块）**

![](https://mmbiz.qpic.cn/sz_mmbiz_gif/0icdicRft8tz7GIMbgTO1vZDjzgDhAneT7f51Vaib9icDQtjibdvDMoPjeGZFO41iaZOd5ZLI5uGXiacib5qgGROXRGM9w/640?wx_fmt=gif&from=appmsg)

BBL（Basic Block）即基本块，是程序执行中最小的执行单元之一。它通常由一系列连续的指令组成，这些指令之间不存在跳转，因此在基本块内程序控制流程是顺序执行的。在动态分析中，基本块被视为程序的一个“原子”执行单元。

**Pin\_BBL**

Pin 保证每个 trace （追踪）只有一个顶部入口点，但可以有多个出口点。如果一个分支指令指向 trace 的中间位置，Pin 会生成一个新的 trace，并以该分支为起点。Pin 将 trace 切分成基本块，每个基本块称为“BBL”，每个 BBL 是一个具有单一入口和单一出口的指令序列。如果有分支指向 BBL 的中间位置，则会定义一个新的 BBL。通常，分析调用会以 BBL 为单位插入，这样可以减少分析调用对性能的影响。

Trace Instrumentation 通过 TRACE\_AddInstrumentFunction API 进行注册 Trace 回调。

**BBL\_InsertCall**

* **函数：**VOID BBL\_InsertCall(BBL bbl, IPOINT ipoint, AFUNPTR fun, ...)
* **功能：**在基本块插入回调函数
* **说明：**允许在指定的基本块中插入回调函数，并在程序执行时触发该回调函数。IOPOINT 可指定回调函数插入位置的枚举类型，可以选择如 IOPOINT\_BEFORE 、 IOPOINT\_AFTER、IPointAny 等位置进行插桩

+ IPointBefore：在基本块开始执行之前调用回调函数
+ IPointAfter：在基本块执行结束之后调用回调函数
+ IPointAny：在基本块的任何位置都可以调用回调函数

**Pintools**

![](https://mmbiz.qpic.cn/sz_mmbiz_gif/0icdicRft8tz7GIMbgTO1vZDjzgDhAneT7f51Vaib9icDQtjibdvDMoPjeGZFO41iaZOd5ZLI5uGXiacib5qgGROXRGM9w/640?wx_fmt=gif&from=appmsg)

基于 Pin 开发的 Pintools 是一种动态二进制插桩工具，也相当于动态程序分析工具，可用于对Linux、Windows 上的用户空间应用程序进行程序分析。因其能够实现无需重新编译源代码，即可在程序运行时进行插桩，所以 Pintools 也支持对动态生成代码进行插桩。Pintools 包括Intel® VTune™ Amplifier、Intel® Inspector、Intel® Advisor以及Intel®软件开发模拟器（Intel® SDE）。

通过编写简单的示例代码，可以对代码覆盖率进行简单分析，但这种方法在处理大量执行流的明文字符串时，会涉及到频繁的 IO 操作，特别是在分析那些被 VMProtect、Themida 等强壳保护的程序时，如果虚拟化的指令数量达到千万条时，追踪效率会大幅降低。为了优化这一过程，我们可以利用 ProtoBuf 库对数据进行序列化，并通过对 BBL 进行白名单标记，取消对重复执行代码块的插桩，从而提高追踪效率。

```
static void OnTrace(TRACE trace, void* v) {auto& context = *reinterpret_cast<ToolContext*>(v);if (!context.m_tracing_enabled ||         !context.m_images->isInterestingAddress(TRACE_Address(trace))) {return;    }
// 获取线程ID和线程本地数据auto tid = PIN_ThreadId();    ThreadData* data = context.GetThreadLocalData(tid);
// 处理第一个基本块auto bbl = TRACE_BblHead(trace);auto firstBlockAddr = BBL_Address(bbl);    data->m_blocks[firstBlockAddr] = static_cast<uint16_t>(BBL_Size(bbl));
// 遍历trace中的后续基本块for (bbl = BBL_Next(bbl); BBL_Valid(bbl); bbl = BBL_Next(bbl)) {        ADDRINT blockAddr = BBL_Address(bbl);
if (data->m_blocks.find(blockAddr) != data->m_blocks.end()) {continue;        }
        BBL_InsertCall(            bbl,             IPOINT_ANYWHERE, reinterpret_cast<AFUNPTR>(OnBasicBlockHit),            IARG_FAST_ANALYSIS_CALL,            IARG_THREAD_ID,            IARG_ADDRINT, blockAddr,            IARG_UINT32, BBL_Size(bbl),            IARG_PTR, v,            IARG_END        );    }}
```

以样本 c997772c5f498acdc2bc3e94dccc4b76f1bb6c2f 为例，下面是对其进行插桩分析、生成追踪日志以及序列化后的数据情况。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/0icdicRft8tz7GIMbgTO1vZDjzgDhAneT7hiaKD0NSEEThp3ibtKUEQBSBcNwficluEraaQYd9ehklAGib5xM3nEu7ng/640?wx_fmt=png&from=appmsg)

追踪数据

![](https://mmbiz.qpic.cn/sz_mmbiz_png/0icdicRft8tz7GIMbgTO1vZDjzgDhAneT7Cpx90xtiauCjqVolZ00fqbicfkJpevy8KWKIyZZicSWJu1dYHl86b9PTA/640?wx_fmt=png&from=appmsg)

序列化数据

利用 IDA 可以进一步增强代码覆盖率分析的准确性。通过统计每条指令的执行次数，可以计算出每个函数的执行覆盖率。即使在缺乏符号信息的情况下，借助 IDA 的函数识别功能，也能协助逆向分析人员精确分析出每个函数的代码覆盖率。**注：绿色表示代码块已被执行。**

![](https://mmbiz.qpic.cn/sz_mmbiz_png/0icdicRft8tz7GIMbgTO1vZDjzgDhAneT7wrnNIU1JibcbhxSaMCVB1dRWszaiaRI8VWYqyXnmqujvQXmWOgL455Pg/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/0icdicRft8tz7GIMbgTO1vZDjzgDhAneT7nfib5wcTSJH3kg0Nh2PTceiaBIAw72c3n5FHydH3cNwXDNtiarkYEQPPw/640?wx_fmt=png&from=appmsg)

代码覆盖图

通过代码覆盖率分析，可以看到病毒样本在添加启动项时的程序执行流程。结合 IDA 反编译器生成的伪代码，能够清晰标记出伪代码的覆盖率情况。通过分析伪代码的覆盖率，逆向分析人员可以轻松追踪病毒在执行过程中对注册表的操作过程。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/0icdicRft8tz7GIMbgTO1vZDjzgDhAneT77RmBnmibr2DibP67woia6pL8cfLibvTj2hIJW3yQeFYiaI1TicXvJ9hzQicBA/640?wx_fmt=png&from=appmsg)

指令代码覆盖率

**代码覆盖率**

![](https://mmbiz.qpic.cn/sz_mmbiz_gif/0icdicRft8tz7GIMbgTO1vZDjzgDhAneT7f51Vaib9icDQtjibdvDMoPjeGZFO41iaZOd5ZLI5uGXiacib5qgGROXRGM9w/640?wx_fmt=gif&from=appmsg)

代码覆盖率通过 Pin 对指令进行插桩，从而实现对执行地址的追踪。通过获取 RIP 寄存器的值，Pin 可以记录指令的执行情况，从而分析出哪些指令被执行过，哪些指令没有被执行过。此外，Pin 可通过对事件的监控来检测映像和模块的加载情况，并对相关模块进行追踪。通过对指令的插桩，Pin 可实时 Dump内存，查看内存状态，并对内存修改进行断点分析。同时，它也能对指令执行过程进行详细分析。

代码覆盖率分析通过追踪已执行的指令来判断哪些指令被执行过，哪些未被执行，并将这些信息记录到日志中。这些日志对于逆向分析人员来说非常有用，尤其是在判断 JCC 指令执行情况时，可以更准确的进行静态分析。

**回溯分析**

通过使用 IDA 插件分析日志中的 RIP 值，可以回溯 JCC 指令的相关执行流程，并实现内存断点执行的效果。

以下以指令粒度插桩进行打印 RIP 的例子：

```
#include <stdio.h>#include "pin.H"
FILE* trace;
// This function is called before every instruction is executed// and prints the IPVOID printip(VOID* ip) { fprintf(trace, "%p\n", ip); }
// Pin calls this function every time a new instruction is encounteredVOID Instruction(INS ins, VOID* v){// Insert a call to printip before every instruction, and pass it the IP    INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)printip, IARG_INST_PTR, IARG_END);}
// This function is called when the application exitsVOID Fini(INT32 code, VOID* v){fprintf(trace, "#eof\n");    fclose(trace);}
/* ===================================================================== *//* Print Help Message                                                    *//* ===================================================================== */
INT32 Usage(){    PIN_ERROR("This Pintool prints the IPs of every instruction executed\n" + KNOB_BASE::StringKnobSummary() + "\n");return -1...