---
title: CVE-2023-41111: Samsung Baseband RLC Data Re-Assembly Buffer Overflow
url: https://labs.taszk.io/blog/post/93_rlc_bof/
source: Taszk Labs on taszk.io labs
date: 2024-07-30
fetch_date: 2025-10-06T17:47:18.029387
---

# CVE-2023-41111: Samsung Baseband RLC Data Re-Assembly Buffer Overflow

[![logo](https://labs.taszk.io/images/taszk_logo.png)
![logo](https://labs.taszk.io/images/taszk_logo_white.png)](https://labs.taszk.io)

* [Home](https://labs.taszk.io/)
* [Articles](https://labs.taszk.io/articles)
* [Advisories](https://labs.taszk.io/blog)
* [Get in touch](https://taszk.io/contact)

## [CVE-2023-41111: Samsung Baseband RLC Data Re-Assembly Buffer Overflow](https://labs.taszk.io/blog/post/93_rlc_bof/)

2024-07-29
 by Daniel Komaromy
 [Samsung](/blog/tags/samsung) [baseband](/blog/tags/baseband)

We have identified a new buffer overflow vulnerability in Samsung’s baseband implementation (mainly used in Exynos chipsets). The vulnerability can be exploited to achieve arbitrary code execution in the baseband runtime.

The vulnerability we are disclosing in this advisory affected a wide range of Samsung devices, including phones on the newest Exynos chipsets. The November 2023 issue of the Samsung Semiconductor Security Bulletin contains this vulnerability as CVE-2023-41111.

# Vulnerability Details

## Background: Data Block Format and Re-assembly in RLC

In GPRS, an LLC layer PDU can be up to 1560 bytes long, but the maximum size for an RLC data block is 22/32/38/52 for the GPRS coding schemes CS-1/2/3/4, respectively.

The segmentation and re-assembly procedures for RLC data blocks is described in 3GPP 44.060. 9.1.11. and 9.1.12.

## Block Format

After a fix sized (1 byte long) MAC header, each RLC data block starts with 2 bytes: the first includes the Traffic Block Flow identifier (TFI) and a Final Block Identifier bit (FBI), whereas the second (“BSN\_E”) includes the 7 bit BSN (block sequence number) and the Extension bit (E).

A 0 value for the `E` bit means the rest of the PDU is all actual RLC data. Otherwise (`E==1`), these 2 header bytes are followed by an optional number of `LI_M_E` octets, which consist of the 6 bit Length Indicator, the More bit and the Extension bit fields.

After the optional `LI_M_E` octets, the rest of the RLC data block is the actual RLC data.

The `FBI`, `E`, and `LI_M_E` fields all play a role in the re-assembly process.

The `LI` indicates the length of a fragment, the `M` (more bit) says whether there is yet another LLC PDU whose fragment will be present in the current block, and the `E` (extension) bit is the inverse of whether this `LI_M_E` field is the last one or not (0 means it is not the last one, 1 means it is the last one).

What we can see is that there is no such thing as an “LLC PDU identifier”: within a given RLC Traffic Block Flow (“session”), we can collect and re-assemble only one LLC PDU’s fragments at one time, in other words, any fragment that comes next is considered part of the ongoing LLC PDU.

## Re-Segmentation algorithm

According to the specification, only the last fragment of an LLC PDU may have a Length Indicator value (i.e. an `LI_M_E` field corresponding to it). This makes sense: as long as a fragment is not the last fragment of an LLC PDU, it must fill the (remainder) of the current RLC data block, consequently it doesn’t need a byte wasted on an `LI_M_E` octet, the preceding “E” and/or “M” values are already able to signal its presence.

However, there is an exception to this, as 44.060. 10.4.14 explains:

```
A singular case occurs when the end of the Upper Layer PDU would fit within the RLC data block but the addition of the Length Indicator octet (to indicate the Upper Layer PDU boundary) causes the Upper Layer PDU to extend into the next RLC data block. In this case, this additional LI field shall take the value 0 whatever is the length of the last but one Upper Layer PDU segment.
```

That optimization sounds like infinitesimal gains, but it’s a quirk of the algorithm that is crucial to this vulnerability chain.

The summarized algorithm of handling an RLC data block is as follows:

* if “E” is 0, the entire block contains a fragment of an LLC PDU being re-assembled and this is not the last fragment of it yet: save and continue to wait fragments (if not already collecting fragments of an incomplete LLC PDU, it is saved as the first fragment of a new one)
* if “E” is 1, then process each `LI_M_E` field, recursively reading a next one until `E == 1`
  + if `LI` in the `LI_M_E` field is non-0, we have the last fragment of the current LLC PDU, concatenate it with any already collected ones and send the PDU to the upper layer, then based on the combination of the values in `LI_M_E`, continue onto a next fragment within the RLC data block:
    - `M==0 && E==0` is not valid, should be ignored
    - `M==0 && E==1` means no more LLC PDUs and no more Extensions to parse afer this one, finished with this RLC data block
    - `M==1 && E==1` means the rest of the data if a new LLC PDU’s start, but no more Extensions to parse, the new LLC PDU will finish in a later RLC data block, so just save this first fragment of the new LLC PDU and then finished with this RLC data block
    - `M==1 && E==0` means move on to the next `LI_M_E` which is the first of the next LLC PDU and process it based on the same logic
  + if `LI` is 0, store this fragment (calculating its size based on the number of data bytes left in the RLC data block after the optional number of `LI_M_E`s and any data bytes that have been matched by preceding `LI_M_E` fields), on the assumption that the first data byte within the next arriving RLC data block will complete the current LLC PDU, so process any `LI_M_E` header byte(s) of that next RLC data block by accounting for the first non-`LI_M_E` byte being the last byte of the current LLC PDU

The firts key observation is that this logic, when followed correctly, guarantees that any fragment’s data size is at least `block_size-3` (3 being the size of the mandatory headers), with only the final fragment being an exception from this. In other words, given that the smallest block size with Coding Scheme 1 is 23, we get the following equation for the maximum possible valid fragment count in RLC: `max_llc_size / (min_block_size - 3) + 1 = 1560 / 20 + 1 = 79`

The second key observation is that an implementation must take care that:

* maximum 1 fragment tagged with an `LI_M_E` field with `LI==0` is allowed per LLC PDU
* only 1 `LI_M_E` header with `LI==0` is present in any given RLC data block (since it must be followed by all data bytes, ergo there is no room for additional fragments)
* as a consequence of the above, an `LI_M_E` field with `LI==0` shall have `M==0` and `E==1` values (to be precise, the specification states that for `LI==0` case `M==0` shall be sent, but the receiver shall simply ignore its value)

In Samsung’s case, however, these requirements were not enforced!

## Vulnerability #1: Wrong RLC Data Block Size Calculation

Instead, the implementation parsed the header fields in two rounds:

* first, to parse the `LI_M_E` headers and, since it can be necessary, calculate and store the value of the “remaining data bytes”
* next, to actually handle concatenation(s)

The problem was a mismatch in how the two rounds handled `LI_M_E` headers with the value `LI==0`.

In the first round, the logic that looped over the header bytes did not enforce the “only once” rule on the special case, instead allowing it to occur any number of times. This can be seen below from the decompiled pseudocode snippet of the `RLC_handle_DATA_IND` function:

…

```
      rlc_data_block_ptr = blk_p;
      block_offset_new = 3;
      rlcmac_size = uVar8;
      if (-1 < (int)mcs_or_cs_encoded) {
        rlcmac_size = (int)RLCMAC_SIZE_BY_CS[mcs_or_cs_encoded];
        rlcmac_size_ = rlcmac_size;
      }
      RLC_CONTEXT[sim_].rlc_lens[(int)bsn_00] = rlcmac_size;
      if (e_param == 0) {
        remaining_data_size = rlcmac_size - 3;
        max_data_size = rlcmac_size + -4;
        block_offset_from_start = 4;
        data_ptr_ = blk_p->data;
        LI = *data_ptr_ >> 2;
        rlcmac_size_ = remaining_data_size;
        if (((*data_ptr_ & 1) == 0) || ((int)(uint)LI <= max_data_size...