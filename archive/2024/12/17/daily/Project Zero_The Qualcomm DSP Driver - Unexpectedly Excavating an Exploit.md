---
title: The Qualcomm DSP Driver - Unexpectedly Excavating an Exploit
url: https://googleprojectzero.blogspot.com/2024/12/qualcomm-dsp-driver-unexpectedly-excavating-exploit.html
source: Project Zero
date: 2024-12-17
fetch_date: 2025-10-06T19:39:49.156299
---

# The Qualcomm DSP Driver - Unexpectedly Excavating an Exploit

# [Project Zero](https://googleprojectzero.blogspot.com/)

News and updates from the Project Zero team at Google

## Sunday, December 15, 2024

### The Qualcomm DSP Driver - Unexpectedly Excavating an Exploit

Posted by Seth Jenkins, Google Project Zero

This blog post provides a technical analysis of exploit artifacts provided to us by Google's Threat Analysis Group (TAG) from Amnesty International. Amnesty’s report on these exploits is available [here](https://securitylab.amnesty.org/latest/2024/12/a-digital-prison-surveillance-and-the-suppression-of-civil-society-in-serbia/). Thanks to both Amnesty International and Google's Threat Analysis Group for providing the artifacts and collaborating on the subsequent technical analysis!

## Introduction

Earlier this year, Google's TAG received some kernel panic logs generated by an In-the-Wild (ITW) exploit. Those logs kicked off a bug hunt that led to the discovery of 6 vulnerabilities in one Qualcomm driver over the course of 2.5 months, including one issue that TAG reported as ITW. This blog post covers the details of the original artifacts, each of the bugs discovered, and the hypothesized ITW exploit strategy gleaned from the logs.

## Artifacts

Usually when successfully reverse-engineering an ITW exploit, Project Zero/TAG have had access to the exploit sample itself, making determining what vulnerability was exploited primarily a matter of time and effort. However, in this particular case, we received several kernel panic logs but unfortunately not the exploit sample. This meant we could not directly reproduce crashes or reverse engineer what bug was being exploited.

Accurately determining what vulnerability an exploit uses working only off of crash logs and without the exploit itself can range in difficulty from highly plausible to impossible. I decided to give it a try and see what I could learn. Out of the 6 panics we received, 4 panics in particular contained potentially useful information:

##### Log 1:

[   47.223480] adsprpc: fastrpc\_init\_process: untrusted app trying to attach to privileged DSP PD

[   47.254494] adsprpc: mapping not found to unmap fd 0xffffffff, va 0xffffffffffffffff, len 0xffffffff

[   47.254512] adsprpc: falcon: fastrpc\_internal\_mmap: ERROR: adding user allocated pages is not supported

[   47.261488] adsprpc: mapping not found to unmap fd 0xa, va 0x0, len 0x0

...

[   50.865579] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000000

[   50.865586] Mem abort info:

[   50.865590]   ESR = 0x96000006

[   50.865593]   Exception class = DABT (current EL), IL = 32 bits

[   50.865597]   SET = 0, FnV = 0

[   50.865600]   EA = 0, S1PTW = 0

[   50.865603] Data abort info:

[   50.865606]   ISV = 0, ISS = 0x00000006

[   50.865609]   CM = 0, WnR = 0

[   50.865614] user pgtable: 4k pages, 39-bit VAs, pgdp = 00000000f66703d3

[   50.865617] [0000000000000000] pgd=0000000213147003, pud=0000000213147003, pmd=0000000000000000

[   50.865624] Internal error: Oops: 96000006 [#1] PREEMPT SMP

...

[   50.865649] Process falcon (pid: 8909, stack limit = 0x000000000e91af69)

[   50.865654] CPU: 5 PID: 8909 Comm: falcon Tainted: G S      W  O      4.19.157-perf-g8779875ad741 #1

[   50.865657] Hardware name: Qualcomm Technologies, Inc. xiaomi apollo (DT)

[   50.865661] pstate: 00400005 (nzcv daif +PAN -UAO)

[   50.865669] pc : \_\_list\_del\_entry\_valid+0x34/0xd0

[   50.865672] lr : dma\_buf\_detach+0x34/0xa0

[   50.865675] sp : ffffff802c7bb990

...

[   50.865735] Call trace:

[   50.865739]  \_\_list\_del\_entry\_valid+0x34/0xd0

[   50.865742]  dma\_buf\_detach+0x34/0xa0

[   50.865746]  fastrpc\_mmap\_free+0x3e8/0x4d0

[   50.865749]  fastrpc\_file\_free+0x1a8/0x2e0

[   50.865753]  fastrpc\_device\_release+0x50/0x68

[   50.865757]  \_\_fput+0xb8/0x1b0

[   50.865762]  \_\_\_\_fput+0xc/0x18

[   50.865764]  task\_work\_run+0x8c/0xb0

[   50.865767]  do\_exit+0x3fc/0xa10

[   50.865770]  do\_group\_exit+0x8c/0xa0

[   50.865773]  get\_signal+0x7c8/0x958

[   50.865778]  do\_notify\_resume+0x148/0x23e8

[   50.865781]  work\_pending+0x8/0x10

[   50.865785] Code: f9400669 91040042 eb02013f 54000260 (f9400122)

[   50.865789] ---[ end trace 42c589b65f43d4ee ]---

[   50.865802] Kernel panic - not syncing: Fatal exception

We see right away from the first panic that the exploit appears to be targeting a driver called adsprpc. We also see from the stacktrace that the crash is happening when freeing a fastrpc\_mmap struct - so it seems likely this is a heap exploit of some sort, and that a fastrpc\_mmap struct is potentially involved.

##### Log 2:

[   37.450199] adsprpc: fastrpc\_init\_process: untrusted app trying to attach to privileged DSP PD

[   37.482741] adsprpc: mapping not found to unmap fd 0xffffffff, va 0xffffffffffffffff, len 0xffffffff

[   37.482759] adsprpc: falcon: fastrpc\_internal\_mmap: ERROR: adding user allocated pages is not supported

[   37.486210] adsprpc: mapping not found to unmap fd 0xa, va 0x0, len 0x0

...

[   40.917577] adsprpc: ERROR:fastrpc\_mmap\_free, Invalid channel id: 1702834303, err:-44

...

[   41.970037] adsprpc: ERROR:fastrpc\_mmap\_free, Invalid channel id: 1702834303, err:-44

...

[   51.052781] adsprpc: ERROR:fastrpc\_mmap\_free, Invalid channel id: 1702834303, err:-44

...

[   73.964765] adsprpc: ERROR:fastrpc\_mmap\_free, Invalid channel id: 1702834303, err:-44

...

[   83.030394] adsprpc: ERROR:fastrpc\_mmap\_free, Invalid channel id: 1702834303, err:-44

...

[   86.358103] Unable to handle kernel paging request at virtual address 0035fb968c5d536d

[   86.358118] Mem abort info:

[   86.358122]   ESR = 0x96000044

[   86.358127]   Exception class = DABT (current EL), IL = 32 bits

[   86.358131]   SET = 0, FnV = 0

[   86.358135]   EA = 0, S1PTW = 0

[   86.358139] Data abort info:

[   86.358143]   ISV = 0, ISS = 0x00000044

[   86.358147]   CM = 0, WnR = 1

[   86.358151] [0035fb968c5d536d] address between user and kernel address ranges

[   86.358159] Internal error: Oops: 96000044 [#1] PREEMPT SMP

...

[   86.358221] Process falcon (pid: 7053, stack limit = 0x00000000a7dfa97f)

[   86.358230] CPU: 0 PID: 7053 Comm: falcon Tainted: G S         O      4.19.157-perf-g8779875ad741 #1

[   86.358235] Hardware name: Qualcomm Technologies, Inc. xiaomi apollo (DT)

[   86.358241] pstate: 60400005 (nZCv daif +PAN -UAO)

[   86.358259] pc : fastrpc\_file\_free+0x1c4/0x2e0

[   86.358264] lr : fastrpc\_file\_free+0x198/0x2e0

[   86.358268] sp : ffffff80264d3a50

...

[   86.358352] Call trace:

[   86.358359]  fastrpc\_file\_free+0x1c4/0x2e0

[   86.358364]  fastrpc\_device\_release+0x50/0x68

[   86.358374]  \_\_fput+0xb8/0x1b0

[   86.358380]  \_\_\_\_fput+0xc/0x18

[   86.358387]  task\_work\_run+0x8c/0xb0

[   86.358394]  do\_exit+0x3fc/0xa10

[   86.358399]  do\_group\_exit+0x8c/0xa0

[   86.358405]  get\_signal+0x7c8/0x958

[   86.358412]  do\_notify\_resume+0x148/0x23e8

[   86.358418]  work\_pending+0x8/0x10

[   86.358424] Code: b4ffff68 f9400009 f9000109 b4fffee9 (f9000528)

[   86.358430] ---[ end trace 9b01c55ca2d0bfea ]---

[   86.358452] Kernel panic - not syncing: Fatal exception

Here’s another crash in the adsprpc driver, this time associated with a fastrpc\_file struct which is associated with a struct file which itself is the backing object referenced by a file descriptor. We also see that the exploit appears to have gotten farther in the exploit process this time and was making multiple calls to fastrpc\_mmap\_free. Notably the channel id is set to this very large value: 1702834303. Channel id’s can’t usually be set this high. While the maximum value varies from version to version, valid channel ids are in the range from 0 to about 6, so it’s clear that there is somehow memory corruption of the channel id (cid). It is also notable that the channel id value is set to a Unix epoch timestamp value - something Donncha of Amnesty noticed in the course of investigation. 1702834...