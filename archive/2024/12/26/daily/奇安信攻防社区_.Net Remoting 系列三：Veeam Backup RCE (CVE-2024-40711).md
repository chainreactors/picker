---
title: .Net Remoting 系列三：Veeam Backup RCE (CVE-2024-40711)
url: https://forum.butian.net/share/4000
source: 奇安信攻防社区
date: 2024-12-26
fetch_date: 2025-10-06T19:33:07.875049
---

# .Net Remoting 系列三：Veeam Backup RCE (CVE-2024-40711)

#

[问答](https://forum.butian.net/questions)

*发起*

* [提问](https://forum.butian.net/question/create)
* [文章](https://forum.butian.net/share/create)

[攻防](https://forum.butian.net/community)
[活动](https://forum.butian.net/movable)

Toggle navigation

* [首页 (current)](https://forum.butian.net)
* [问答](https://forum.butian.net/questions)
* [商城](https://forum.butian.net/shop)
* [实战攻防技术](https://forum.butian.net/community)
* [漏洞分析与复现](https://forum.butian.net/articles)
  NEW
* [活动](https://forum.butian.net/movable)
* [摸鱼办](https://forum.butian.net/questions/Play)

搜索

* [登录](https://forum.butian.net/login)
* [注册](https://user.skyeye.qianxin.com/user/register?next=http://forum.butian.net/btlogin)

### .Net Remoting 系列三：Veeam Backup RCE (CVE-2024-40711)

* [漏洞分析](https://forum.butian.net/topic/48)

本次带来一个相对完整的分析案例

前置知识
----
<https://codewhitesec.blogspot.com/2022/01/dotnet-remoting-revisited.html>
<https://github.com/codewhitesec/RogueRemotingServer>
Remoting代码逻辑分析
--------------
按照之前的思路：
1. 注册的Channel类型（全局搜ChannelServices#RegisterChannelInternal）
2. sinkProviderChains
3. TypeFilterLevel
4. 注册的objecturi（全局搜RemotingConfiguration#RegisterWellKnownServiceType或RemotingServices#Marshal）
5. 处理消息逻辑（`IServerChannelSink#ProcessMessage`的实现）
首先定位到Veeam.Common.Remoting.dll文件发现有TransportSink和FormatterSink相关的类，但是并没有自定义的ServerChannel，搜索`ChannelServices#RegisterChannelInternal`的调用找到注册ServerChannel的地方：
![Pasted image 20240911111358.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/12/attach-8caddf97a05f943cf69ec767708203f27ada5c40.png)
挨个看过去只有CSrvTcpChannelRegistration类注册了一个tcpServerChannel，具体调用代码如下：
```php
private static TcpServerChannel RegisterChannel(Dictionary<string, string> channelProperties, IServerChannelSinkProvider sinkProvider, CConnectionInterceptor connectionInterceptor)
{
TcpServerChannel tcpServerChannel = new TcpServerChannel(channelProperties, sinkProvider, connectionInterceptor);
// 开启认证
tcpServerChannel.IsSecured = true;
ChannelServices.RegisterChannel(tcpServerChannel, true);
CSrvTcpChannelRegistration.LogChannelData(tcpServerChannel);
return tcpServerChannel;
}
```
注意这里TcpServerChannel传入的有第三个参数CConnectionInterceptor，这里放到后面再说，我们先梳理sinkProviderChains。
继续查找调用寻找sinkProvider定义的地方：
```php
//其构造函数
private CSrvTcpChannelRegistration(string commonChannelName, int port, IReadOnlyDictionary<string, string> channelProperties, bool enableRemotingPerfLog, bool requireBasicPermission, [CanBeNull] IActivityMonitor monitor, [CanBeNull] IImpersonationProvider impersonation, [CanBeNull] IAccessCheckProvider accessCheckerProvider, [CanBeNull] IMfaProvider mfaProvider)
{
this.\_commonChannelName = commonChannelName;
this.\_port = port;
//调用GetSinkProvider方法
IServerChannelSinkProvider sinkProvider = CSrvTcpChannelRegistration.GetSinkProvider(enableRemotingPerfLog, requireBasicPermission, monitor, impersonation, accessCheckerProvider, mfaProvider);
CConnectionInterceptor cconnectionInterceptor = new CConnectionInterceptor();
if (Socket.OSSupportsIPv4)
{
TcpServerChannel tcpServerChannel = CSrvTcpChannelRegistration.RegisterChannel(CSrvTcpChannelRegistration.CreateIPv4BindingConfiguration(commonChannelName, channelProperties), sinkProvider, cconnectionInterceptor);
this.\_channelIPv4Name = tcpServerChannel.ChannelName;
}
......
}
```
跟进GetSinkProvider方法
```php
private static IServerChannelSinkProvider GetSinkProvider(bool enableRemotingPerfLog, bool requireBasicPermission, [CanBeNull] IActivityMonitor monitor, [CanBeNull] IImpersonationProvider impersonation, [CanBeNull] IAccessCheckProvider accessCheckerProvider, [CanBeNull] IMfaProvider mfaProvider)
{
IServerChannelSinkProvider serverChannelSinkProvider = new CBinaryServerFormatterSinkProvider(enableRemotingPerfLog, requireBasicPermission, accessCheckerProvider, mfaProvider);
if (monitor != null)
{
serverChannelSinkProvider = new CActivityMonitorServerSinkProvider(monitor, serverChannelSinkProvider);
}
if (impersonation != null)
{
serverChannelSinkProvider = new CImpersonationServerSinkProvider(impersonation, serverChannelSinkProvider);
}
return serverChannelSinkProvider;
}
```
这里使用的是\*\*CBinaryServerFormatterSink\*\*作为FormatterSink，TransportSink使用的默认TcpServerTransportSink，整个服务端的sinkProviderChains：`TcpServerTransportSink → CBinaryServerFormatterSink → DispatchChannelSink`
同时CBinaryServerFormatterSink中定义了TypeFilterLevel.Low
追溯到启动类发现监听的端口为9392，服务名为`Veeam.Backup.Service.exe`（tcp://IP:9392/VeeamClientUpdateService ）。
最后找到对应的ProcessMessage方法梳理处理消息的逻辑，主要代码如下：
```php
public ServerProcessing ProcessMessage(IServerChannelSinkStack sinkStack, IMessage requestMsg, ITransportHeaders requestHeaders, Stream requestStream, out IMessage responseMsg, out ITransportHeaders responseHeaders, out Stream responseStream)
{
ServerProcessing serverProcessing;
using (LogRegistration.RegisterSafe(this.\_logStorage))
{
......
string text = (string)requestHeaders["Content-Type"];
string text2 = (string)requestHeaders["\_\_RequestVerb"];
......
//部分省略
requestMsg = CBinaryServerFormatterSink.DeserializeBinaryRequestMessage(requestStream, requestHeaders);
if (requestMsg == null)
{
throw new RemotingException("Remoting Deserialize Error");
}
IMethodMessage methodMessage = requestMsg as IMethodMessage;
if (methodMessage != null)
{
string text3 = requestHeaders["access\_token"] as string;
Dictionary<string, object> dictionary;
EJwtValidationResult ejwtValidationResult = this.\_mfaProvider.ValidateToken(text3, out dictionary);
if (ejwtValidationResult == EJwtValidationResult.Empty || ejwtValidationResult == EJwtValidationResult.Invalid)
{
this.EnsureMfa(requestHeaders);
}
this.EnsureAccessIsAllowed(methodMessage);
}
sinkStack.Push(this, null);
ServerProcessing serverProcessing2 = this.CallNextSink(sinkStack, requestMsg, requestHeaders, null, out responseMsg, out responseHeaders, out responseStream);
if (responseStream != null)
{
throw new RemotingException("Remoting\_ChnlSink\_WantNullResponseStream");
}
switch (serverProcessing2)
{
case ServerProcessing.Complete:
if (responseMsg == null)
{
throw new RemotingException("Remoting\_DispatchMessage");
}
sinkStack.Pop(this);
this.AddSessionToken(requestHeaders, ref responseHeaders);
CBinaryServerFormatterSink.SerializeResponse(sinkStack, responseMsg, ref responseHeaders, out responseStream);
this.AdditionalyLogResponse(responseMsg);
......
}
}
}
return serverProcessing;
}
```
调用DeserializeBinaryRequestMessage方法执行反序列化的操作，也是整个过程中最关键的，实现如下
```php
//Veeam.Common.Remoting.CBinaryServerFormatterSink#DeserializeBinaryRequestMessage
private static IMessage DeserializeBinaryRequestMessage(Stream requestStream, ITransportHeaders requestHeaders)
{
IMessage message;
try
{
message = (IMessage)CBinaryServerFormatterSink.CreateFormatter(false).DeserializeMethodResponse(requestStream, new HeaderHandler(new CBinaryServerFormatterSink.UriHeaderHandler(requestHeaders).HeaderHandler), null);
}
finally
{
requestStream.Close();
}
return message;
}
//Veeam.Common.Remoting.CBinaryServerFormatterSink#CreateFormatter
private static BinaryFormatter CreateFormatter(bool serializingResponse)
{
BinaryFormatter binaryFormatter = new BinaryFormatter();
binaryFormatter.Binder = new RestrictedSerializationBinder(serializingResponse, RestrictedSerializationBinder.Modes.FilterByWhitelist);
binaryFormatter.Context = new StreamingContext(StreamingContextStates.Other);
binaryFormatter.FilterLevel = TypeFilterLevel.Low;
binaryFormatter.AssemblyFormat = FormatterAssemblyStyle.Full;
if (!serializingResponse)
{
binaryFormatter.SurrogateSelector = new CDataSerializationSurogate();
}
else
{
ISurrogateSelector surrogateSelector = new RemotingSurrogateSelector();
surrogateSelector.ChainSelector(new CDataSerializationSurogate());
binaryFormatter.SurrogateSelector = surrogateSelector;
}
return binaryFormatter;
}
```
这儿有两点需要注意：
1. 定义了RestrictedSerializationBinder设置反序列化白名单或黑名单
2. 定义了CDataSerializationSurogate作为formatter的序列化或反序列化处理
首先看RestrictedSerializationBinder是如何防御的，关注ResolveType方法和BindToType方法，如果仅仅使用CustomSerializationBinder是可以绕的，数据流：`CustomSerializati...