---
title: CVE-2024-41009 Linux内核的bpf ringbuf中存在一个缓冲区重叠漏洞分析与利用
url: https://forum.butian.net/share/4024
source: 奇安信攻防社区
date: 2025-01-10
fetch_date: 2025-10-06T20:05:59.852127
---

# CVE-2024-41009 Linux内核的bpf ringbuf中存在一个缓冲区重叠漏洞分析与利用

#

[问答](https://forum.butian.net/questions)

*发起*

* [提问](https://forum.butian.net/question/create)
* [文章](https://forum.butian.net/share/create)

[攻防](https://forum.butian.net/community)
[活动](https://forum.butian.net/movable)

Toggle navigation

* [首页 (current)](https://forum.butian.net)
* [问答](https://forum.butian.net/questions)
* [商城](https://forum.butian.net/shop)
* [实战攻防技术](https://forum.butian.net/community)
* [漏洞分析与复现](https://forum.butian.net/articles)
  NEW
* [活动](https://forum.butian.net/movable)
* [摸鱼办](https://forum.butian.net/questions/Play)

搜索

* [登录](https://forum.butian.net/login)
* [注册](https://user.skyeye.qianxin.com/user/register?next=http://forum.butian.net/btlogin)

### CVE-2024-41009 Linux内核的bpf ringbuf中存在一个缓冲区重叠漏洞分析与利用

* [漏洞分析](https://forum.butian.net/topic/48)

Linux内核的bpf ringbuf中存在一个缓冲区重叠漏洞。可以使得第二个分配的内存块与第一个内存块重叠，结果就是BPF程序能够编辑第一个内存块的头部。一旦第一个内存块的头部被修改，bpf\_ringbuf\_commit()就会引用错误的页面，可能会导致崩溃。

背景
==
以下内容摘自 [提交信息](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit?id=cfa1a2329a691ffd991fcf7248a57d752e712881)：
> BPF 环形缓冲区内部实现为大小为 2 的幂次方的循环缓冲区，并使用两个逻辑且不断递增的计数器：`consumer\_pos` 表示消费者消费数据的位置，`producer\_pos` 表示生产者已保留的数据量。&lt;br&gt;&lt;br&gt;
> 每次预留一个记录时，负责该记录的生产者会推进生产者计数器。每当用户空间读取记录时，消费者会在处理完成后推进消费者计数器。两个计数器存储在不同的内存页中，因此，用户空间只能读 `producer\_pos`（只读），而可以读写 `consumer\_pos`（可读写）。
`bpf\_ringbuf` 的结构布局如下：
```c
struct bpf\_ringbuf {
wait\_queue\_head\_t waitq;
struct irq\_work work;
u64 mask;
struct page \*\*pages;
int nr\_pages;
spinlock\_t spinlock \_\_\_\_cacheline\_aligned\_in\_smp;
atomic\_t busy \_\_\_\_cacheline\_aligned\_in\_smp;
unsigned long consumer\_pos \_\_aligned(PAGE\_SIZE); // 用户空间可读写
unsigned long producer\_pos \_\_aligned(PAGE\_SIZE); // 用户空间只读
unsigned long pending\_pos;
char data[] \_\_aligned(PAGE\_SIZE);
};
```
`BPF\_FUNC\_ringbuf\_reserve` 用于从 `BPF\_MAP\_TYPE\_RINGBUF` 中分配内存。它会预留 8 字节空间，用于记录头部结构：
```c
/\* 8 字节的环形缓冲区记录头结构 \*/
struct bpf\_ringbuf\_hdr {
u32 len;
u32 pg\_off;
};
```
并返回 `(void \*)hdr + BPF\_RINGBUF\_HDR\_SZ`，供 eBPF 程序使用。eBPF 程序无法修改 `bpf\_ringbuf\_hdr`，因为它位于内存块外部。
然而，通过故意修改 `&rb->consumer\_pos`，可以使第二次分配的内存块与第一次分配的内存块重叠。这样，eBPF 程序就能修改第一个内存块的头部。下面是具体步骤：
1. 首先，我们创建一个大小为 `0x4000` 的 `BPF\_MAP\_TYPE\_RINGBUF`，并在调用 `BPF\_FUNC\_ringbuf\_reserve` 前将 `consumer\_pos` 修改为 `0x3000`。
2. 分配块 A，它位于 `[0x0, 0x3008]`，此时 eBPF 程序可以编辑 `[0x8, 0x3008]`。
3. 接下来分配块 B，大小为 `0x3000`，此时会成功分配，因为 `consumer\_pos` 已提前修改，可以通过检查。
4. 块 B 会位于 `[0x3008, 0x6010]`，eBPF 程序可以编辑 `[0x3010, 0x6010]`。
在内核代码中，检查逻辑如下：
```c
static void \*\_\_bpf\_ringbuf\_reserve(struct bpf\_ringbuf \*rb, u64 size)
{
...
len = round\_up(size + BPF\_RINGBUF\_HDR\_SZ, 8);
...
prod\_pos = rb->producer\_pos;
new\_prod\_pos = prod\_pos + len;
/\* 检查环形缓冲区是否溢出，确保生产者位置
\* 不会提前超出环形缓冲区的大小
\*/
if (new\_prod\_pos - cons\_pos > rb->mask) {
// 失败路径
spin\_unlock\_irqrestore(&rb->spinlock, flags);
return NULL;
}
// 成功路径
}
```
由于 `cons\_pos` 的值为 `0x3000`（通过用户空间修改），`new\_prod\_pos` 为 `0x6010`，`rb->mask` 为 `0x4000 - 1`，条件满足，因此返回在 `[0x3008, 0x6010]` 之间分配的缓冲区给 eBPF 程序。
由于环形缓冲区的内存布局是如下分配的：
```c
static struct bpf\_ringbuf \*bpf\_ringbuf\_area\_alloc(size\_t data\_sz, int numa\_node)
{
int nr\_meta\_pages = RINGBUF\_NR\_META\_PAGES;
int nr\_data\_pages = data\_sz >> PAGE\_SHIFT;
int nr\_pages = nr\_meta\_pages + nr\_data\_pages;
...
/\* 每个数据页面被映射两次，以便“虚拟”连续读取绕过环形缓冲区末尾的数据：
\* ------------------------------------------------------
\* | 元数据页面 | 实际数据页面 | 重复的数据页面 |
\* ------------------------------------------------------
\* | | 1 2 3 4 5 6 7 8 9 | 1 2 3 4 5 6 7 8 9 |
\* ------------------------------------------------------
\* | | TA DA | TA DA |
\* ------------------------------------------------------
\* ^^^^^^^
\* |
\* 在这种布局下，不需要特殊处理绕环数据，因为数据页面被双重映射。这样无论在内核还是用户空间中 mmap 都能正常工作。
\*/
array\_size = (nr\_meta\_pages + 2 \* nr\_data\_pages) \* sizeof(\*pages);
pages = bpf\_map\_area\_alloc(array\_size, numa\_node);
if (!pages)
return NULL;
for (i = 0; i < nr\_pages; i++) {
page = alloc\_pages\_node(numa\_node, flags, 0);
if (!page) {
nr\_pages = i;
goto err\_free\_pages;
}
pages[i] = page;
if (i >= nr\_meta\_pages)
pages[nr\_data\_pages + i] = page;
}
rb = vmap(pages, nr\_meta\_pages + 2 \* nr\_data\_pages,
VM\_MAP | VM\_USERMAP, PAGE\_KERNEL);
...
}
```
`[0x0, 0x4000]` 和 `[0x4000, 0x8000]` 指向相同的数据页面。这意味着我们可以通过 `[0x4000, 0x4008]` 访问块 B，这将指向块 A 的头部。
利用
==
`BPF\_FUNC\_ringbuf\_submit`/`BPF\_FUNC\_ringbuf\_discard` 使用头部的 `pg\_off` 来定位元数据页面。
```c
bpf\_ringbuf\_restore\_from\_rec(struct bpf\_ringbuf\_hdr \*hdr)
{
unsigned long addr = (unsigned long)(void \*)hdr;
unsigned long off = (unsigned long)hdr->pg\_off << PAGE\_SHIFT;
return (void\*)((addr & PAGE\_MASK) - off);
}
static void bpf\_ringbuf\_commit(void \*sample, u64 flags, bool discard)
{
unsigned long rec\_pos, cons\_pos;
struct bpf\_ringbuf\_hdr \*hdr;
struct bpf\_ringbuf \*rb;
u32 new\_len;
hdr = sample - BPF\_RINGBUF\_HDR\_SZ;
rb = bpf\_ringbuf\_restore\_from\_rec(hdr);
```
`pg\_off` 在 `bpf\_ringbuf\_hdr` 中是环形缓冲区块的页面偏移量，因此，`bpf\_ringbuf\_restore\_from\_rec` 会通过减去 `pg\_off` 来从环形缓冲区块地址定位到 `bpf\_ringbuf` 对象。我们可以再次看到 `bpf\_ringbuf\_hdr` 结构：
```c
struct bpf\_ringbuf {
...
unsigned long consumer\_pos \_\_aligned(PAGE\_SIZE); // 用户空间可读写
unsigned long producer\_pos \_\_aligned(PAGE\_SIZE); // 用户空间只读
unsigned long pending\_pos;
char data[] \_\_aligned(PAGE\_SIZE);
}
```
假设块 A 位于 `rb->data` 的第一页，块 A 地址与 `rb->consumer\_pos` 的距离为 `2`。通过利用漏洞，我们将块 A 的 `pg\_off` 修改为 `2`，然后通过 `bpf\_ringbuf\_restore\_from\_rec` 计算出来的元数据页面会指向 `rb->consumer\_pos`。我们可以在用户空间 `mmap` `rb->consumer\_pos` 并控制其内容。
通过构造 `bpf\_ringbuf` 中的 `work` 字段，并在调用 `bpf\_ringbuf\_commit` 时传入 `BPF\_RB\_FORCE\_WAKEUP`，会触发调用我们构造的 `irq\_work` 对象，并将其排入 `irq\_work\_queue`。
```c
static void bpf\_ringbuf\_commit(void \*sample, u64 flags, bool discard)
{
...
rb = bpf\_ringbuf\_restore\_from\_rec(hdr);
...
if (flags & BPF\_RB\_FORCE\_WAKEUP)
irq\_work\_queue(&rb->work);
...
```
构造的 `irq\_work` 会在 `irq\_work\_single` 中被处理，并执行我们控制的函数指针。
```c
void irq\_work\_single(void \*arg)
{
struct irq\_work \*work = arg;
int flags;
flags = atomic\_read(&work->node.a\_flags);
flags &= ~IRQ\_WORK\_PENDING;
atomic\_set(&work->node.a\_flags, flags);
...
lockdep\_irq
\_work\_enter(flags);
work->func(work); // [1]
lockdep\_irq\_work\_exit(flags);
...
}
```
KASLR 绕过
========
为了绕过 kASLR，我们参考了[这一技术](https://github.com/google/security-research/blob/master/pocs/linux/kernelctf/CVE-2023-6817\_mitigation/docs/exploit.md#kaslr-bypass)。
ROP 链
=====
通过观察，我们发现 RBX/RDI 会包含 `work` 字段的地址，且我们可以控制从 `RDI + 0x18` 开始的 ROP 数据。接下来，我们使用此 ROP 小工具进行堆栈跳转到我们的控制数据。
```php
0x00000000004b78b1 : push rbx ; or byte ptr [rbx + 0x41], bl ; pop rsp ; pop r13 ; pop rbp ; ret
```
然后，我们继续执行 ROP 有效负载，通过覆盖 `core\_pattern` 来触发漏洞。通过触发崩溃，它将以高权限执行我们的攻击。
### 参考
[https://github.com/google/security-research/blob/master/pocs/linux/kernelctf/CVE-2024-41009\\_lts\\_cos/docs/vulnerability.md](https://github.com/google/security-research/blob/master/pocs/linux/kernelctf/CVE-2024-41009\_lts\_cos/docs/vulnerability.md)

* 发表于 2025-01-09 09:00:00
* 阅读 ( 3121 )
* 分类：[代码审计](https://forum.butian.net/community/code%20audit)

0 推荐
 收藏

## 0 条评论

请先 [登录](https://forum.butian.net/login) 后评论

[![吃不饱的崽](https://forum.butian.net/static/images/default_avatar.jpg)](https://forum.butian.net/people/30912)

[吃不饱的崽](https://forum.butian.net/people/30912)

1 篇文章

[奇安信攻防社区](https://forum.butian.net)|
联系我们

|
[sitemap](https://forum.butian.net/sitemap)

Copyright © 2013-2023 BUTIAN.NET 版权所有 [京ICP备18014330号-2](https://beian.miit.gov.cn/#/Integrated/index)

×

#### 发送私信

请先 [登录](https://forum.butian.net/login) 后发送私信

×

#### 举报此文章

垃圾广告信息：
广告、推广、测试等内容

违规内容：
色情、暴力、血腥、敏感信息等内容

不友善内容：
人身攻击、挑衅辱骂、恶意行为

其他原因：
请补充说明

举报原因:

取消
举报

×

#### ![吃不饱的崽](https://forum.butian.net/static/images/default_avatar.jpg)

如果觉得我的文章对您有用，请随意打赏。你的支持将鼓励我继续创作！

![]()

---