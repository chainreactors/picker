---
title: Linux Kernel: Exploiting a Netfilter Use-after-Free in kmalloc-cg
url: https://buaq.net/go-140639.html
source: unSafe.sh - 不安全
date: 2022-12-20
fetch_date: 2025-10-04T01:57:58.688024
---

# Linux Kernel: Exploiting a Netfilter Use-after-Free in kmalloc-cg

* [unSafe.sh - 不安全](https://unsafe.sh)
* [我的收藏](/user/collects)
* [今日热榜](/?hot=true)
* [公众号文章](/?gzh=true)
* [导航](/nav/index)
* [Github CVE](/cve)
* [Github Tools](/tools)
* [编码/解码](/encode)
* [文件传输](/share/index)
* [Twitter Bot](https://twitter.com/buaqbot)
* [Telegram Bot](https://t.me/aqinfo)
* [Search](/search/search)

[Rss](/rss.xml)

[ ]
黑夜模式

![](https://8aqnet.cdn.bcebos.com/7f7a6f0416da221ba50ba0fd4c4318ce.jpg)

Linux Kernel: Exploiting a Netfilter Use-after-Free in kmalloc-cg

OverviewIt’s been a while since our last technical blogpost, so here’s one right
*2022-12-19 23:14:55
Author: [blog.exodusintel.com(查看原文)](/jump-140639.htm)
阅读量:30
收藏*

---

## Overview

It’s been a while since our last technical blogpost, so here’s one right on time for the Christmas holidays. We describe a method to exploit a use-after-free in the Linux kernel when objects are allocated in a specific slab cache, namely the `kmalloc-cg` series of SLUB caches used for cgroups. This vulnerability is assigned [CVE-2022-32250](https://nvd.nist.gov/vuln/detail/cve-2022-32250) and exists in Linux kernel versions 5.18.1 and prior.

The use-after-free vulnerability in the Linux kernel netfilter subsystem was discovered by NCC Group’s Exploit Development Group (EDG). They published a very detailed [write-up](https://research.nccgroup.com/2022/09/01/settlers-of-netlink-exploiting-a-limited-uaf-in-nf_tables-cve-2022-32250) with an in-depth analysis of the vulnerability and an exploitation strategy that targeted Linux Kernel version 5.13. Additionally, Theori [published their own analysis](https://blog.theori.io/research/CVE-2022-32250-linux-kernel-lpe-2022/) and exploitation strategy, this time targetting the Linux Kernel version 5.15. We strongly recommend having a thorough read of both articles to better understand the vulnerability prior to reading this post, which almost exclusively focuses on an exploitation strategy that works on the latest vulnerable version of the Linux kernel, version 5.18.1.

The aforementioned exploitation strategies are different from each other and from the one detailed here since the targeted kernel versions have different peculiarities. In version 5.13, allocations performed with either the `GFP_KERNEL` flag or the `GFP_KERNEL_ACCOUNT` flag are served by the `kmalloc-*` slab caches. In version 5.15, allocations performed with the `GFP_KERNEL_ACCOUNT` flag are served by the `kmalloc-cg-*` slab caches. While in both 5.13 and 5.15 the affected object, `nft_expr,` is allocated using `GFP_KERNEL,`the difference in exploitation between them arises because a commonly used heap spraying object, the System V message structure (`struct msg_msg)`, is served from `kmalloc-*` in 5.13 but from `kmalloc-cg-*` in 5.15. Therefore, in 5.15, `struct msg_msg` cannot be used to exploit this vulnerability.

In 5.18.1, the object involved in the use-after-free vulnerability, `nft_expr,`is itself allocated with `GFP_KERNEL_ACCOUNT` in the `kmalloc-cg-*` slab caches. Since the exploitation strategies presented by the NCC Group and Theori rely on objects allocated with  `GFP_KERNEL,`they do not work against the latest vulnerable version of the Linux kernel.

The subject of this blog post is to present a strategy that works on the latest vulnerable version of the Linux kernel.

## Vulnerability

Netfilter sets can be created with a maximum of two associated expressions that have the `NFT_EXPR_STATEFUL` flag. The vulnerability occurs when a set is created with an associated expression that does not have the `NFT_EXPR_STATEFUL` flag, such as the `dynset` and `lookup` expressions. These two expressions have a reference to another set for updating and performing lookups, respectively. Additionally, to enable tracking, each set has a bindings list that specifies the objects that have a reference to them.

During the allocation of the associated `dynset` or `lookup` expression objects, references to the objects are added to the bindings list of the referenced set. However, when the expression associated to the set does not have the `NFT_EXPR_STATEFUL` flag, the creation is aborted and the allocated expression is destroyed. The problem occurs during the destruction process where the bindings list of the referenced set is not updated to remove the reference, effectively leaving a dangling pointer to the freed expression object. Whenever the set containing the dangling pointer in its bindings list is referenced again and its bindings list has to be updated, a use-after-free condition occurs.

## Exploitation

Before jumping straight into exploitation details, first let’s see the definition of the structures involved in the vulnerability: `nft_set`, `nft_expr`, `nft_lookup`, and `nft_dynset`.

```
// Source: https://elixir.bootlin.com/linux/v5.18.1/source/include/net/netfilter/nf_tables.h#L502

struct nft_set {
        struct list_head           list;                 /*     0    16 */
        struct list_head           bindings;             /*    16    16 */
        struct nft_table *         table;                /*    32     8 */
        possible_net_t             net;                  /*    40     8 */
        char *                     name;                 /*    48     8 */
        u64                        handle;               /*    56     8 */
        /* --- cacheline 1 boundary (64 bytes) --- */
        u32                        ktype;                /*    64     4 */
        u32                        dtype;                /*    68     4 */
        u32                        objtype;              /*    72     4 */
        u32                        size;                 /*    76     4 */
        u8                         field_len[16];        /*    80    16 */
        u8                         field_count;          /*    96     1 */

        /* XXX 3 bytes hole, try to pack */

        u32                        use;                  /*   100     4 */
        atomic_t                   nelems;               /*   104     4 */
        u32                        ndeact;               /*   108     4 */
        u64                        timeout;              /*   112     8 */
        u32                        gc_int;               /*   120     4 */
        u16                        policy;               /*   124     2 */
        u16                        udlen;                /*   126     2 */
        /* --- cacheline 2 boundary (128 bytes) --- */
        unsigned char *            udata;                /*   128     8 */

        /* XXX 56 bytes hole, try to pack */

        /* --- cacheline 3 boundary (192 bytes) --- */
        const struct nft_set_ops  * ops __attribute__((__aligned__(64))); /*   192     8 */
        u16                        flags:14;             /*   200: 0  2 */
        u16                        genmask:2;            /*   200:14  2 */
        u8                         klen;                 /*   202     1 */
        u8                         dlen;                 /*   203     1 */
        u8                         num_exprs;            /*   204     1 */

        /* XXX 3 bytes hole, try to pack */

        struct nft_expr *          exprs[2];             /*   208    16 */
        struct list_head           catchall_list;        /*   224    16 */
        unsigned char              data[] __attribute__((__aligned__(8))); /*   240     0 */

        /* size: 256, cachelines: 4, members: 29 */
        /* sum members: 176, holes: 3, sum holes: 62 */
        /* sum bitfield members: 16 bits (2 bytes) */
        /* padding: 16 */
        /* forced alignments: 2, forced holes: 1, sum forced holes: 56 */
} __attribute__((__aligned__(64)));
```

The `nft_set` structure represents an nftables set, a built-in generic infrastructure of nftables that allows using any supported selector to build sets, which makes possible the representation of maps and verdict maps (check the [corresponding nftables wiki entry](https://wiki.nftables.org/wiki-nftables/index.p...