---
title: Emulating inline decryption for triaging C++ malware
url: https://viuleeenz.github.io/posts/2024/05/emulating-inline-decryption-for-triaging-c-malware/
source: Over Security - Cybersecurity news aggregator
date: 2024-05-17
fetch_date: 2025-10-06T17:19:16.762791
---

# Emulating inline decryption for triaging C++ malware

[>
$ cd /home/Viuleeenz](../../../../)

* [About](../../../../about/)
* [Posts](../../../../posts/)
* [Whitepapers](../../../../whitepapers/)

11 minutes

# [Emulating inline decryption for triaging C++ malware](https://Viuleeenz.github.io/posts/2024/05/emulating-inline-decryption-for-triaging-c-malware/)

## What we need to know?

C and C++ binaries share several commonalities, however, some additional features and complexities introduced by C++ can make reverse engineering C++ binaries more challenging compared to C binaries. Some of the most important features are:

**Name Mangling**: C++ compilers often use name mangling to encode additional information about functions and classes into the symbol names in the binary. This can make it more challenging to understand the code’s structure and functionality by simply looking at symbol names.

**Object-Oriented Features**: C++ supports object-oriented programming (OOP) features such as classes, inheritance, polymorphism, and virtual functions. Reverse engineering C++ binaries may involve identifying and understanding these constructs, which may not exist in C binaries.

**Templates**: C++ templates allow for generic programming, where functions and classes can operate on different data types. Reverse engineering C++ templates can be complex due to the generation of multiple versions of the same function or class template with different types.

Another topic that is **mandatory to understand** when we approach binaries is related to the **calling convention.** Even if it’s determined by the operating system and the compiler ABI (Application Binary Interface) rather than the specific programming language being used, its one of the fundamental aspects that too many times is overlooked.

> 💡There are many other differences related to **Runtime Type Information (RTTI)**, **Constructor and Destructor Calls,* Exception Handling and **Compiler-Specific Features**. Those topics aren’t less important than the others mentioned above, however, explaining a basic triage does not involve those topics and giving an explanation for all of them could just lose the focus. Moreover,* If you don’t feel comfortable with **calling conventions**, refer to exceptional material on [OALabs](https://www.youtube.com/watch?v=9lzW0I9_cpY).

## Why GlorySprout?

I know, probably this name for most of you does not mean anything because it does not represent one the most prominent threats on Cyberspace, however, didactically speaking, it has a lot of characteristics that make it a great fit. First of all it’s a recent malware and because of this, it shares most of the capabilities employed by more famous ones such as: **obfuscation**, **api hashing**, **inline decryption** etc.. Those characteristics are quite challenging to deal with, especially if we go against them to build an automation script that is going to replicate our work on multiple samples.

Another interesting characteristic of this malware is that it represents a fork of another malware called Taurus Stealer as reported by RussianPanda in her article. So, why is it important? Taurus Stealers have been dissected and a detailed report is available here. From a learning stand point it represents a plus, since if you are stuck somewhere in the code, you have a way out trying to match this GlorySprout capabilities with Taurus.

Let’s start our triage.

## Binary Overview

Opening up the binary in IDA and scrolling a little bit from the main functions it should be clear that this binary is going to use some api hashing for retrieving DLLs, inline decryption and C++ structures to store some interesting value. To sum up, this binary is going to start resolving structures and APIs, perform inline decryption to start checking Windows information and installed softwares. However, those actions are not intended to be taken without caution. In fact, each time a string is decrypted, its memory region is then immediately zeroed after use. It means that a “*quick and dirty*” approach using dynamic analysis to inspect memory sections won’t give you insights about strings and/or targets.

![Figure 1: Binary Overview](../../../../img/glory_sprout/binary_overview.png)

Figure 1: Binary Overview

### Identifying and Creating Structures

Identifying and creating structures is one of the most important tasks when we deal with C++ malware. Structures are mostly reused through all code, because of that, having a good understanding of structures is mandatory for an accurate analysis. In fact, applying structures properly will make the whole reversing process way more easier.

Now you may be wondering, how do we recognise a structure? In order to recognise structures it’s important to observe **how a function is called** and **how input parameters are actually used**.

In order to explain it properly, let’s take an example from GlorySprout.

![Figure 2: Passing structure parameter](../../../../img/glory_sprout/passing_structure.png)

Figure 2: Passing structure parameter

Starting from left to right, we see some functions callings that could help us to understand that we are dealing with a structure. Moreover, its also clear in this case, **how big the structures is**.

> 💡*As said before, **calling convention is important** to understand how parameters are passed to a function. In this case, we are dealing with is a clear example of **thiscall**.*

Let’s have a look at the function layout. Even if we are seeing that **ecx** is going to be used as a parameter for three functions, it is actually used each time with a different offset (this is a good indication that we are dealing with a structure). Moreover, if we have a look at the first call (`sub_401DEB`), this function seems to fill the first **0xF4** (244 in decimal) bytes pointed by **ecx** with some values. Once the function ends, there is the instruction **lea ecx, [esi+0F8h]** and another function call. This pattern is used a couple of times and confirms our hypothesis that each function is in charge to fill some offset of the structure.

From the knowledge we have got so far and looking at the code, we could also infer the structure passed to the third call (`sub_406FF1`) and the whole size of the structure.

```
sub_406FF1_bytes_to_fill = 0xF8 - 0x12C = 0x34 (52 bytes)
structure_size = 0xF8 + 0x34 = 0x12C (300 bytes) + 4 bytes realted to the size of the last value.
```

However, even if we resolved the size structures and understood where it is used, there is still a point missing. **Where does this structure come from?** To answer this question, it’s important to take a step back. Looking at the function`sub_40100A` we see the instruction [**mov ecx , offset unk\_4463F8**]. If you explore that variable you will see that it is stored at `0x004463F8` and the next variable is stored at `0x0044652F`. If we do a subtraction through these two addresses, we have **312** bytes. There are two important things to highlight here. First of all, we are dealing with a **global structure** that is going to be used multiple times in different code sections (because of that, naming structure fields will be our first task), however, according to the size calculated, it seems that we are missing a few bytes. This could be a good indication that additional bytes will be used later on in the code to store an additional value. In fact, this insight is confirmed if we analyze the last function (`sub_40B838`). Opening up the function and skipping the prolog instructions, we could immediately see that the structure is moved in `esi`, and then a **dword** is moved to **esi+4**. It means that **esi** is adding **4 bytes** to the structure that means that now the structure size is **308 bytes**.

![Figure 3: Understanding structure size](../../../../img/glory_sprout/structure_size.png)

Figure 3: Understanding structure size

Now that we have a better understanding of the structure’s size, it’s time to understand its values. In order to figure out what hex valu...