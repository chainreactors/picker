---
title: Bypassing File Upload Restrictions To Exploit Client-Side Path Traversal
url: https://blog.doyensec.com/2025/01/09/cspt-file-upload.html
source: Over Security - Cybersecurity news aggregator
date: 2025-01-10
fetch_date: 2025-10-06T20:11:47.700532
---

# Bypassing File Upload Restrictions To Exploit Client-Side Path Traversal

[

](https://doyensec.com/img/home-video.mp4)

[![](/public/images/doyensec-logo.svg)](/index.html)

[![](/public/images/logo.svg)](/index.html)

#### ABOUT US

We are [**security engineers**](https://doyensec.com) who break bits and tell stories.

Visit us
[doyensec.com](https://doyensec.com)

Follow us
[@doyensec](https://twitter.com/doyensec)

Engage us
info@doyensec.com

#### Blog Archive

* 2025
* 2024
* 2023
* 2022
* 2021
* 2020
* 2019
* 2018
* 2017

© 2025 [Doyensec LLC](https://doyensec.com) [![](/public/images/rss.png)](/atom.xml "RSS")

# Bypassing File Upload Restrictions To Exploit Client-Side Path Traversal

09 Jan 2025 - Posted by Maxence Schmitt

![Doyensec CSPT](../../../public/images/cspt2.png)

In my [previous blog post](https://blog.doyensec.com/2024/07/02/cspt2csrf.html), I demonstrated how a JSON file could be used as a gadget for Client-Side Path Traversal (CSPT) to perform Cross-Site Request Forgery (CSRF). That example was straightforward because no file upload restriction was enforced. However, real-world applications often impose restrictions on file uploads to ensure security.

In this post, weâll explore how to bypass some of these mechanisms to achieve the same goal. Weâll cover common file validation methods and how they can be subverted.

# Constraint

In most scenarios, the gadget file will be parsed in the front-end using `JSON.parse`.
It means that our file must be a valid input for `JSON.parse`.
If we look at the [V8 implementation](https://github.com/v8/v8/blob/refs/tags/13.2.67/src/json/json-parser.cc). A valid JSON input is :

* a string
* a number
* true
* false
* null
* an array
* an object

The parser skips starting [WHITESPACE characters](https://github.com/v8/v8/blob/refs/tags/13.2.67/src/json/json-parser.cc#L563C1-L575C2) such as :

* â â
* â\tâ
* â\râ
* â\nâ

Also, control characters and double quotes inside a JSON object (key or value) will break the JSON structure and must be escaped.

Our gadget file must follow these restrictions to be parsed as JSON.

Different applications validate files using libraries or tools designed to detect the fileâs MIME type, file structure or magic bytes. By creatively crafting files that meet these conditions, we can fool these validations and bypass the restrictions.

Letâs explore how various file upload mechanisms can be bypassed to maintain valid JSON payloads for CSPT while satisfying file format requirements, such as PDFs or images.

# Bypassing PDF Checks To Upload a JSON File

A basic check in many upload mechanisms involves verifying the fileâs MIME type. This is often done using the `Content-Type` header or by inspecting the file itself. However, these checks can often be bypassed by manipulating the fileâs structure or headers.

## Bypassing mmmagic Validation

The [mmmagic](https://github.com/mscdex/mmmagic) library is commonly used in Node.js applications to detect file types based on the [Magic database](https://github.com/file/file/blob/master/magic/Magdir/).
A PDF file can be verified with the following code:

```
async function checkMMMagic(binaryFile) {
    var magic = new Magic(mmm.MAGIC_MIME_TYPE);

    const detectAsync = (binaryFile) => {
        return new Promise((resolve, reject) => {
            magic.detect.call(magic, binaryFile, (error, result) => {
                if (error) {
                    reject(error);
                } else {
                    resolve(result);
                }
            });
        });
    };

    const result = await detectAsync(binaryFile);

    const isValid = (result === 'application/pdf')
    if (!isValid) {
        throw new Error('mmmagic: File is not a PDF : ' + result);
    }
}
```

### Technique:

The library checks for the `%PDF` magic bytes. It uses the Magic detection rules defined [here](https://github.com/file/file/blob/FILE5_46/magic/Magdir/pdf#L45C1-L45C34). However, according to the PDF specification, this magic number doesnât need to be at the very beginning of the file.

We can wrap a PDF header within the first 1024 bytes of a JSON object. It will be a valid JSON file considered as a PDF by the library. This allows us to fool the library into accepting the upload as a valid PDF while still allowing it to be parsed as JSON by the browser. Hereâs an example:

`{ "id" : "../CSPT_PAYLOAD", "%PDF": "1.4" }`

As long as the `%PDF` header appears within the first 1024 bytes, the `mmmagic` library will accept this file as a PDF, but it can still be parsed as JSON on the client side.

## Bypassing pdflib Validation

The [pdflib](https://www.pdflib.com) library requires more than just the `%PDF` header. It can be used to validate the overall PDF structure.

```
async function checkPdfLib(binaryFile) {
    let pdfDoc = null
    try {
        pdfDoc = await PDFDocument.load(binaryFile);
    } catch (error) {
        throw new Error('pdflib: Not a valid PDF')
    }

    if (pdfDoc.getPageCount() == 0) {
        throw new Error('pdflib: PDF doesn\'t have a page');
    }
}
```

### Technique:

To bypass this, we can create a valid PDF (for pdflib) that still conforms to the JSON structure required for CSPT.
The trick is to replace `%0A` (line feed) characters between PDF object definitions with space `%20`. This allows the file to be recognized as a valid PDF for `pdflib` but still be interpretable as JSON. The xref table doesnât need to be fixed because our goal is not to display the PDF, but to pass the upload validation.

Hereâs an example:

```
{"_id":"../../../../CSPT?","bypass":"%PDF-1.3 1 0 obj <<   /Pages 2 0 R   /Type /Catalog >> endobj 2 0 obj <<   /Count 1   /Kids [     3 0 R   ]   /Type /Pages >> endobj 3 0 obj <<   /Contents 4 0 R   /MediaBox [ 0 0 200 200 ]   /Parent 2 0 R   /Resources <<     /Font << /F1 5 0 R >>   >>   /Type /Page >> endobj 4 0 obj <<   /Length 50 >> stream BT   /F1 10 Tf   20 100 Td   (CSPT) Tj ET endstream endobj 5 0 obj <<   /Type /Font   /Subtype /Type1   /BaseFont /Helvetica >> endobj xref 0 6 0000000000 65535 f 0000000009 00000 n 0000000062 00000 n 0000000133 00000 n 0000000277 00000 n 0000000370 00000 n trailer <<   /Size 6   /Root 1 0 R >> startxref 447 %%EOF "}
```

While this PDF will not render in recent PDF viewers, it will be readable by `pdflib` and pass the file upload checks.

## Bypassing file Command Validation

In some environments, the `file` command or a library based on `file` is used to detect file types.

```
async function checkFileCommand(binaryFile) {
    //Write a temporary file
    const tmpobj = tmp.fileSync();
    fs.writeSync(tmpobj.fd, binaryFile);
    fs.closeSync(tmpobj.fd);

    // Exec file command
    output = execFileSync('file', ["-b", "--mime-type", tmpobj.name])

    const isValid = (output.toString() === 'application/pdf\n')
    if (!isValid) {
        throw new Error(`content - type: File is not a PDF : ${output}`);
    }
    tmpobj.removeCallback();

}
```

### Technique:

The difference with `mmmagic` is that before checking the magic bytes, it tries to parse the file as [JSON](https://github.com/file/file/blob/FILE5_46/src/funcs.c#L388C1-L397C1). If it succeed, the file is considered to be JSON and no other checks will be perform. So we canât use the same trick as mmmagic. However, the `file` command has a known limit on the size of files it can process. This is an extract of the `man file` command.

```
     -P, --parameter name=value
             Set various parameter limits.

            Name         Default    Explanation
            bytes        1048576    max number of bytes to read from file
            elf_notes    256        max ELF notes processed
            elf_phnum    2048       max ELF program sections processed
            elf_shnum    32768      max ELF sections processed
            encoding     65536      max number of bytes for encoding evaluation
            indir        50         recursion limit for indirect magic
            name         60         use count limit...