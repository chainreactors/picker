---
title: StealC Malware Analysis Part 3
url: https://blog.lexfo.fr/StealC_malware_analysis_part3.html
source: Lexfo's security blog
date: 2024-10-04
fetch_date: 2025-10-06T18:50:39.055423
---

# StealC Malware Analysis Part 3

[BLOG POSTS](/index.html) [CATEGORIES](/categories.html) [ARCHIVES](/archives.html)

[CONTACT US](https://lexfo.fr/contact/)

StealC Malware Analysis Part 3

Wed 04 September 2024 by **Lexfo** in [Malware Analysis](category/malware-analysis.html)

# 06 - Analysis of StealC (Stage 4)

In [the first article](./StealC_malware_analysis_part1.html) of the series, we saw how to unpack the first stage `pkr_ce1a` manually and using an emulator (MIASM). In [the second article](./StealC_malware_analysis_part2.html) we have extracted the C2 of the loader and unpacked the last stage using MIASM. Now let's take a look at the **StealC** malware and recover some IOCs.

## Sample information

Below is the information concerning the last stage we are going to analyze:

| Type | Data |
| --- | --- |
| SHA256 | 18f53dd06e6d9d5dfe1b60c4834a185a1cf73ba449c349b6b43c753753256f62 |
| SHA1 | a952b1ed963346d5029a9acb3987d5e3a65c47a3 |
| MD5 | 8022ef84cfe9deb72b1c66cd17cac1cd |
| File size | 153 088 bytes |
| First seen | N/A |
| MIME type | application/x-dosexec |
| imphash | 1ef0d6e4c3554a91026b47d9a27bf6db |
| ssdeep | 3072:ivyLlG8KPgpJSG61doHN4NoQiUukOoy9bzyRy2GxhGJuU:ivyhJryZoIohvkOpt+M2GzAu |

At the time of writing, the sample has not been made public on sample-sharing platforms such as VirusTotal.

## Detect the sample family

First, we can look at the entropy of the file to see if it is packaged:

![](../images/stealc_analysis/detect_it_easy_entropy_stage4_stealc.png)

Detect It Easy - Entropy of StealC sample (stage 4)

The latter is not packaged, as its entropy is not high.

We don't know which family of malware it is yet. A loader? A beacon? To find out, we can run a Yara scan. If you don't have a Yara rules database, you can find some on GitHub repositories such as [Yara-Rules](https://github.com/Yara-Rules/rules) (no longer maintained), or on specialized platforms such as [Malpedia](https://malpedia.caad.fkie.fraunhofer.de/).

If you run a scan on all Malpedia's Yara rules, you should come across a positively matching rule named `win_stealc_auto`:

```
$ yara -s win.stealc_auto.yar syncUpd_exe_miasm_unpacked.bin
win_stealc_auto syncUpd_exe_miasm_unpacked.bin
0x135df:$sequence_0: FF 15 38 4F 62 00 85 C0 75 07 C6 85 E0 FE FF FF 43
0xde4c:$sequence_1: 68 6F D7 41 00 E8 EA 82 00 00 E8 65 E7 FF FF 83 C4 74
0xc760:$sequence_2: 50 E8 3A 9A 00 00 E8 D5 F2 FF FF 83 C4 74
0xc81c:$sequence_2: 50 E8 DE 40 FF FF E8 D9 EC FF FF 83 C4 74
0xc8ca:$sequence_2: 50 E8 70 98 00 00 E8 EB FC FF FF 83 C4 74
0xaf51:$sequence_3: E8 4A B2 00 00 E8 D5 E4 FF FF 81 C4 80 00 00 00 E9 53 03 00 00
0xb03c:$sequence_3: E8 5F B1 00 00 E8 EA E3 FF FF 81 C4 80 00 00 00 E9 68 02 00 00
0xd558:$sequence_4: 50 E8 42 8C 00 00 E8 DD F3 FF FF 81 C4 84 00 00 00
0xd5d4:$sequence_4: 50 E8 C6 8B 00 00 E8 61 F3 FF FF 81 C4 84 00 00 00
0xd650:$sequence_4: 50 E8 4A 8B 00 00 E8 E5 F2 FF FF 81 C4 84 00 00 00
0x124c7:$sequence_5: E8 44 25 FF FF 83 C4 60 E8 7C E2 FF FF 83 C4 0C
0x10692:$sequence_6: E8 09 5B 00 00 E8 A4 4A FF FF 83 C4 18 6A 3C
0x149d6:$sequence_7: FF 15 88 50 62 00 50 FF 15 20 50 62 00 8B 55 08 89 02
0x149dc:$sequence_8: 50 FF 15 20 50 62 00 8B 55 08 89 02
```

It seems that the executable matches 9 out of 10 sequences, which is a very good score. We can therefore strongly assume that this is the final **StealC** malware. Malpedia has [a dedicated page about it](https://malpedia.caad.fkie.fraunhofer.de/details/win.stealc).

Our aim is to recover C2 from the malicious program, and several methods can be used:

* Sandbox
* Emulation
* Static analysis

In this article, we will use the **Static** method.

## Automate string decryption

Open the sample with your favorite disassembler. By wandering through the various functions, you should be able to identify methods calling `sub_4043b0` which seems to take 3 parameters: a sequence of bytes, a string, then an integer (which seems to correspond to the length of the string):

![](../images/stealc_analysis/binary_ninja_stage4_func_call_decode_str.png)

Binary Ninja - Function with lot of call with strings arguments

If we unpack the `sub_4043b0` function, we can see that the malware uses a military encryption algorithm (`xor`). We can rename the function and its variables:

![](../images/stealc_analysis/binary_ninja_xor_str_func.png)

Function that XOR strings

The function we just renamed `simple_crypto_xor` is used by two other functions in the program:

![](../images/stealc_analysis/binary_ninja_xref_func_xor_str.png)

Binary Ninja - XREF of simple\_crypto\_xor

We can then rename the variables according to the bytes decoded with our disassembler's API. First, we'll try to recover the address of the function that performs the XOR operations, based on the calls to the `LocalAlloc` and `strlen` functions:

```
def get_most_called_function_sorted():
    funcs = bv.functions
    call_function_counter = {}
    for func in funcs:
        callers = func.callers
        #print("\nFunction {} is called from {} known locations.".format(func.name, len(callers)))
        call_function_counter[func] = len(callers)
    return sorted(((v, k) for k, v in call_function_counter.items()), reverse=True)

def get_xor_str_func():
    most_called_functions  = get_most_called_function_sorted()
    for func in most_called_functions:
        if func[0] < 260:
            # xor func must have more than 100 callers
            break
        if not func_has_call_func_by_name(func[1], "LocalAlloc"):
            continue
        if not func_has_call_func_by_name(func[1], "strlen"):
            continue
        return func[1]
    return None

def func_has_call_func_by_name(func, func_name: str):
    for inst in func.mlil.instructions:
        if not isinstance(inst, Localcall):
            continue
        if str(inst.dest) == func_name:
            return True
    return False
```

Once we have the address of our `simple_crypto_xor` function, we can try to identify the functions that call it, retrieve the arguments sent as parameters and then decode them. Once decoded, we can then rename the destination variables to make them easier to read:

```
[...]

xored_str = None
def xorme(secret_string, key, key_len):
    final = ""
    for i in range(0, key_len):
        final = f"{final}{chr(secret_string[i] ^ key[i])}"
    return final

def visitor_xored_func(_a, inst, _c, _d) -> bool:
    global xored_str
    if isinstance(inst, Localcall):
        ptr_secret_string = int(inst.params[0].value)
        key = inst.params[1].string[0].encode()
        key_len = int(inst.params[2].value)
        secret_string = bv.read(ptr_secret_string, key_len)
        xored_str = xorme(secret_string, key, key_len)

def main():
    global xored_str
    xor_func = get_xor_str_func()
    if not xor_func:
        print("Error: StealC xor func not found")
        return
    print(f"Xor function at @{xor_func.address_ranges}")
    xor_func_callers = []
    callers = xor_func.callers
    for caller in callers:
        if caller in xor_func_callers:
            continue
        xor_func_callers.append(caller)
        for inst in caller.hlil.instructions:
            xored_str = None
            inst.visit(visitor_xored_func)
            if xored_str:
                try:
                    dst = inst.dest.get_expr(0).get_int(0)
                    var = bv.get_data_var_at(dst)
                    print(f"New string identified : {xored_str}")
                    xored_str_cleaned = xored_str.replace("/", "-").replace("%", "").replace(":", "").replace(" ", "_").replace(".", "_").replace("/", "_").replace("\\", "_").replace(",","_")
                    var.name = f"str_{xored_str_cleaned}" #Â Rename variable

                except:
                    pass
main()
```

This produces the following result:

![](../images/stealc_analysis/run_binary_ninja_script_decode_str.png)

Binary Ninja - Script that decode xored strings and rename variables

Lists of decoded strings are available [here](../ressources/stealc_analysis/...