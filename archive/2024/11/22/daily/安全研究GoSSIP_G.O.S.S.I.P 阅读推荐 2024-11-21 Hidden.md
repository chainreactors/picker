---
title: G.O.S.S.I.P 阅读推荐 2024-11-21 Hidden
url: https://mp.weixin.qq.com/s?__biz=Mzg5ODUxMzg0Ng==&mid=2247499247&idx=1&sn=3e78debf5c61eb06c8c36a5fe0429402&chksm=c063d336f7145a20b787dcdf75b497d8c80161ea9280400168a59920a78b6ec688b6d0fb9f11&scene=58&subscene=0#rd
source: 安全研究GoSSIP
date: 2024-11-22
fetch_date: 2025-10-06T19:16:41.815611
---

# G.O.S.S.I.P 阅读推荐 2024-11-21 Hidden

![cover_image](https://mmbiz.qpic.cn/sz_mmbiz_jpg/uicdfzKrO21FNYuBS5qicyZhA2FDElex1l5QP1n8VIO2yvtkK3AtQ1Gw0JJ9ibcxo3pqFYXmQRyyX46RLOEGETMpA/0?wx_fmt=jpeg)

# G.O.S.S.I.P 阅读推荐 2024-11-21 Hidden

Peihua

安全研究GoSSIP

今天为大家推荐的论文来自中科院计算所内构安全实验室投稿并发表在 TACO 2024 上的最新工作**Shining Light on the Inter-procedural Code Obfuscation: Keep Pace with Progress in Binary Diffing**。该工作从二进制比对的视角，提出了一种过程间的代码混淆技术，解决现有代码混淆技术逐渐失效的问题，提升了对抗二进制比对技术的有效性。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/uicdfzKrO21FNYuBS5qicyZhA2FDElex1lPYVGMBciaeBwBhQWK2yRn4FlGyvJ6XfI8HJVdpcTvoOkiaWNnlTdrKMA/640?wx_fmt=png&from=appmsg)

该工作观察到，现有代码混淆技术的粒度往往集中在函数内部，缺乏函数间的变换，无法从根本上改变函数的语义，而二进制比对技术可以越来越准确地提取函数内部的特征以获得其语义，从而使函数内粒度的代码混淆技术不再有效。该工作认为应该强调函数间的代码混淆技术，因为它们能够更改函数的语义。所提出的过程间代码混淆技术包含函数裂变、函数聚变以及控制流隐藏三种混淆原语。实验结果表明混淆后的程序能降低二进制比对工具的准确率至19%以下，超过80%的漏洞函数的搜索排名下降到50名以后，同时混淆带来的开销不超过7%。目前该工作已经开源。

该论文贡献如下：

* **一种过程间的混淆技术**。该工作认识到过程间混淆在对抗二进制比对技术中的重要性，并引入了一种过程间代码混淆技术，该技术可以跨函数混淆代码。
* **三个互补的混淆原语**。该工作提出了三种混淆原语来完成代码的移动和隐藏。这些原语包括裂变——将一个函数划分为多个函数；聚变——将多个函数合并在一起；隐藏——利用异常处理机制因此程序中的控制流。
* **关于代码混淆与编译器优化的新观察**。代码混淆需要对抗编译器优化，以免生成相同的二进制代码，但也不可避免地带来了较高的性能开销；而编译器本身的代码变换由于其模式固定可以实现有限的代码混淆。一种更有效的方法是以优化兼容的方式混淆代码，并利用编译器来增强混淆效果。

**背景**

**二进制代码比对技术**

二进制代码比对技术，也称做二进制代码相似性检测技术（Binary Code Similarity Detection，BCSD），是一种用于分析和比较二进制代码以识别二进制文件之间相似性的技术。它能够定量地测量二进制代码之间的差异并以预定义的粒度级别（通常在函数级别）给出匹配结果。该技术已广泛应用于软件漏洞搜索，恶意软件检测，代码克隆检测等场景中。如下图所示，二进制比对的过程通常从二进制代码的反汇编开始，该过程将二进制代码转换为汇编代码，从而在一定程度上恢复程序的语义信息。反汇编之后，二进制比对技术的工作流程可分为两个阶段：**离线特征提取和在线代码搜索**。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/uicdfzKrO21FNYuBS5qicyZhA2FDElex1l4BAM7cgahdWETS6PyPuDZibFrEs7QJqiaeq3RGAgjogTicPFewiaY7pXPQ/640?wx_fmt=png&from=appmsg)

在离线阶段，二进制比对技术从汇编代码中提取特征。最近的研究重点是确定应该提取哪些特征来实现有效的代码比对。根据二进制比对工作的方法，它们可以分为两类：传统方法和基于学习的方法。

* 传统方法从二进制代码中提取统计信息，例如指令操作码的分布情况，控制流图以及每个节点的入度出度信息等。例如，一些工作提取了字符串常量、数字常量和不同种类指令的数量作为基本块和函数的标识。此外，很多工作也尝试过提取语义级特征作为二进制代码的标识，比如使用通过识别基本块的输入输出来描述一个基本块的功能。
* 最近，许多工作尝试采用机器学习技术来进行二进制比对。例如将汇编语言视为一种特殊的自然语言，然后使用自然语言处理技术对其进行分析，将程序中的每个元素（操作码、操作数）抽象为自然语言中的词素，并通过训练和聚类生成每个词素的向量化表示。

传统方法和基于学习的方法都有其优点和局限性。一方面，传统方法的比对效率较高，但常常难以应对复杂的代码变换。另一方面，基于学习的方法可以适应不同的代码表示，并对代码转换表现出更好的鲁棒性。然而它们需要大量标记数据进行训练，并且计算量可能很大。

在线阶段，二进制比对技术会计算提取的特征之间的相似度从而识别能够配对的二进制代码。这个过程可以看作是一个搜索过程，其中搜索空间的规模受到定义特征的粒度的影响。例如，如果粒度设置在函数级别，则搜索空间将由二进制文件中函数的数量决定，每个函数会得出一个该工具认为的最为相似配对的函数，或一个按照相似性排名的函数候选列表，以供逆向分析人员进行后续分析。而如果粒度设置在基本块级别，则考虑到代码中基本块的数量较多，搜索空间将进一步扩大。

此外，特征的具体表示会影响用于相似性计算的方法。例如在处理与向量相关的特征时，通常采用欧氏距离或余弦相似度等距离度量方法，从而量化了特征向量之间的差异或相似性。当使用与图相关的特征时，就需要图匹配算法来衡量图的相似度，即找到提取特征的节点或子图之间的对应关系，从而进一步判断代码结构和语义的相似性。

**代码混淆**

代码混淆技术（Code Obfuscation）旨在不改变程序功能的前提下，对软件的代码进行变换，复杂化软件代码，使得代码更加难以理解。变换后，函数的控制流发生较大变化，可用于隐藏程序的功能逻辑，因此也适用于漏洞的隐藏。由于该技术能够灵活地改变二进制代码，因此是对抗二进制比对的可用选择。实际上，代码混淆和二进制比对之间存在着一场军备竞赛。代码混淆不希望二进制比对技术成功地将未混淆的代码与混淆后的代码配对，反之亦然。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/uicdfzKrO21FNYuBS5qicyZhA2FDElex1lVGwgpg0sFtOpzGnyL3ccru0Cpkk45S2gLo3AT2pwaicm1PBY14Q7OkA/640?wx_fmt=png&from=appmsg)

近几十年来，国内外研究人员在混淆技术方面提出了多种方法，上表总结了过去二十年来的代码混淆相关工作，并按照混淆粒度对这些工作进行分类：

* **指令级**：指令替换（Instruction Substitution，SUB）将原始指令替换为等效指令，例如将一条add指令替换为两条sub指令。O-LLVM为算术和逻辑运算设计了10种不同的替换策略。此外，花指令（Garbage Substitution，GS）技术利用复杂指令集（Complex Instruction Set Computer，CISC）指令不定长的特点，在代码中插入垃圾字节来对抗反汇编。混合布尔算数（Mixed Boolean-Arithmetic，MBA）将代码中的算术指令复杂化，通常用来对抗符号执行等技术。
* **基本块级**：为了增加条件分支指令的复杂性，许多工作提出了多种不透明谓词技术（Opaque Predicate，OPA）。这些不透明谓词不影响原始控制流的永真或永假条件（例如，x^2 != -1），也经常用于对抗符号执行等分析技术。冗余控制流（Bogus Control Flow， BCF）将任意代码插入到原始控制流中，并经常利用不透明谓词来防止这些代码被优化和执行，从而确保程序的原始功能。
* **函数级**：控制流扁平化（Control Flow Flattening， FLA）将函数的控制流转化为较为复杂的switch-case形式，并通过控制case的值来保持原有的跳转关系。为了防止被降级回原始控制流， case的关系也被混淆（加密）。输入不变量（Input Invariant，INP）通过分析函数的输入来变换函数中的分支，例如将字符串相等判断语句转化为一系列连续的字符相等判断语句，范围分割（Range Divider）首先分析函数中的判断语句，并将其拆分为多个子范围，随后在不同的子范围对应的代码块中使用不同的代码遍体，这些变体与原代码功能一致。Tigress将函数的形参重新排序，并插入一些冗余参数，但这种方法不会改变函数内部的控制流，只会影响到指令中使用的寄存器编号。一些工作利用面向返回的编程（Return-Oriented Programming，ROP）技术将程序中的代码逻辑转化为离散的代码片段（gadget），但由于这种方法会打破栈的布局，因此与一些运行时的代码加固技术（如影子栈等）不兼容。

**动机**

对于用户态应用软件来说，代码复用是引入安全风险的重要来源。代码复用使得攻击者无需费力挖掘其中的零日漏洞，而仅通过检测攻击目标中已存在漏洞即可。在这种情况下，二进制代码比对技术为攻击者提供了便利。在不需要源代码的情况下，攻击者可以利用该技术，通过将目标应用的二进制文件与已知漏洞的二进制代码进行比较来定位目标应用中存在的已知漏洞，进而发起攻击。近年来，基于学习的二进制比对技术近年来取得了长足的进步，可以在不到1秒的时间内完成万级的代码比对，这极大地方便了攻击者定位二进制文件中现有的漏洞。在这种场景下，通过对抗二进制比对技术来保护软件安全就显得尤为重要。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/uicdfzKrO21FNYuBS5qicyZhA2FDElex1lhaTfCWrCOhBc1aqWaNvxoW9cZNhOO9JVNuZiaH4DUKFtiaI598cmHZvA/640?wx_fmt=png&from=appmsg)

上表对过去十年在顶级刊物上发表的二进制比对工作进行了全面分析，并依据其对比方法、对比粒度以及对不同代码变换的适应能力进行了总结。早期的二进制比对工作往往以传统方法为主，自2018年以来，随着机器学习在不同研究方向的大规模应用，大多数工作都开始采纳了基于学习的二进制比对方法。

由于代码变换是造成二进制代码差异的常见来源，因此测试对代码变换的适应性成为了二进制比对工作的常见评估步骤。如表中的代码变换适应性所示，许多二进制比对工作都考虑了使用不同的主流编译器来生成二进制文件，其中大多数集中在GCC和Clang上。在特定的编译器下，大多数工作只考虑了O0到O3等默认优化选项，而只有一个工作探索了非默认优化选项的影响。

部分二进制比对工作也考虑了代码混淆技术带来的影响，并且从不同的粒度（例如，在语句、基本块或函数级别）评估了对代码混淆技术的适应程度。从它们的实验中可以看到，现有基于静态代码重写的混淆技术已经失效。究其原因，该工作认为这些混淆技术主要集中在函数内。为了保证功能正确性，**函数内的代码混淆不能改变每个函数的功能，因此无法从根本上改变每个函数的语义**。随着二进制比对技术越来越能够提取函数内的特征并理解其语义，现有的代码混淆技术难以取得令人满意的效果。

通过对现有二进制比对技术和代码混淆技术的观察与总结，该工作强调函数间代码混淆对二进制比对技术的影响，并通过性能与混淆效果两个视角来论述其有效性：

**视角1——性能**：在对近年来的代码混淆技术进行总结的过程中，该工作发现代码混淆与编译器优化存在对抗或破坏的关系。一般来说，编译器优化方向为提升程序的运行性能，同时缩小二进制文件的大小，而代码混淆往往为了增加程序的复杂度而降低了程序的性能，并增加了二进制文件的大小。通过对近年来的代码混淆技术的总结，该工作发现现有的代码混淆技术的作用粒度大多是函数或小于函数。而编译器中的优化技术也大都为函数内优化，因此这些以函数为粒度的混淆技术为了保持混淆效果不被优化，需要对抗若干编译优化技术，从而降低了程序的性能。因此，为了降低代码混淆带来的额外开销，使用的代码混淆应尽可能顺从编译优化，而大部分编译优化均为函数内优化，因此为了不对抗/破坏这些优化，该工作利用函数间的代码混淆来进行代码混淆。

**视角2——混淆效果**：经由以函数为粒度的代码混淆技术处理后，函数的功能一般不发生改变。而随着二进制代码比对技术在程序的抽象表示能力方面的不断提高，尤其是深度学习在代码比对技术中的应用，使得该技术捕获函数功能的能力越来越强，函数内代码混淆的效果逐渐减弱。而在函数间的代码混淆的帮助下，函数的界限被打破，函数的功能被改变，从而提升代码混淆在对抗二进制比对技术方面的效果。一方面，对于仅考虑函数内信息信息的二进制比对工作来说，函数间代码混淆可以从根本上击败它们，因为函数的代码结构和语义都发生了明显变化；另一方面，对于考虑函数间信息的二进制比对工作来说，由于它们提取的函数间信息（如函数调用调用图、调用类型、调用次数等）在混淆后也发生了显著变化，因此函数间代码混淆也可以有效对抗它们。

从攻防双方发表的文献中也进一步验证了该工作的想法：1）函数内联优化作为函数间变换的一种典型的优化技术，大多数二进制比对工作都讨论了该变换带来的问题，其中许多工作承认它会影响代码比对的准确性；2）一些工作发现通过强制开启编译器中的函数内联优化可以将二进制相似度降低约10%。

因此，该工作认为应该强调函数间的代码混淆技术，因为它们能够在二进制级别更改函数语义。基于上述观察，本文提出了一种函数间混淆技术，它可以跨函数移动代码，并利用编译器的优化来进一步转换（混淆）代码。其核心思想是**一旦代码在函数之间进行重组，编译优化后生成的二进制代码会有很大不同**。

**设计**

为了实现函数间代码混淆，该工作提出三种混淆原语：裂变，聚变，以及隐藏。

* 裂变原语以支配树为粒度将函数中的代码区域划分为单独的子函数，同时结合冷热代码分析技术来降低裂变带来的性能开销。此外，由于变量的定义-使用关系从函数内变为函数间，因此还需要通过传递参数来重建数据流。为了最大限度地减少参数传递引起的性能下降，裂变原语提出了一种数据流缩减机制来减少子函数的参数数量。最后，裂变原语通过插入调用子函数的函数调用语句并对子函数中的返回值进行编码来重建控制流。
* 聚变原语聚合具有兼容返回值的函数并合并它们的参数列表，其中兼容类型意味着在不同数据类型之间的转换不会损失精度。为了避免低效的栈传参方式，聚变原语提出了一种参数压缩机制来减少参数的数量。同时，为了完全重建控制流，聚变原语提出了一种标签化指针机制，通过将控制位附加在函数指针的高位上，来决定间接调用点时聚合函数内部执行的代码。此外，聚变原语还提出了一种跳板机制来处理跨模块的函数调用。最后，为了进一步提高混淆效果，聚变原语提出了深度聚变方法，在聚合后的函数内部对来自不同函数的无害化基本块（其执行不影响全局内存状态）进行合并。聚变之后程序的调用图发生明显变化，深度聚变导致基本块的特征被打破，并且产生了新的执行路径。
* 隐藏原语利用异常处理（Exception Handling）机制来隐藏程序中的控制流。异常处理机制是C++的一个关键特性，开发人员可以通过编写catch语句来捕获try块中主动抛出或被动产生的异常。该机制需要应用程序二进制接口（Application Binary Interface，ABI）和异常处理运行时库的配合，它们通过搜索二进制文件中记录的异常处理信息来选择要执行的适当的catch代码。隐藏原语通过将程序中的直接跳转变换为throw-catch关系，即将直接控制流变为基于查找的间接控制流，从而隐藏程序的控制流关系。为了进一步隐藏间接控制流，隐藏原语还提出了一个代码分发机制，负责在编译时将隐藏代码随机发送到其他函数。最后，隐藏原语还为C程序设计了相应的补充方法。隐藏之后程序的代码引用关系被破坏，一方面使得代码比对工具无法分析调用语句与被调用函数的关系，从而无法进行内联等操作，代码分发机制进一步破坏了可能的相似代码。

下图给出了一个关于在名为cal\_file()的函数上进行函数间代码混淆的示例。该函数的功能为查找给定文件中内容的签名。它首先检查文件名是否为空（第4行），若非空则调用log()函数来记录文件名（第5行），随后打开文件（第6行）。若打开失败则返回-1（第7行），否则循环读取文件内容并调用cal()函数计算（第9-10行），计算完成后关闭文件（第11行）并返回计算结果（第12行）。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/uicdfzKrO21FNYuBS5qicyZhA2FDElex1l7jcwf5I6o0deAv2KIic58k07ja7LDDef6KxMDHg57ZC1W3qziaosfD5w/640?wx_fmt=png&from=appmsg)

上图右侧给出了混淆前后的控制流，可以看到裂变原语分别将两个基本块（2-3）分裂为名为sepFunc-1()的函数，将四个基本块（5-8）分离为sepFunc-2函数。为了保证正确性，裂变原语在remFunc-1()函数中插入三个跳板基本块（abc），以创建与两个sepFunc函数的调用关系。

在裂变结束后，聚变原语将log()函数和sepFunc-2()函数聚合成fusFunc-1()函数，并在fusFunc-1()函数中插入一个入口基本块（e）来选择每次执行的代码块。为了实现更深层次的代码聚合，该工作提出了深度聚变的方法来结合来自不同函数体的基本块。在生成fusFunc-1()函数后，聚变原语会将所有对log()函数和sepFunc-2()函数的引用调整为对fusFunc-1()函数的引用。

隐藏原语是为了解决使用上述原语后仍可能存在的“顽固的”控制流，其重点是将直接控制流转换为间接控制流。例如，隐藏原语首先将sepFunc-1()函数中的基本块2末尾的分支语句替换为用throw语句，随后在后续基本块（d和3）中添加catch语句。这样通过利用异常和相关的catch语句实现了间接控制流驱动的hidFunc-1()函数，同时保留了代码的预期功能。此外，隐藏原语也为C语言和函数调用语句扩展了等效隐藏方法。最后，为了进一步打破hidFunc-1()函数与其他函数的边界，隐藏原语将被隐藏的代码（d和3）分发到了不同的函数中。此步骤确保同一个函数的控制流分布在多个函数中，从而提升整体的混淆效果并使分析程序结构更具挑战性。详细的设计与挑战请参阅论文。

**实验**

**性能实验**

![](https://mmbiz.qpic.cn/sz_mmbiz_png/uicdfzKrO21FNYuBS5qicyZhA2FDEl...