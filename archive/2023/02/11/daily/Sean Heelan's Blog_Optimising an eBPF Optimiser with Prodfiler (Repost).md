---
title: Optimising an eBPF Optimiser with Prodfiler (Repost)
url: https://sean.heelan.io/2023/02/10/optimising-an-ebpf-optimiser-with-prodfiler-repost/
source: Sean Heelan's Blog
date: 2023-02-11
fetch_date: 2025-10-04T06:20:26.629811
---

# Optimising an eBPF Optimiser with Prodfiler (Repost)

[Skip to content](#content)

Open Menu

* [Home](https://sean.heelan.io/)
* [All Posts](https://sean.heelan.io/posts/)
* [Research & Publications](https://sean.heelan.io/research/)
* [About Me](https://sean.heelan.io/about-me/)

*Search*

Search for:

 Close

[![](https://sean.heelan.io/wp-content/uploads/2023/02/logo_ireland-1.jpg)](https://sean.heelan.io/)

# [Sean Heelan's Blog](https://sean.heelan.io/)

## Software Exploitation and Optimisation

[Performance Optimisation](https://sean.heelan.io/category/performance-optimisation/) / [Profiling](https://sean.heelan.io/category/profiling/)

# Optimising an eBPF Optimiser with Prodfiler (Repost)

[February 10, 2023February 10, 2023](https://sean.heelan.io/2023/02/10/optimising-an-ebpf-optimiser-with-prodfiler-repost/) [seanhn](https://sean.heelan.io/author/seanhn/)

How do you almost 2x your application’s performance with zero code changes? Read on to find out!

*This is a repost of a blog I [originally wrote](https://prodfiler.com/blog/optimising-an-ebpf-optimiser/) on prodfiler.com on October 4th 2021. Prodfiler was acquired by Elastic is is now the Elastic Universal Profiler.*

In this post I will walk through how we can use Prodfiler to unearth areas for optimisation in K2 ([paper](https://k2.cs.rutgers.edu/), [video](https://youtu.be/igJLKyP1lFk?t=3726)), an optimising compiler for eBPF. K2 is entirely CPU bound and uses a guided search technique that relies on the ability to create and check candidate solutions at high speed. With Prodfiler we can easily discover which components of K2 consume the most CPU cycles, allowing us to optimise them accordingly. The end result is a version of K2 that is 1.4x-1.9x faster, meaning it can explore a significantly larger search space given the same resources.

To foreshadow where we are going, the improvements discovered come from:

1. Replacing the system allocator with better performing alternative, namely `mimalloc`.
2. Assisting the compiler in auto-vectorising a series of hot loops.
3. Applying PGO and LTO to K2 itself and to Z3, its most significant dependency.

## Introduction

As more use-cases are discovered for eBPF, with many of them on critical paths, the performance of the eBPF code generated by compilers is increasingly important. While clang usually does a good job of producing efficient programs, it sometimes generates code that suffers from redundancies, unusual choice of instruction sequences, unnecessarily narrow operand widths, and other quirks that mean a hand-optimised program can be significantly faster. Hand-optimisation of eBPF instructions is challenging, time consuming and error prone and so, as with compilation for more traditional target platforms, there is a market for tools that spend time upfront in compilation in order to gain performance at runtime.

In August of this year, researchers at Rutgers released [K2](https://k2.cs.rutgers.edu/), an optimising compiler for eBPF code. K2 takes as input an existing eBPF program and searches for a faster and smaller program that is semantically equivalent to the original. In their paper they demonstrate that their approach can be used to reduce program size by 6-26%, lower the average packet-processing latency of those programs by 1-55%, and increase throughput by up to 5%, relative to the best clang-compiled programs.

To drive its search K2 uses [MCMC](https://en.wikipedia.org/wiki/Markov_chain_Monte_Carlo) with the [Metropolis-Hastings](https://en.wikipedia.org/wiki/Metropolis%E2%80%93Hastings_algorithm#Step-by-step_instructions) acceptance criteria [1]. A good introduction to MCMC/MH can be found [here](https://twiecki.io/blog/2015/11/10/mcmc-sampling/), but for our purposes it’s sufficient to just think of MCMC as a search technique that, in its inner loop, must generate a new candidate from the current state and assign a cost to it. The next current state is then decided upon randomly using the costs of the current state and the candidate state to bias selection. Given a fixed time budget (and assuming sane candidate generation and a reasonable cost function) the quality of the result is directly linked to the number of states that can be explored in that time period. MCMC-based applications are thus prime targets for tools like Prodfiler, as any performance gains that we can eke out are likely to enable the application to find higher quality results using the same resources.

### A Brief Overview of K2’s Architecture

[![](https://sean.heelan.io/wp-content/uploads/2023/02/k2-architecture.png?w=629)](https://sean.heelan.io/wp-content/uploads/2023/02/k2-architecture.png)

For some context on what exactly we will be optimising, lets quickly run through the components of K2. The above diagram is from the K2 [paper](https://people.cs.rutgers.edu/~sn624/papers/k2-sigcomm21.pdf), which is very readable and highly recommended if you’d like more detail.

As mentioned above, being MCMC-driven, the core of K2 is:

1. Generate a new candidate from the current state.
2. Assign that candidate a cost.
3. Set the current state to new candidate state, conditionally on the candidate’s cost and the current state’s cost.

Algorithmically, almost all of the heavy lifting goes on in step 2. To calculate the cost of a candidate, K2 interprets it using a custom userspace eBPF interpreter on a set of inputs. For these inputs, if the candidate produces the same outputs as the original program, K2 then converts the candidate to a symbolic representation and uses the Z3 theorem prover to perform an equivalence check. The inner loop of the MCMC search is therefore computationally quite intensive, with each candidate requiring a significant amount of work to evaluate.

## Setting Up

### Setting up Benchmarks

K2 itself can be found on [GitHub](https://github.com/smartnic/superopt.git), and conveniently the authors have also uploaded a conference artifact containing tests and benchmarks that were used to generate the results in their paper. I have cloned this repository [here](https://github.com/SeanHeelan/sigcomm21_artifact) in order to add some helper scripts for use in this post. The primary K2 repository is a bit scant on information on how to actually install and run it, but fortunately there is an installation script [here](https://github.com/SeanHeelan/sigcomm21_artifact/blob/master/install.sh), which one can follow as required. An example of how to run K2 to optimise an eBPF program can be found in [this](https://github.com/SeanHeelan/sigcomm21_artifact/blob/master/4_reproduce_results/1_insn_count/insn_count.sh) script. That script will invoke K2 on 11 different eBPF programs to try and find more efficient implementations. We will use it as the basis for our benchmarks as the input eBPF programs are diverse, and we can be relatively certain that if we find optimisations that make K2 run faster across these input targets, then they *should* generalise.

One final point on setting up the benchmarks is that I have cloned K2 [here](https://github.com/SeanHeelan/superopt) in order to provide a default [Makefile](https://github.com/SeanHeelan/superopt/commit/67984c49ca9305f8045bb0c74e21b0bc5d477607) that will build a reasonable binary for us to compare our improvements against. The standard Makefile that comes with K2 appears to have an error, and does not specify an optimisation level when compiling most files that make up the program, and thus by default you get no optimisation and quite poor performance. My Makefile specifies *-O3 -march=native* as a default.

### Benchmarking and Optimising with Prodfiler

Getting started with Prodfiler is straightforward. Follow the docs [here](https://documentation.prodfiler.com/getting-started.html) to create a new project and deploy Prodfiler in a few clicks. Once it is up and running we can then gather our baseline data by running the benchmarks mentioned above. The script I have created to do so can be found [here](https://github.com/SeanHeelan/sigcomm21_arti...