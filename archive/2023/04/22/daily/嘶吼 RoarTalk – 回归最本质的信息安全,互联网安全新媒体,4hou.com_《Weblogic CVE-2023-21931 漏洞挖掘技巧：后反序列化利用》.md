---
title: 《Weblogic CVE-2023-21931 漏洞挖掘技巧：后反序列化利用》
url: https://www.4hou.com/posts/6x67
source: 嘶吼 RoarTalk – 回归最本质的信息安全,互联网安全新媒体,4hou.com
date: 2023-04-22
fetch_date: 2025-10-04T11:32:05.476554
---

# 《Weblogic CVE-2023-21931 漏洞挖掘技巧：后反序列化利用》

《Weblogic CVE-2023-21931 漏洞挖掘技巧：后反序列化利用》 - 嘶吼 RoarTalk – 网络安全行业综合服务平台,4hou.com

[![](https://www.4hou.com/sihou/images/new4hou/newlogoss.png)](https://www.4hou.com)

* [首页](https://www.4hou.com)
* [企业中心](https://www.4hou.com/corp/newindex)
* [产业研究院](https://www.4hou.com/real-time)

![](https://www.4hou.com/sihou/images/new4hou/search-icon.png)

[投稿](https://www.4hou.com/contribute)

[登录](https://www.4hou.com/login)
  |
[注册](https://www.4hou.com/register)

* 导读 ▾
* [活动](https://www.4hou.com/newticket)
* [专题](https://www.4hou.com/category/special)
* [图谱](https://www.4hou.com/atlas/index)
* [报告](https://www.4hou.com/new-report-info)
* [嘶票](https://www.4hou.com/tickets)
* [嘶货](https://www.4hou.com/shop)
* [企业查询](https://www.4hou.com/corp/new-search-company)
* [招聘](https://www.4hou.com/recruit)![](https://www.4hou.com/sihou/images/1561626446625934.png)

* [新闻](https://www.4hou.com/category/news)
* [行业](https://www.4hou.com/category/industry)
* [趋势](https://www.4hou.com/category/observation)
* [访谈](https://www.4hou.com/category/people)
* [漏洞](https://www.4hou.com/category/vulnerable)
* [WEB安全](https://www.4hou.com/category/web)
* [业务安全](https://www.4hou.com/category/business)
* [系统安全](https://www.4hou.com/category/system)
* [内网渗透](https://www.4hou.com/category/penetration)
* [勒索软件](https://www.4hou.com/category/typ)
* [安全工具](https://www.4hou.com/category/tools)

# 《Weblogic CVE-2023-21931 漏洞挖掘技巧：后反序列化利用》

Goby
[行业](https://www.4hou.com/category/industry)
2023-04-21 11:42:39

![](https://img.4hou.com/article/%E6%B5%8F%E8%A7%88.png)144336

收藏

导语：我们发现了两个 Weblogic 的后反序列化漏洞（CVE-2023-21931、CVE-2023-21839），获得了 Oracle 的官方确认。本文以这两个 Weblogic 漏洞为例，分享"后反序列化漏洞"的利用思路。

##

**0×01 概述**

近些年，Weblogic 反序列化漏洞一直围绕着反序列化的触发点进行漏洞挖掘，事实上还有很多存在反序列化但无法实时利用的点，在大家平时的漏洞挖掘中容易忽略。在行业内也有一些关于”后反序列化“的进一步讨论，这些看似无法利用的漏洞，其实可以通过一些后续的技巧完成稳定的利用效果。例如，进行 bind() 或 rebind() 操作后，并没有触发漏洞，此时可以尝试其他方法如 lookup()、lookupLink() 等触发漏洞。

通过这种思路我们发现了两个 Weblogic 的后反序列化漏洞（CVE-2023-21931、CVE-2023-21839），获得了 Oracle 的官方确认。本文以这两个 Weblogic 漏洞为例，分享"后反序列化漏洞"的利用思路。我们相信还有很多这类的漏洞在未来会逐渐被挖掘出来，希望本篇文章能够给大家一些启发。

##

**0×02 后反序列化漏洞**

![1.png](https://img.4hou.com/uploads/ueditor/php/upload/image/20230419/1681838702566520.png "1681838702566520.png")

Weblogic 反序列化漏洞挖掘思路是利用 readObject()、readResolve()、readExternal() 等反序列化方法对恶意序列化数据进行操作，以达到攻击目的。常规的漏洞思路重点关注 Weblogic 在反序列化过程中进行恶意攻击，而忽略了反序列化完成后的操作。后反序列化漏洞挖掘的思路重点关注 Weblogic 完成反序列化过程后，在达到某个时机或执行操作后触发的漏洞攻击。

在 Weblogic 中，如果进行 bind() 或 rebind() 操作后，并没有触发漏洞，此时可以尝试其他方法如 lookup()、lookupLink() 等触发漏洞。

本文将以 lookup() 方法作为漏洞触发点，对 Weblogic 后反序列化漏洞的攻击过程进行分析和漏洞实例展示。

##

**0×03  lookup**

通过跟踪调用堆栈，我们发现 lookup() 的流程如下：

* Weblogic 在接收到请求后，通过 BasicServerRef 类中的 invoke() 方法解析传入数据。
* 通过 \_invoke() 方法，Weblogic 根据传入的方法名 resolve\_any 执行的 resolve\_any() 方法。
* 在 resolve\_any() 方法中，通过 resolveObject() 方法对传入的绑定命名进行解析。
* 在 resolveObject() 方法中，根据上下文信息调用其中的 lookup() 方法。
* 根据上下文中的信息，经过在 WLContextImpl、WLEventContextImpl、 WLEventContextImpl、RootNamingNode、ServerNamingNode 、BasicNamingNode 类中一系列的 lookup() 方法调用，实现 BasicNamingNode 类中的 resolveObject() 方法调用。
* 由于传入 resolveObject() 方法中的 obj 不是 NamingNode 类的实例，且 mode 的值默认为 1，所以会调用 WLNamingManager 类中的 getObjectInstance() 方法。

![2.png](https://img.4hou.com/uploads/ueditor/php/upload/image/20230419/1681838745259935.png "1681838745259935.png")

最终，可以看到 WLNamingManager 类的 getObjectInstance() 方法根据传入的对象接口类型，调用对象中的 getReferent() 方法，完成漏洞触发点的 lookup() 方法调用。实际上这两个 CVE 漏洞都是通过 getObjectInstance() 的两个分支触发的。

##

**0×04  CVE-2023-21931**

CVE-2023-21931 的漏洞触发点在 WLNamingManager 类的 getObjectInstance() 方法中，当传入的 boundObject 对象是 LinkRef 的实现类时，则调用传入对象 boundObject 的 getLinkName()方法，并通过 lookup() 方法对 getLinkName() 方法返回的 linkAddrType 地址进行远程 JNDI 加载。在实例化 LinkRef 类时，可以通过类中的构造方法给 linkAddrType 传入一个 JNDI 地址。这样，我们就可以调用 lookup() 方法对自定义的 JNDI 地址进行远程加载，达到攻击的目的。

```
package weblogic.jndi.internal;public final class WLNamingManager {
    public static Object getObjectInstance(Object boundObject, Name name, Context ctx, Hashtable env) throws NamingException {
        if (boundObject instanceof ClassTypeOpaqueReference) {
            ......
        } else if (boundObject instanceof LinkRef) {
            String linkName = ((LinkRef)boundObject).getLinkName();
            InitialContext ic = null;
            try {
                ic = new InitialContext(env);
                boundObject = ic.lookup(linkName);  // 漏洞触发点
            } catch (NamingException var15) {
              ......
            } finally {......}
        }
    }}
```

漏洞 JNDI 地址构造在 LinkRef 这个类中，LinkRef 是 Java 的一个原生类。通过 LinkRef 类中的构造方法，我们可以控制变量 linkAddrType 的值， 再通过 getLinkName() 方法将 linkAddrType作为字符串返回。

```
package javax.naming;public class LinkRef extends Reference {
    static final String linkClassName = LinkRef.class.getName();
    static final String linkAddrType = "LinkAddress";

    public LinkRef(Name linkName) {
        super(linkClassName, new StringRefAddr(linkAddrType, linkName.toString()));
    }

    public LinkRef(String linkName) {
        super(linkClassName, new StringRefAddr(linkAddrType, linkName));
    }

    public String getLinkName() throws NamingException {
        if (className != null && className.equals(linkClassName)) {
            RefAddr addr = get(linkAddrType);
            if (addr != null && addr instanceof StringRefAddr) {
                return (String)((StringRefAddr)addr).getContent();
            }
        }
        throw new MalformedLinkException();
    }}
```

![3.png](https://img.4hou.com/uploads/ueditor/php/upload/image/20230419/1681838788170455.png "1681838788170455.png")

在上述过程中，rebind() 和 lookup() 方法的反序列化过程并未执行恶意操作，而是在完成反序列化之后，通过调用类 WLNamingManager 中 getObjectInstance() 方法的 lookup() 才触发漏洞，进行远程恶意加载 JNDI 地址操作的。

我们在 Goby 中已经集成了 CVE-2023-21931 漏洞，并加入了回显和反弹 shell 的功能。演示效果如下：

![4.gif](https://img.4hou.com/uploads/ueditor/php/upload/image/20230419/1681838816197995.gif "1681838816197995.gif")

##

**0×05  CVE-2023-21839**

ForeignOpaqueReference 是 OpaqueReference 接口的实现类。在 ForeignOpaqueReference 类中声明了两个私有变量：jndiEnvironment 和 remoteJNDIName，同时声明了两个构造方法，在有参构造方法中接收 env 和 remoteJNDIName，并分别赋值给了上面的两个私有类变量。

ForeignOpaqueReference 类的 getReferent() 方法是 OpaqueReference 接口的实现方法，在 getReferent() 方法中，retVal = context.lookup(this.remoteJNDIName); 对本类 remoteJNDIName变量中的 JNDI 地址进行远程加载，导致了反序列化漏洞。

```
package weblogic.jndi.internal;public class ForeignOpaqueReference implements OpaqueReference, Serializable {
    private Hashtable jndiEnvironment;
    private String remoteJNDIName;
        ......
    public ForeignOpaqueReference(String remoteJNDIName, Hashtable env) {
        this.remoteJNDIName = remoteJNDIName;
        this.jndiEnvironment = env;
    }
    public Object getReferent(Name name, Context ctx) throws NamingException {
        InitialContext context;
        if (this.jndiEnvironment == null) {
            context = new InitialContext();
        } else {
            Hashtable properties = this.decrypt();
            context = new InitialContext(properties);
        }
        Object retVal;
        try {
            retVal = context.lookup(this.remoteJNDIName);   // 漏洞点
        } finally {
            context.close();
        }
        return retVal;
    }
    ......}
```

getReferent() 调用分析

```
package weblogic.jndi;public interface OpaqueReference {
    Object getReferent(Name var1, Context var2) throws NamingException;
    String toString();}
```

OpaqueReference 接口有两个抽象方法：getReferent() 和 toString();

ForeignOpaqueReference 类的 getReferent() 方法调用在 WLNamingManager 类中。

在 WLNamingManager 类的 getObjectInstance() 方法中，当传入的 boundObject 对象实现了 OpaqueReference 接口时，则会调用该对象的 getReferent() 方法，即 boundObject = ((OpaqueReference)boundObject).getReferent(name, ctx);。

正如上方提到的 ForeignOpaqueReference 类实现了 OpaqueReference 接口，因此会调用该类中的 getReferent() 方法，导致反序列化代码执行漏洞。

```
package weblogic.jndi.internal;public final class WLNamingManager {
  public static Object getObjectInstance(Object boundObject, Name name, Context ctx, Hashtable env) throws NamingException {
        if (boundObject instanceof ClassTypeOpaqueReference)...