---
title: XORtigate: Pre-authentication Remote Code Execution on Fortigate VPN (CVE-2023-27997)
url: https://buaq.net/go-168596.html
source: unSafe.sh - 不安全
date: 2023-06-14
fetch_date: 2025-10-04T11:44:45.725891
---

# XORtigate: Pre-authentication Remote Code Execution on Fortigate VPN (CVE-2023-27997)

* [unSafe.sh - 不安全](https://unsafe.sh)
* [我的收藏](/user/collects)
* [今日热榜](/?hot=true)
* [公众号文章](/?gzh=true)
* [导航](/nav/index)
* [Github CVE](/cve)
* [Github Tools](/tools)
* [编码/解码](/encode)
* [文件传输](/share/index)
* [Twitter Bot](https://twitter.com/buaqbot)
* [Telegram Bot](https://t.me/aqinfo)
* [Search](/search/search)

[Rss](/rss.xml)

[ ]
黑夜模式

![](https://8aqnet.cdn.bcebos.com/e2c5b56d063e0ca660cd8037978019ed.jpg)

XORtigate: Pre-authentication Remote Code Execution on Fortigate VPN (CVE-2023-27997)

During a redteam assessment for one of our client, we had the opportunity to look into Fortigate SSL
*2023-6-13 22:0:0
Author: [blog.lexfo.fr(查看原文)](/jump-168596.htm)
阅读量:157
收藏*

---

During a redteam assessment for one of our client, we had the opportunity to look into Fortigate SSL VPN, one of the most used VPN solution worldwide. We discovered a heap overflow bug on the internet-facing interface of the VPN. This vulnerability, which is reachable without authentication, can be leveraged to get remote code execution on Fortigate instances. [CVE-2023-27997](https://www.fortinet.com/blog/psirt-blogs/analysis-of-cve-2023-27997-and-clarifications-on-volt-typhoon-campaign) was assigned, with a CVSS of 9.2 (but really, it's a 10). We believe the bug has been present for a long, long time (more than on the 7.x and 6.x branches). Please [refer to FG-IR-23-097](https://www.fortiguard.com/psirt/FG-IR-23-097) for details about affected versions.

We'll describe here the bug and the exploitation process on two architectures, along with a few pointers for blue teamers.

The bug is located on the web interface that allows users to authenticate to the VPN. This interface is, by design, internet-facing. If we hit the path `/remote/hostcheck_validate`, we can send an HTTP parameter named `enc`, through GET or POST. The parameter, which does not seem to be much used now, seems to be an old way for Fortigate to forward HTTP parameters across requests.

The `enc` parameter is a structure containing a seed, size (2 bytes) and data. Both size and data are encrypted.

![](https://blog.lexfo.fr/images/xortigate-cve-2023-27997/xortigate-enc-1.png)

The seed, stored as 8 hexadecimal characters, is used to compute the first state of a XOR keystream:

S0=MD5(salt∣seed∣‘‘GCC is the GNU Compiler Collection.′′)S\_0 = MD5(salt | seed | ``\text{GCC is the GNU Compiler Collection.}'')

*`salt` is a random value created by the server, which can be retrieved by issuing a GET request to `/remote/info`.*

The other states of the keystream are computed like so:

S1=MD5(S0)S2=MD5(S1)Sn+1=MD5(Sn)S=S1∣S2∣S3∣...∣Sn\begin{matrix} S\_1 = MD5(S\_0)\\ S\_2 = MD5(S\_1)\\ S\_{n+1} = MD5(S\_n)\\ \\ S = S\_1 | S\_2 | S\_3 | ... | S\_n\\ \end{matrix}

![](https://blog.lexfo.fr/images/xortigate-cve-2023-27997/xortigate-enc-2.png)

Keystream example values

The keystream SS can be xored to the rest of the `enc` payload, the size and the ciphertext, to decrypt them. It is sent as an hexadecimal string.

The decryption method looks like this (simplified code):

```
int parse_enc_data(char *in)
{
    int in_len = strlen(in);
    int given_len;
    int xored_given_len;

    if(in_len & 1)
    {
        return 1;
    }

    compute_key_zero(salt, in, 8, md5); // [1] Computes key from salt, seed

    out = alloc_block(*pool, (in_len >> 1) + 1); // [2] Allocate a buffer
    unhex(out, in); // [2] Hexa-decode in to out

    if (out[0]) // first byte of seed must be 0x00
    {
        ap_log_rerror((__int64)a1, 8LL, (__int64)"invalid encoding method %d\n", needs_null);
        return 1;
    }

    // [3] Decrypt given length
    xored_given_len = *((_WORD *)out + 2);
    given_len = (unsigned __int8)(xored_given_len ^ md5[0]);
    BYTE1(given_len) = md5[1] ^ HIBYTE(xored_given_len);

    if ( inlen - 5 <= given_len ) // [4] Verify bounds
    {
        ap_log_rerror(a1, 8LL, "invalid enc data length: %d\n", given_len);
        return 1LL;
    }

    // [5] Decrypt: xor every input from byte 6 (4 bytes for seed, 2 bytes for length)
    p = &out[6];
    if (given_len)
    {
        int i = 0LL;
        while (i < given_len)
        {
            p[i] ^= md5[(i + 3) % 16];
            if ((i + 3) % 16 == 0) // Current state is exhausted: compute new
            {
                MD5_Init(md5_ctx);
                MD5_Update(md5_ctx, md5, 16LL);
                MD5_Final(md5, md5_ctx);
            }
            ++i;
        }
    }
    out[6 + given_len] = 0; // [6] Append null byte

    add_kvp_to_hashmap(a1->params, out); // [7] Process plaintext

    // Allocated buffers get freed at the end of the HTTP exchange
    return 0;
}
```

The function behaves like so:

1. Compute an MD5 (16 bytes), which is the first state of the key from the salt and the seed (first 8 chars of `in`)
2. Allocate a buffer of size `in_len / 2 + 1`, `out`, and hexadecimal-decoded input into it
3. Compute the length given by the user, `given_len`, by xoring the first two bytes of the payload with the first two of the key
4. Bound check: verify that the given length is not greater than the size of the buffer
5. Decrypt the whole string in place: XOR the first 14 bytes, then compute a new state K1K\_1, use it to XOR the 16 next bytes, and repeat.
6. Put a NULL byte at the end of the decrypted data
7. Add decrypted values to the hashmap containing HTTP input params

The bug is easy to spot: when the program checks that the given length is not greater than the length of the sent payload, it compares `in_len` to `given_len`. But while the former describes the length of the payload in hexadecimal (*e.g.* `'41424343'`), the latter describes its size in raw bytes (*e.g* `'ABCD'`). As a result, `given_len` can be twice as big as it should be.

This bug allows us to apply the decryption process to not only to the ciphertext in `out`, but also to the memory that comes after.

This makes for a funny bug: instead of just overwriting bytes in the heap, we get to XOR them with some MD5!

The bug allows us to allocate a chunk of arbitrary size NN, `out`, and then XOR bytes after the buffer with a keystream of MD5 hashes, for which we partially control the key. We control the size of the allocated buffer, and the size of the XOR overflow. In addition, the last byte of the overflow gets nulled.

*Hereafter, we name BiB\_i the ith byte in memory, and KiK\_i the ith byte of the keystream. Therefore, triggering the bug with a length of LL applies:*

{Bi≔Bi⊕Kiwithi∈[0,L−1]BL≔0\begin{cases} B\_i \colonequals B\_i \oplus K\_i \enspace \text{with} \enspace i \in [0, L-1]\\ B\_L \colonequals 0 \end{cases}

We "control" the MD5 hashes because we partially control the bytes used to create the first one:

{S0=MD5(salt∣seed∣”GCC is the GNU Compiler Collection.”)Sn+1=MD5(Sn)Sn=K8×ntoKn×8+7\begin{cases} S\_0 = MD5(salt | seed | \text{''GCC is the GNU Compiler Collection.''})\\ S\_{n+1} = MD5(S\_n)\\ S\_n = K\_{8 \times n} \enspace \text{to} \enspace K\_{n \times 8+7} \end{cases}

It's easy to enforce the value of some bytes of the keystream by bruteforcing with the seed. We can't, however, hope to control all of it.

## First idea

The first thing that comes to mind, is xoring the LSB of some address to change its position. Something like this:

```
00 C9 12 32 BB 7F 00 00 (0x7FBB3212C900) [Original pointer]
30 63 00 00 00 00 00    (0x000000006330) [Part of keystream]
----------------------- XOR
30 AA 12 32 BB 7F 00 00 (0x7FBB3212AA30) [Modified pointer]
```

However, this is costly: we need to find an MD5 hash which starts with `306300000000`. This hash is the hash of another one, which is the hash of another one, etc. If the distance from the hash to the pointer we want to modify is 0x1000 for instance, this would be the 256th state of the key stream. Not to hard to compute once, but to bruteforce...

Even if we manage to get such a hash, the data previous to this modified pointer would get garbled, because it'd be XORed with previous hashes, whose contents we can...