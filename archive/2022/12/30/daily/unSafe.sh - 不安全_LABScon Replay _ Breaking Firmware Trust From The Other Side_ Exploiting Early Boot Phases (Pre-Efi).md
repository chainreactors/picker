---
title: LABScon Replay | Breaking Firmware Trust From The Other Side: Exploiting Early Boot Phases (Pre-Efi)
url: https://buaq.net/go-143062.html
source: unSafe.sh - 不安全
date: 2022-12-30
fetch_date: 2025-10-04T02:43:01.037542
---

# LABScon Replay | Breaking Firmware Trust From The Other Side: Exploiting Early Boot Phases (Pre-Efi)

* [unSafe.sh - 不安全](https://unsafe.sh)
* [我的收藏](/user/collects)
* [今日热榜](/?hot=true)
* [公众号文章](/?gzh=true)
* [导航](/nav/index)
* [Github CVE](/cve)
* [Github Tools](/tools)
* [编码/解码](/encode)
* [文件传输](/share/index)
* [Twitter Bot](https://twitter.com/buaqbot)
* [Telegram Bot](https://t.me/aqinfo)
* [Search](/search/search)

[Rss](/rss.xml)

[ ]
黑夜模式

![]()

LABScon Replay | Breaking Firmware Trust From The Other Side: Exploiting Early Boot Phases (Pre-Efi)

Breaking Firmware Trust From The Other Side: Exploiting Early Boot PhasesAlex Matrosov: I think
*2022-12-29 20:29:31
Author: [www.sentinelone.com(查看原文)](/jump-143062.htm)
阅读量:22
收藏*

---

Breaking Firmware Trust From The Other Side: Exploiting Early Boot Phases

**Alex Matrosov:**

I will probably just make a chart. So it’s the Binarly research team which has been involved. Google remembers all my research better than me. You can just Google my name. All right.

So this is a short agenda for today. And I think we will start with some introduction and why this topics are important and then dive deeper into the problems features that actually cause these vulnerabilities. Right.

So first of all, like the complexity of the modern firmware, it’s increasing every year. And to be honest, like your laptop is running the firmware, which is bigger than ntos kernel nowadays. It’s a whole operating system, but most of most of the endpoint solutions doesn’t look in there and also repeatable problems happen in there. So basically all the vulnerabilities we are discovering, it’s in not new attack vectors. It’s been known before. Probably pre-EFI is a new stuff, but system management, memory corruption bugs come from the early 2000 but are still a thing.

All this vulnerability is actually been discovered by Binarly team. And as you can see, like we today disclose 68 vulnerabilities for a bit more than a year and 50 plus. It’s still under the disclosure. That’s a lot. What we can deduce, it’s been a failure when HP not patch the bugs after Black Hat talk almost two months after the Black hat talk. Of course, not all of them, but some are still left unpatched. And think about it. It’s high severity issues. It’s like what, 8.5, 8.2 in CVS score and it’s left unpatched all the documentation available. Black Hat recording is available and actually it can cause problems to your infrastructures.

And today. So basically we make one more transition. To be honest, I want to discuss ten bugs, but three bugs actually been not patched because it’s actually cause more serious problems that this seven and takes more time.

But to be honest I want to thank you Insyde’s product security team which make it happen in less than 90 days, which is very very rare thing for firmware vulnerabilities. Usually the disclosure cycle, it goes six months and up. Sometimes it’s actually takes more than a year. As example, previous Black Hat talk, it’s been 13 months when Intel been patching BSSA DFT issue and today’s vulnerabilities which is we will be on the next slides. So it’s actually an industry wide thing.

So we are talking not just single vulnerability impacting one vendor.It’s actually a reference code which is used by many devices, not just single device, and that’s actually can cause a lot of problems.

So quickly on the attacker model. So usually such vulnerabilities is used for the second stage when actually the attacker want to gain additional persistence on the device and want to actually sit on there for months. And if you think about all these recent discoveries, MoonBounce, CosmicStrand, and others, it’s like comes from 2014, seven years of persistence. Wow. That’s kind of like a thing for the firmware problems. So.

But let’s recap a bit some of the basics on the firmware problems. So what is NVRAM, what is NVRAM persistence and why it can cause problems? So environments the storage for some of the data which is used during the boot, let’s just call that like that and it’s stored on the flash memory and basically this memory is not protected by any security features like Intel boot guard and others because it’s used in early boot. And some of these things are persistent. So this data used during the boot. What it can cause, of course, the bugs. Right. So if you modify some of these variables and if it can cause the code execution, these persistent variables can also be use for persistence, right. So consistent exploitation and actually take an attacker some advantage.

So here is the NVRAM attack surface, which is show you like this type of variables is used during the PEI phase, DXE phase, which is actually available during an operating system.

**Alex Matrosov:**
And of course from the operating system you have a read write access to there with a privileged user. And important reminder vulnerabilities we are covering today. It will be not detected by health attestation, not will be detected by PCR registers from the TPM because PCR are not extending in runtime. So they measure what been known to measure not new things.

Attack surface for pre-EFI. And actually what interesting about PFI mode, it’s actually enable a lot of security features for later stages and a lot of things are just not enabled yet. So also you can actually reflect or disable from security feature standpoint and this is completely new thing because everybody thinks oh, SMM is bad, SMM some rootkits is bad, but nobody thinks about what’s happening before. So basically pre-EFI is security boundary when by default it’s trusted because all system management mode is initialized at that phase. So this is actually a potential proof of concept about how we can survive of the payload delivery from platform initialization phase, pre-EFI phase to system management mode. So basically constantly enabling some of the key mechanisms which is actually can create an anchor between these different phases. We can survive. But of course I have a policy for that.

**Alex Matrosov:**
So basically. It works like a charm. So you exploit the bug, which is actually on pre-EFI phase, but it’s also available to exploitation from from operating system level and boom, you found the keys. Cool right? And working very fast. It’s a recent Ubuntu server. But let’s talk more about attack surface on pre-EFI and what kind of problem it can cause. So basically Intel Platform Properties Assessment Module, which is part of the hardware shield. It’s short abbreviation. It’s PPAM. So in the perfect world it looks like that. So it’s how Intel imagines it will be designed on the systems. But complexity increase. Design issues remain forever, right? So basically initially PPAM get inspired by is my transfer monitor its earlier concept. I would say it comes from 2013-14 when Intel been experimenting with these things and actually open sourced a lot of documentation about that but think is it’s been heavily impacting the performance and I don’t see much of this implemented actually on the real systems except some of specific systems. And Intel came up with a simpler concept. It’s not really related, but actually also try to separate different policies on SMM drivers and this concept called PPAM. So basically we have this very high level picture of how it is initialized. But if you look on that, we actually have PEI SMM CPU DXE SMM system, which is actually the driver which is being initialized during the pre-EFI phase.

**Alex Matrosov:**
So boom, of course we can influence from earlier boot to the later boot and actually we can attack the data and some of the configuration of things for such security feature. And we found one bug in an HP machine, it’s actually the most recent HP book, which is used a lot on the enterprise users networks. And also this bug exists actually on some other systems on HP. So basically simply you can modify in the memory one flag and then this feature will not be enabled in runtime. But of course like Intel reference implementation, by the way, doesn’t have this bug. W...