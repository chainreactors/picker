---
title: Checkm8 Exploit Explained How Apple’s Worst Vulnerability Works at the Lowest Level
url: https://idevicecentral.com/jailbreak-tools/checkm8-exploit-explained/
source: Instapaper: Unread
date: 2025-06-13
fetch_date: 2025-10-06T22:56:04.323505
---

# Checkm8 Exploit Explained How Apple’s Worst Vulnerability Works at the Lowest Level

[Skip to content](#primary)

[iDevice Central](https://idevicecentral.com/)

* [Home](https://idevicecentral.com/)* [Jailbreak Tools](https://idevicecentral.com/jailbreak-tools/ios-jailbreak-downloads-download-jailbreak-tools-for-all-ios-versions/)* [iOS Jailbreak Finder](https://idevicecentral.com/ios-jailbreak-tool-finder/)* [MDC Apps](https://idevicecentral.com/jailbreak-tools/all-macdirtycow-tools-ipa-downloads/)* [iOS Signing Status](https://idevicecentral.com/ios-signing-status/)
          + [SEP & Baseband Chart](https://idevicecentral.com/ios-downgrade/futurerestore-ios-downgrade-sep-and-baseband-compatibility-chart/)* [TweaksDB](https://idevicecentral.com/tweaksdb/)* [Advertise](https://idevicecentral.com/advertise-on-idevice-central/)

Search for:

Main Menu

Posted in

* [Jailbreak Tools](https://idevicecentral.com/category/jailbreak-tools/)

# checkm8 Exploit Explained: How Apple’s Worst Vulnerability Works at the Lowest Level

![GeoSn0w](data:image/png;base64...)![GeoSn0w](https://idevicecentral.com/wp-content/litespeed/avatar/57daf6219a8838af11b51912f4a20b16.jpg?ver=1759591167)by [GeoSn0w](https://idevicecentral.com/author/geosn0w/)•[June 12, 2025June 12, 2025](https://idevicecentral.com/jailbreak-tools/checkm8-exploit-explained/)•[0](https://idevicecentral.com/jailbreak-tools/checkm8-exploit-explained/#respond)

![Checkm8 Exploit Explained: How Apple's Worst Vulnerability Works at the Lowest Level](https://idevicecentral.com/wp-content/plugins/native-lazyload/assets/images/placeholder.svg "Checkm8 Exploit Explained: How Apple's Worst Vulnerability Works at the Lowest Level - iDevice Central")

Checkm8 Exploit Explained: How Apple's Worst Vulnerability Works at the Lowest Level

If you’ve ever wanted to jailbreak iOS or downgrade to older iOS, you’ve likely heard of the **checkm8 exploit** — a game-changing vulnerability discovered by axi0mX that targets the **SecureROM** (BootROM) of Apple devices ranging from A5 to A11.

In this article, I’ll break down the internals of the exploit: how it works, why it works, what CVE-2019-8900 is in technical detail, how the checkm8 implementation executes it, and how tools like **checkra1n** and **palera1n** utilize it for jailbreak purposes.

### CVE-2019-8900: The SecureROM Memory Corruption Bug Explained

Back in 2019, [developer axi0mX](https://x.com/axi0mx?lang=en "developer axi0mX") released [CVE-2019-8900](https://nvd.nist.gov/vuln/detail/CVE-2019-8900 "CVE-2019-8900"), a critical memory corruption vulnerability in Apple’s SecureROM USB descriptor handling logic.

> EPIC JAILBREAK: Introducing checkm8 (read "checkmate"), a permanent unpatchable bootrom exploit for hundreds of millions of iOS devices.
>
> Most generations of iPhones and iPads are vulnerable: from iPhone 4S (A5 chip) to iPhone 8 and iPhone X (A11 chip). <https://t.co/dQJtXb78sG>
>
> — [[email protected]](/cdn-cgi/l/email-protection) (@axi0mX) [September 27, 2019](https://twitter.com/axi0mX/status/1177542201670168576?ref_src=twsrc%5Etfw)

The root cause lies in **insufficient input validation combined with a fixed-size memory buffer** used in the DFU (Device Firmware Update) mode’s control transfer handler.

Here’s what the SecureROM logic roughly does when responding to a `GET_DESCRIPTOR` request:

```
int handle_get_descriptor(uint16_t wValue, uint16_t wLength) {
    uint8_t *desc = lookup_descriptor(wValue);
    if (!desc)
        return STALL;

    int len = desc[0]; // Assumes valid descriptor
    if (wLength < len)
        len = wLength;

    memcpy(usb_ep0_buffer, desc, len); // vulnerability: unchecked copy into fixed-size buffer
    return send_response(len);
}
```

There are several flaws in this code:

1. **No null-pointer check** — if `lookup_descriptor()` fails or returns a dangling pointer, a crash or memory leak may occur.- **No boundary enforcement** — SecureROM doesn’t check if `len` exceeds the size of `usb_ep0_buffer`.- **Predictable memory layout** — since DFU mode is minimal, memory state is deterministic across boots.

![Normal boot vs checkm8 boot on iOS](https://idevicecentral.com/wp-content/plugins/native-lazyload/assets/images/placeholder.svg "checkm8 bootchain - iDevice Central")![Normal boot vs checkm8 boot on iOS](https://idevicecentral.com/wp-content/uploads/2025/06/checkm8-bootchain.png "checkm8 bootchain - iDevice Central")

Normal boot vs checkm8 boot on iOS

By sending a maliciously crafted descriptor request and interrupting it with an **asynchronous cancel**, the attacker can:

* Corrupt internal state (leaving a pointer half-initialized)* Leak memory (dumping uninitialized SRAM content)* Overwrite heap/stack memory structures

This forms the basis of arbitrary memory write and code execution.

## Deep Dive into the checkm8 Exploit Code

### Heap Grooming and Callback Hijacking

While triggering the memory corruption is one thing, getting actual execution from it requires some clever tricks. This is where heap grooming, aka **heap feng shui**, comes into play — and the real magic of checkm8 starts to shine.

In certain SoCs (like A10, A10X, A11), a bug allows **zero-length packet requests** to leak in memory under the right conditions.

By sending crafted USB transfers that aren’t multiples of 64 bytes (a quirk of USB), we can trigger this leak and cause the USB stack to allocate request objects that never get cleaned up.

These requests start to pile up on the heap. If timed right — and combined with a forced DFU shutdown before the transfers finish — they leave behind exactly-sized holes in heap memory. This is where we can land our payload structures on a future allocation.

On older devices like A8 or A9, this memory leak step isn’t even needed. You can go straight into code execution using a **DFU abort bug**. On A7 devices, the leak behavior is even more aggressive it happens on *every* request, so heap setup is even easier there.

Once we have the heap prepped, we intentionally cause a **use-after-free** by restarting DFU while SecureROM still holds pointers to freed buffers. The next DFU session allocates new buffers on top of these poisoned holes.

We then **overwrite a usb\_device\_io\_request** object, replacing its function pointer (used when the request completes) with one pointing to our payload in SRAM.

The final trick? A USB reset. This triggers cleanup in the DFU USB queue, and as each request’s callback is invoked, the one we hijacked gets executed, and our shellcode runs inside SecureROM.

This is the precise moment that checkm8 wins, turning a memory corruption bug into full SecureROM code execution.

From there, it’s just a matter of uploading PongoOS, custom bootloaders, or a patched kernel depending on your tool of choice.

**Here’s exactly what happens at the Python script level:**

#### USB Corruption Primitive: `stall()`

```
def stall(device):
    libusb1_async_ctrl_transfer(device, 0x80, 6, 0x304, 0x40A, 'A' * 0xC0, 0.00001)
```

* `bmRequestType = 0x80` – Device-to-host, standard, device.* `bRequest = 6` – GET\_DESCRIPTOR* `wValue = 0x304` – Invalid descriptor (intentionally malformed)* `wIndex = 0x40A` – Arbitrary* `data = 0xC0` bytes of junk* `timeout = 10us` – Forces immediate timeout and cancellation

The `libusb1_async_ctrl_transfer()` call submits this and then cancels it using `libusb_cancel_transfer`.

This results in an inconsistent USB state machine and a corrupted heap.

Amazing, especially considering that the SecureROM is not that big of a codebase and Apple audits the heck out of it after limera1n back in the days. Still, as you can see, you can never be too sure.

#### Memory Leak or Hole Creation

```
for i in range(config.hole):
    no_leak(device)
usb_req_leak(device)
```

The exploit can either:

* Dump memory by misusing descriptors (leak)* Create a hole for ROP chain/shellcode (hole)

#### Payload Injection + Overwrite

```
libusb1_no_error_ctrl_transfer(device, 0, 0, 0, 0, config.overwrite, 100)
for i in range(0, len(payload), 0x800):
    ...