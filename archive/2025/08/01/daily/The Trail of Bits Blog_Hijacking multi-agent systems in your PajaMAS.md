---
title: Hijacking multi-agent systems in your PajaMAS
url: https://blog.trailofbits.com/2025/07/31/hijacking-multi-agent-systems-in-your-pajamas/
source: The Trail of Bits Blog
date: 2025-08-01
fetch_date: 2025-10-07T00:15:27.191743
---

# Hijacking multi-agent systems in your PajaMAS

[The Trail of Bits Blog](/ "The Trail of Bits Blog")

[![Trail of Bits Logo](/img/tob.png)](https://trailofbits.com "Trail of Bits")

# Hijacking multi-agent systems in your PajaMAS

Suha Sabi Hussain

July 31, 2025

[machine-learning](/categories/machine-learning/), [multi-agent systems](/categories/multi-agent-systems/)

Page content

* [How MAS hijacking works](#how-mas-hijacking-works)
* [Understanding the attack surface of MAS hijacking](#understanding-the-attack-surface-of-mas-hijacking)
  + [Malicious environments](#malicious-environments)
  + [Malicious tools](#malicious-tools)
  + [Malicious (or compromised) agents](#malicious-or-compromised-agents)
  + [Exploiting the lethal trifecta](#exploiting-the-lethal-trifecta)
  + [Exploiting cycles](#exploiting-cycles)
  + [Bypassing naive security controls](#bypassing-naive-security-controls)
* [Building secure MASs](#building-secure-mass)
  + [Core design principles](#core-design-principles)
  + [MAS security checklist](#mas-security-checklist)
  + [Framework selection criteria](#framework-selection-criteria)
  + [Moving forward](#moving-forward)
  + [Acknowledgments](#acknowledgments)

Multi-agent systems (MASs) are an increasingly popular paradigm for AI applications. As Leslie Lamport famously noted, “a distributed system is one in which the failure of a computer you didn’t even know existed can render your own computer unusable.” It turns out that a similar aphorism applies to MASs.

MASs introduce a new dimension to the attack surface of AI applications: inter-agent control flow. Through an attack known as [MAS hijacking](https://arxiv.org/abs/2503.12188), attackers can manipulate the control flow of a MAS. Imagine your AI research assistant retrieves a malicious web page, and suddenly an attacker can execute arbitrary code on your machine.

Today, we’re releasing [pajaMAS](https://github.com/trailofbits/pajaMAS): a curated set of MAS hijacking demos that illustrate important principles of MAS security. In this post, we’ll walk through each demo, explain the underlying security principles, and present concrete guidance for secure MAS development.

## How MAS hijacking works

**MAS hijacking manipulates the control flow of MASs by exploiting how agents communicate with each other.** Discovered by [Triedman et al](https://arxiv.org/abs/2503.12188)., this attack can be seen as a variant of prompt injection that targets MAS control flow. The researchers hijacked multiple MASs to execute arbitrary malicious code, discovering that these attacks succeed:

* Across different domains, mediums, and topologies;
* Even when individual agents have strong prompt injection defenses; and
* Even when individual agents explicitly recognize the prompt as unsafe.

This is the fault in our agents: they’re [confused deputies](https://en.wikipedia.org/wiki/Confused_deputy_problem) laundering malicious data from other agents. The inherent unreliability of MASs [hinders their productionalization](https://cognition.ai/blog/dont-build-multi-agents) and enables attacks like MAS hijacking. This matters because MASs can also emerge [implicitly](https://docs.letta.com/guides/agents/architectures/sleeptime) whenever [multiple agents share an environment](https://www.anthropic.com/research/project-vend-1) or [a discovery protocol is adopted](https://a2a-protocol.org/v0.2.5/topics/agent-discovery/). The pajaMAS demos characterize the attack surface of MAS hijacking, informing secure design principles.

## Understanding the attack surface of MAS hijacking

Attackers can exploit a number of attack vectors to perform MAS hijacking, including a malicious environment, a malicious tool, or a malicious agent. Architectural weaknesses such as the “lethal trifecta,” cycles, and naive security controls can amplify the impact and complexity of these attacks.

### Malicious environments

The most common attack vector is a malicious environment. The **[`simple_mas`](https://github.com/trailofbits/pajaMAS/tree/main/simple_mas)** demo reproduces the paper’s target using Google’s Agent Development Kit (ADK). Here, an orchestration agent delegates tasks to a web surfing agent and code execution agent. The `simple_mas` demo includes multiple malicious websites with varying levels of subtlety ([partially generated by Claude agents](https://arxiv.org/abs/2504.19855)).

![Diagram comparing benign operation of an example MAS with the MAS hijacked operation](/img/mas-hijacking/figure1.png)

Figure 1: Diagram comparing benign operation of an example MAS with the MAS hijacked operation (Source: Triedman et al., 2025 [https://arxiv.org/abs/2503.12188])

**Here’s how the attack works**:

1. The user requests the orchestrator to summarize a specific URL.
2. The orchestrator delegates the task to the web surfing agent.
3. The web surfing agent visits the malicious website.
4. The malicious content makes the web surfing agent delegate to the code execution agent.
5. The code execution agent executes the payload.

Here’s the example malicious website we use in our demo:

![Screenshot of a simple, overtly malicious website used for simple_mas](/img/mas-hijacking/figure2.png)

Figure 2: Screenshot of a simple, overtly malicious website used for simple\_mas

And here’s a video of the attack:

[
](/img/mas-hijacking/mas_demo.mp4)

Figure 3: Video of the MAS hijacking attack

This demo illustrates that MASs create privilege escalation opportunities when high-privilege agents trust unvalidated outputs from low-privilege agents. Exploitation emerges from the interconnections: adding more agents typically multiplies uncertainty instead of adding robustness.

**Defensive considerations**: For this exploit, the system could validate the chain of commands prior to execution. Inputs could have metadata that state their source, which is appended to as it flows through the MAS, blocking invalid transitions. This validation should be independent of the LLM and supported by agentic frameworks.

### Malicious tools

Malicious tools present another attack vector for MAS compromise. In the **[`tool_mas`](https://github.com/trailofbits/pajaMAS/tree/main/tool_mas)** demo, the tool `safely_parse_web_search_results` is added to the web surfing agent. The tool’s name leads the agent to trust and use it automatically. However, when triggered by specific content, this tool injects malicious prompts into the agent’s response, achieving MAS hijacking like `simple_mas`.

Malicious tools can [exploit semantic and syntactic relationships](https://arxiv.org/abs/2504.03111) with legitimate tools to hijack control flows. Not only is the threat of malicious tools amplified by the [current state of the MCP ecosystem](https://blog.trailofbits.com/categories/mcp/), but attackers can also [prompt inject within descriptions](https://invariantlabs.ai/blog/mcp-security-notification-tool-poisoning-attacks), trick agents into [picking malicious tools](https://arxiv.org/abs/2504.04809), and [dynamically update tools over time](https://arxiv.org/abs/2412.10198) for more effective attacks.

**Defensive considerations:** Malicious tools require a defense-in-depth approach. Solutions include tool provenance tracking, tool allowlisting, independent output validation, tool data isolation, and [sandboxed](https://developer.nvidia.com/blog/sandboxing-agentic-ai-workflows-with-webassembly/) tool access to prevent lateral movement between agent contexts.

### Malicious (or compromised) agents

While [malicious agents matter when using an agent discovery protocol](https://docs.agntcy.org/), individual agents in a MAS can be compromised. In pajaMAS, **[`agent_memory_mas`](https://github.com/trailofbits/pajaMAS/tree/main/agent_memory_mas)** induces MAS hijacking by poisoning an agent’s memory for persistent compromise.

In `agent_memory_mas`, the web surfing agent can store user preferences through the inclusion of `_add_user_preference` tool, which uses ADK’s functions for memory.

**Here’s how the attack work...