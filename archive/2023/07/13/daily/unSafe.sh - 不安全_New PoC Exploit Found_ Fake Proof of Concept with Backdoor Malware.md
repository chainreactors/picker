---
title: New PoC Exploit Found: Fake Proof of Concept with Backdoor Malware
url: https://buaq.net/go-171877.html
source: unSafe.sh - 不安全
date: 2023-07-13
fetch_date: 2025-10-04T11:53:00.502402
---

# New PoC Exploit Found: Fake Proof of Concept with Backdoor Malware

* [unSafe.sh - 不安全](https://unsafe.sh)
* [我的收藏](/user/collects)
* [今日热榜](/?hot=true)
* [公众号文章](/?gzh=true)
* [导航](/nav/index)
* [Github CVE](/cve)
* [Github Tools](/tools)
* [编码/解码](/encode)
* [文件传输](/share/index)
* [Twitter Bot](https://twitter.com/buaqbot)
* [Telegram Bot](https://t.me/aqinfo)
* [Search](/search/search)

[Rss](/rss.xml)

[ ]
黑夜模式

![](https://8aqnet.cdn.bcebos.com/12cdfb41055f89eaed0d94f47c676552.jpg)

New PoC Exploit Found: Fake Proof of Concept with Backdoor Malware

A deceptive twist has appeared within cybersecurity norms—a proof
*2023-7-12 20:0:0
Author: [www.uptycs.com(查看原文)](/jump-171877.htm)
阅读量:39
收藏*

---

A deceptive twist has appeared within cybersecurity norms—a proof of concept (PoC) that, rather than demonstrating a vulnerability, stealthily harbors a hidden backdoor. Recently discovered by the Uptycs threat research team, our finding particularly impacts the security research community.

As their primary users, security researchers rely on PoCs to understand potential vulnerabilities by way of innocuous testing. In this instance, the PoC is a wolf in sheep's clothing, harboring malicious intent under the guise of a harmless learning tool. Its concealed backdoor presents a stealthy, persistent threat. Operating as a downloader, it silently dumps and executes a Linux bash script, all the while disguising its operations as a kernel-level process.

Its persistence methodology is quite crafty. Used to build executables from source code files, it leverages the make command to create a kworker file and adds its file path to the bashrc file, thus enabling the malware to continually operate within a victim's system.

The backdoor has broad data theft capabilities. It can exfiltrate a wide array of data—from the hostname and username to an exhaustive list of home directory contents. Moreover, an attacker can gain full access to a target system by adding their ssh key to the authorized\_keys file.

Despite its removal from GitHub, this malicious PoC has been widely shared, achieving significant engagement before its nefarious nature was exposed. For those who have executed it, the likelihood of data compromise is high. Therefore it’s crucial to:

* remove any unauthorized ssh keys
* delete the kworker file
* remove the kworker path from the bashrc file
* check /tmp/.iCE-unix.pid for potential threats

While it can be challenging to distinguish legitimate PoCs from deceptive ones, adopting safe practices such as testing in isolated environments (e.g., virtual machines) can provide a layer of protection.

Although not entirely new, this trend of spreading malware through PoCs poses a significant concern, and it's likely we’ll see this tactic continue to evolve. The Uptycs threat research team remains vigilant in uncovering such threats, thereby helping the security research community to stay abreast of evolving cybersecurity risks.

## Unveiling the Fake PoC

While testing PoCs of various CVEs, our team encountered [one](https://github.com/ChriSanders22/CVE-2023-35829-poc/) claiming to address CVE-2023-35829 (a critical vulnerability), its unusual activity being detected by Uptycs XDR. Significant irregularities suggested it might be deceptive in nature, prompting us to question its legitimacy.

Suspicious activity included unexpected network connections, unusual data transfers, and unauthorized system access attempts. Further investigation fleshed out aclocal.m4 as the initial file requiring additional analysis.

![Figure 1 - PoC repository files](https://www.uptycs.com/hs-fs/hubfs/Figure%201-4.png?width=769&height=534&name=Figure%201-4.png)

aclocal.m4 is normally part of automake, used by autoconf to consolidate macros. And it’s usually not an elf (executable and linkable format) file as it is here.

Figure 2 shows how make triggers src/aclocal.m4, which is the focus of this article.

![Figure 2 - The offending makefile](https://www.uptycs.com/hs-fs/hubfs/Figure%202-3.png?width=624&height=552&name=Figure%202-3.png)*Figure 2 – The offending makefile*

## Technical Analysis

The binary’s main function begins with an interesting string—kworker (figure 3).

![Figure 3-2](https://www.uptycs.com/hs-fs/hubfs/Figure%203-2.png?width=767&height=714&name=Figure%203-2.png)*Figure 3 – The start of the binary*

Line 79 checks if the binary is named kworker. If true, flow passes to the else condition in line 84. If not, two functions are executed called copy\_to\_kworker() and add\_to\_bashrc(). Establishing backdoor persistence, these copy the current file to $HOME/.local/kworker and add its file path to the $HOME/.bashrc file.

To conceal its presence, the program embeds itself in bashrc. The check\_for\_pidfile() function (figure 4) helps ensure that multiple instances of the same program aren’t running simultaneously.

![Figure 4 - Check_for_pidfile() function](https://www.uptycs.com/hs-fs/hubfs/Figure%204-2.png?width=767&height=712&name=Figure%204-2.png)

*Figure 4 – Check\_for\_pidfile() function*

After checking the /tmp/.ICE-unix.pid path, it writes the PID of the currently running process if no function has used flock(2) to restrict file access. The program proceeds only if the main function returns zero (0), indicating the current process is exclusive.

![Figure 5 - Main function else portion](https://www.uptycs.com/hs-fs/hubfs/Figure%205-2.png?width=770&height=711&name=Figure%205-2.png)

*Figure 5 – Main function else portion*

Achieved by forking the program, a new string [kworker/8:3] is created In the main function to obscure the original command line parameters. Subsequently, the parent process executes the curl\_func() function, which uses the libcurl library to download a URL that is obfuscated so as basic static analysis can’t easily find it. The URL is hxxp[:]//cunniloss[.]accesscam[.]org/hash[.]php; it contains a bash script that is run if the curl request succeeds.

(libcurl provides programmatic access to curl; it can be directly included in a binary {statically compiled} or called dynamically.)

![Figure 6 - Excerpt from curl_func()](https://www.uptycs.com/hs-fs/hubfs/Figure%206-1.png?width=757&height=461&name=Figure%206-1.png)*Figure 6 – Excerpt from curl\_func()*

![Figure 7 - Code portion that downloads the bash script](https://www.uptycs.com/hs-fs/hubfs/Figure%207-1.png?width=764&height=826&name=Figure%207-1.png)*Figure 7 – Code portion that downloads the bash script*

The %s variable is replaced by the curl request output, which implies that the following is the command run by kworker:

## Deconstructing the Bogus PoC

This PoC is copied from an old, legitimate [PoC](https://github.com/randorisec/CVE-2022-34918-LPE-PoC) of a Linux kernel vulnerability, CVE-2022-34918. On the surface, it appears to be an authentic demonstration, complete with strings that mimic genuine output. But the true nature of this deception becomes apparent upon closer examination of its code—particularly the discrepancies found within modprobe.c.

A new\_sn() function in the fake modprobe.c allocates memory, attempts to open a specific file, closes the file if it was successfully opened, generates a random number, then pauses program execution for a random duration.

![Figure 8 - Comparison of modprobe.c between the PoCs](https://www.uptycs.com/hs-fs/hubfs/Figure%208-1.png?width=1910&height=889&name=Figure%208-1.png)*Figure 8 – Comparison of modprobe.c between the PoCs*

A prepare\_root\_shell() function prints some strings and calls the setup\_modprobe\_payoad() function based on the condition. It exits with a status code of 0 after completing these operations.

![Figure 9 - Code portion that prints legitimate looking strings](https://www.uptycs.com/hs-fs/hubfs/Figure%209-1.png?width=1920&height=889&name=Figure%209-1.png)Figure 9 – Code portion that prints legitimate looking strings

The aforementioned setup\_modprobe\_payoad() assigns a value to the filename variable, then executes a /bin/sh command to open a new system shell. It then ...