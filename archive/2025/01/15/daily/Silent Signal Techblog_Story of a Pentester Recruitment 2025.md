---
title: Story of a Pentester Recruitment 2025
url: https://blog.silentsignal.eu/2025/01/14/pentester-recruitment-2025-mushroom/
source: Silent Signal Techblog
date: 2025-01-15
fetch_date: 2025-10-06T20:13:33.130957
---

# Story of a Pentester Recruitment 2025

[![Silent Signal](/assets/img/s2_avatar.jpg)](/)

Silent Signal

Professional Ethical Hacking Services

### Contact us

2025 © Silent Signal

![Story of a Pentester Recruitment 2025](/img/mushroom-alice.png)

# Story of a Pentester Recruitment 2025

s2crew 2025-01-14

In 2015, we published a [blog post](https://blog.silentsignal.eu/2015/04/03/the-story-of-a-pentester-recruitment/) about the recruitment challenges we devised for candidates who’d like to join our pentester team. The post got [much attention](https://www.reddit.com/r/netsec/comments/31af8p/the_story_of_a_pentester_recruitment/), with supportive comments and criticism as well. Learning from this experience, we created a completely new challenge that we’re retiring today, and we’d once again share our experiences (and the solutions!) we gained from this little game.

In summary, this second challenge of ours – called Mushroom – was much more successful than our first attempt: during the past 9 years, we hired 14 pentesters from junior to senior levels. We achieved this while keeping the challenge very simple, and mostly unchanged throughout the years. Mushroom was a simple web application that could be approached by even intern candidates but had some tricks that we could use to gauge the seniority of more experienced people too.

In the first part of this post we will guide our readers through all (intended) solutions of Mushroom. In the second part we share some experiences of the results we received. While we discussed other areas like mobile applications or Red Teaming during interviews, we now only focus on the web application testing aspect, as this was relevant at every seniority level (and the post is long enough already).

We mark some paragraphs with **[Industry Insight]** to indicate things that we as business owners learned during the several dozen interviews we’ve been through. We also mark paragraphs with **[Get Hired]** where we aim to help people get hired as pentesters.

## Process

Our hiring process was pretty simple: you express your interest in a pentest position (likely via e-mail), in reply, we ask you to choose a 72h time frame that you see fitting for solving the Mushroom challenge. After the 72h pass, you submit a written report (as if it was a real pentest). If we find the report satisfying, we invite you to an in-person interview, where we first go through the report, and then discuss other technical and administrative topics, including salary. If we agree on everything you are hired.

> Note: we are small company of about 20 people today, without a dedicated HR team. Mushroom was developed and the interviews were done by the company founders who also actively work as penetration testers.

Based on the feedback we received we improved our communication about this process a bit:

* Our salary ranges are public (and open at the top)
* While each candidate had 72 hours to complete the challenge, we explicitly told them that this window was intentionally oversized to leave space for job, studies, family, etc.

## Mushroom Solutions

Mushroom is a quite standard Flask web application with an Oracle backend database and mostly server-side rendering with a little jQuery sparkling on the frontend. The Flask WSGI application runs within Gunicorn, which is reachable via Apache HTTPd. The application doesn’t have authenticated interfaces, only a public UI where visitors can query information about mushrooms. The scope of the challenge was constrained to the HTTPS port of our server and a specific (virtual) hostname.

> The database is old enough not to contain LLM-hallucinated, potentially life-threatening misinformation about mushrooms.

Important parts of the challenge were that the candidate should:

* Find as many vulnerabilities as they can and demonstrate their impact.
* Document their findings in a penetration testing report (as if presenting it to a real client)

### I. Cross-Site Scripting

When playing around with the UI one can easily see that a URL parameter called `filter` is passed to the server when selecting different mushroom “active agents”

Of course, the parameter value can be directly manipulated in the browser, and it should be immediately obvious that the value is directly reflected on the UI:

[![Reflected content](/img/mushroom-reflected.png)](/img/mushroom-reflected.png)

Reflected content

This of course looks like a typical case of XSS, and we can even trivially inject some HTML into the frontend too:

[![Reflected content](/img/mushroom-htmli.png)](/img/mushroom-htmli.png)

Reflected content

Examining HTTP responses shows that there is no frontend magic, the rendering happens on the server-side, suggesting a vanilla XSS scenario. However, when we try to experiment with some typical proof-of-concept XSS payloads we’re faced with an unpleasant surprise:

[![Typical XSS payload](/img/mushroom-onerror.png)](/img/mushroom-onerror.png)

Typical XSS payload

Some candidates concluded that this behavior can only be used for HTML injection, but others rightfully wondered – what’s going on behind the scenes? While there are several ways to figure this out, a reliable method is to manipulate a “known bad” payload until we can deduce what part of it causes the error. Through this process, we can figure out that there is probably a Very Clever Filter™ implemented on the server-side:

[![Corrupt XSS payload](/img/mushroom-xonerror.png)](/img/mushroom-xonerror.png)

Corrupt XSS payload

Indeed, the relevant backend code was this:

```
PROTECT_RE = re.compile('(?:script|on(?:click|mouse|key|load|change|dbl|context|error|scroll|resize|focus))', re.I)
# ...
@app.route('/')
def index():
    active_filter = request.args.get('filter')
    if active_filter and PROTECT_RE.search(active_filter):
        abort(400)
```

Regular players didn’t see this of course, but assuming a deny-list it’s always easiest to just throw a lot of payloads to the service and see what sticks. Many candidates used online collections such as [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings) or [PortSwigger’s XSS Cheat Sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) – let’s see how we can extract some relevant entries from the JSON [dataset](https://github.com/PortSwigger/xss-cheatsheet-data) available for the latter using [jq](https://jqlang.github.io/jq/):

`jq -r '.[] | .tags[]|select(.interaction == false) | select(.browsers[] | contains("chrome")) | .code' events.json`

The above command parses the JSON map and provides us with a list of payloads that don’t need user interaction to fire and work in Chrome (for convenient manual verification).

We can feed this list to Burp’s Intruder (works fine for this task in the Community Edition too) or any simple script, then look for HTTP 200 responses:

[![Testing XSS payloads with Burp Intruder](/img/mushroom-intruder.png)](/img/mushroom-intruder.png)

Testing XSS payloads with Burp Intruder

**[Get Hired]** The above process is also doable manually, but we certainly appreciated if someone could improve their efficiency with some automation. Showing fluency in commonly used utils implies experience and that routine tasks won’t rob your time from the actual target.

In the end about half of the candidates successfully came up with a filter bypass and successfully demonstrated a reflected XSS vulnerability:

[![XSS PoC](/img/mushroom-xss.png)](/img/mushroom-xss.png)

XSS PoC

This vulnerability class is of course very common, and in case you are wondering: yes, unfortunately, we regularly see naive filters similar to the above one during our projects.

### II. SQL “injection”

When the user requests data about a mushroom, some jQuery code on the frontend sends a POST request to the `/ajax-table` interface with a Base64 encoded parameter that holds a JSON object:

```
POST /ajax_table HTTP/1.1
Host: mushroom.silentsignal.hu
Content-Length: 161
Content-Type: application/x-www-form-urlencod...