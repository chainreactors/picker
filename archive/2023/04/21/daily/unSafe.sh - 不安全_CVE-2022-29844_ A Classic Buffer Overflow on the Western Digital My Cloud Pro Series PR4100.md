---
title: CVE-2022-29844: A Classic Buffer Overflow on the Western Digital My Cloud Pro Series PR4100
url: https://buaq.net/go-159692.html
source: unSafe.sh - 不安全
date: 2023-04-21
fetch_date: 2025-10-04T11:32:27.301673
---

# CVE-2022-29844: A Classic Buffer Overflow on the Western Digital My Cloud Pro Series PR4100

* [unSafe.sh - 不安全](https://unsafe.sh)
* [我的收藏](/user/collects)
* [今日热榜](/?hot=true)
* [公众号文章](/?gzh=true)
* [导航](/nav/index)
* [Github CVE](/cve)
* [Github Tools](/tools)
* [编码/解码](/encode)
* [文件传输](/share/index)
* [Twitter Bot](https://twitter.com/buaqbot)
* [Telegram Bot](https://t.me/aqinfo)
* [Search](/search/search)

[Rss](/rss.xml)

[ ]
黑夜模式

![](https://8aqnet.cdn.bcebos.com/855427ebbb03b2d1f619fc341a1353f1.jpg)

CVE-2022-29844: A Classic Buffer Overflow on the Western Digital My Cloud Pro Series PR4100

This post covers an exploit chain demonstrated by Luca Moro (@johncool\_\_) during Pwn2Own Toronto 202
*2023-4-20 23:0:0
Author: [www.thezdi.com(查看原文)](/jump-159692.htm)
阅读量:51
收藏*

---

*This post covers an exploit chain demonstrated by Luca Moro (*[*@johncool\_\_*](https://twitter.com/johncool__)*) during Pwn2Own Toronto 2022. At the contest, he used a classic buffer overflow to gain code execution on the My Cloud Pro Series PR4100 Network Attached Storage (NAS) device. He also displayed a nifty* [*message*](https://twitter.com/thezdi/status/1600644437083914243?s=20) *on the device. Luca’s successful entry earned him $40,000 and 4 points towards Master of Pwn. All Pwn2Own entries are accompanied by a full whitepaper describing the vulnerabilities being used and how they were exploited. The following blog is an excerpt from that whitepaper detailing CVE-2022-29844 with minimal modifications.*

Prior to being patched by Western Digital, a memory corruption vulnerability existed in the FTP service of the My Cloud Pro Series PR4100. It allowed unauthenticated attackers to read arbitrary files and, in certain cases, write them. This vulnerability could allow the full compromise of the NAS and gives remote command execution capabilities.

The exploitation requires the FTP service to be activated. While the ability to read arbitrary files is always possible, writing needs at least one share to be “Public” and accessible via FTP. Such setting is the default configuration when a share is made available on FTP, so it should be a common case.

Here is Network Services panel showing FTP Access enabled:

![](https://images.squarespace-cdn.com/content/v1/5894c269e4fcb5e65a1ed623/acd77d14-b829-4934-866c-68e87db92478/env_setup_1.png)

*Figure 1 - Network Services Panel*

Here is the control panel for configuring FTP shares. Note that the needed settings are enabled by default when sharing a folder via FTP.

![](https://images.squarespace-cdn.com/content/v1/5894c269e4fcb5e65a1ed623/cbe7d0b7-43f9-45b6-a4d6-d6be05c5dda5/env_setup_2.png)

*Figure 2 - Control panel dialog for setting up FTP shares*

**Technical Analysis**

The issue was discovered by reverse engineering the firmware and source code auditing. The firmware used during this event can be downloaded [here](https://downloads.wdc.com/nas/WDMyCloudPR4100_5.24.108_prod.bin). The archive can be carved to extract a [SquashFS](https://tldp.org/HOWTO/SquashFS-HOWTO/whatis.html) filesystem. The GPL source code and the modifications made by Western Digital can be downloaded [here](https://downloads.wdc.com/gpl/WDMyCloud_PR4100_GPL_v5.24.108_20220826.tar.gz).

The FTP service used by the NAS is based on the [Pure-FTPd](https://www.pureftpd.org/project/pure-ftpd/) open source implementation with a few custom patches made by Western Digital. After extracting the GPL tar archive, one can find the custom modification in the `WDMyCloud_PR4100_GPL_v5.24.108_20220826/open-source-packages/pure-ftpd/pure-ftpd-1.0.47/patch/` path within the archive listed above.

To apply the WD patches, run the following commands:

One of the modifications concerns the function `douser()`, which is called when a user issues the ftp command “user ” in order to log in. In the next code example, the content pointed by the argument `const char \*username` is user controlled.

We can spot a buffer overflow vulnerability in the first `strncpy`. When `username` is larger than 2048 bytes an overwrite occurs after `auth_name` which is located in the `.bss` section. The overwritten data is fully controlled by the user. The only requirement is that the data should not contain any NULL bytes beside the finishing one.

Here are some of the relevant global variables located after `auth_name`:

The global variable `loggedin` is especially useful as it represents whether a user was authenticated. The string `wd` is also valuable as it represents the path of the working directory. By overwriting and abusing both of these variables, it is possible to achieve an arbitrary file read and write by using the FTP commands `cwd`, `retr`, and `stor`.

**Exploitation**

Given the previous analysis, the overall strategy for getting command execution would be to read or write an arbitrary file in order to install a backdoor served by the NAS webserver.

The first step would be to find a way to authenticate without valid credentials. This section explains how to do so given the vulnerability.

Then, to read or write a file, it seems reasonable to try to use the FTP features and commands. This would require changing the current working directory of the FTP session by using the command “cwd ”. This step needs some attention because of various access control checks detailed in this section. After a better understanding on how “cwd” is implemented, we will see how the exploit manage to achieve a file read and write.

*Step One: The Authentication Bypass*

As expected, the attacker does not have any credential on the NAS. Moreover, we must assume the FTP service is not accessible to anonymous user. Therefore, it is necessary to find a way to bypass the authentication.

Usually, authentication is achieved in two ftp commands:

         -- 'user ': This specifies the username we want to use to log on. It is implemented in `douser()`.

It is worth mentioning that without authenticating first, it is impossible to use other FTP commands to fetch or store files.

A simplified description of the `dopass()` implementation is to check the user password and set the global variable `loggedin` to 1 and eventually to use `setuid()` to change the user ID of the running process.

As previously seen, the vulnerability allows the attacker to overflow the variable `loggedin`. It is possible to make the server think that the user has already logged in by issuing only a malicious `user` command with a name long enough so that `loggedin` becomes something other than 0, which is sufficient.

One side effect is that the process will not use `setuid()` so the user root will remains the user of the running process. This will have some consequences later.

*Step Two: Access control*

*An Overview of the implementation*

Before retrieving or storing files, we need to change the current working directory of the FTP session by using the `cwd path` command. This command handling is implemented by the function `docwd()`, which was patched by Western Digital to include access control checks. Here are some of the relevant parts:

The main access control check resolves around the call to `check_allowed(wd_tmp, allowed)`, where `wd_tmp` is the concatenation of the global string `wd` and the user-controlled argument `dir`. The general idea is that `check_allowed()` returns something greater than 0 if the user is allowed to enter the directory.

In a similar fashion, the function `check_allowed()` is called when the user tries to read (`retr`) or write a file (`stor`). To provide some additional detail, `check_allowed()` is specific to Western Digital and is implemented in the closed source `/wd/usr/lib/libftp_allow.so` as seen in the example below:

This function checks whether the current user (using `getuid()` and `getpwuid()`) has access to the required path. The function relies on the `Get_Share_Permission()` function to determine the permissions over a path representing a share.

We can sum up the `check_allowed()` method as follows:

         -- If the path is `/`, then `check_allowed()` returns 1...