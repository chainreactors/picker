---
title: How I used o3 to find CVE-2025-37899, a remote zeroday vulnerability in the Linux kernel’s SMB implementation
url: https://sean.heelan.io/2025/05/22/how-i-used-o3-to-find-cve-2025-37899-a-remote-zeroday-vulnerability-in-the-linux-kernels-smb-implementation/
source: Sean Heelan's Blog
date: 2025-05-23
fetch_date: 2025-10-06T22:27:37.042783
---

# How I used o3 to find CVE-2025-37899, a remote zeroday vulnerability in the Linux kernel’s SMB implementation

[Skip to content](#content)

Open Menu

* [Home](https://sean.heelan.io/)
* [All Posts](https://sean.heelan.io/posts/)
* [Research & Publications](https://sean.heelan.io/research/)
* [About Me](https://sean.heelan.io/about-me/)

*Search*

Search for:

 Close

[![](https://sean.heelan.io/wp-content/uploads/2023/02/logo_ireland-1.jpg)](https://sean.heelan.io/)

# [Sean Heelan's Blog](https://sean.heelan.io/)

## Software Exploitation and Optimisation

[AI](https://sean.heelan.io/category/ai/) / [Bug hunting](https://sean.heelan.io/category/bug-hunting/) / [Linux Kernel](https://sean.heelan.io/category/linux-kernel/)

# How I used o3 to find CVE-2025-37899, a remote zeroday vulnerability in the Linux kernel’s SMB implementation

[May 22, 2025May 26, 2025](https://sean.heelan.io/2025/05/22/how-i-used-o3-to-find-cve-2025-37899-a-remote-zeroday-vulnerability-in-the-linux-kernels-smb-implementation/) [seanhn](https://sean.heelan.io/author/seanhn/)[11 Comments](https://sean.heelan.io/2025/05/22/how-i-used-o3-to-find-cve-2025-37899-a-remote-zeroday-vulnerability-in-the-linux-kernels-smb-implementation/#comments)

[Follow @seanhn](https://twitter.com/seanhn)

In this post I’ll show you how I found a zeroday vulnerability in the Linux kernel using OpenAI’s o3 model. I found the vulnerability with nothing more complicated than the o3 API – no scaffolding, no agentic frameworks, no tool use.

Recently I’ve been auditing ksmbd for vulnerabilities. ksmbd is “*[a linux kernel server which implements SMB3 protocol in kernel space for sharing files over network.](https://www.kernel.org/doc/html/v6.6/filesystems/smb/ksmbd.html)*“. I started this project specifically to take a break from LLM-related tool development but after the release of o3 I couldn’t resist using the bugs I had found in ksmbd as a quick benchmark of o3’s capabilities. In a future post I’ll discuss o3’s performance across all of those bugs, but here we’ll focus on how o3 found a zeroday vulnerability during my benchmarking. The vulnerability it found is CVE-2025-37899 (fix [here](https://github.com/torvalds/linux/commit/2fc9feff45d92a92cd5f96487655d5be23fb7e2b)), a use-after-free in the handler for the SMB ‘logoff’ command. Understanding the vulnerability requires reasoning about concurrent connections to the server, and how they may share various objects in specific circumstances. o3 was able to comprehend this and spot a location where a particular object that is not referenced counted is freed while still being accessible by another thread. As far as I’m aware, this is the first public discussion of a vulnerability of that nature being found by a LLM.

Before I get into the technical details, the main takeaway from this post is this: with o3 LLMs have made a leap forward in their ability to reason about code, and if you work in vulnerability research you should start paying close attention. If you’re an expert-level vulnerability researcher or exploit developer the machines aren’t about to replace you. In fact, it is quite the opposite: they are now at a stage where they can make you *significantly* more efficient and effective. If you have a problem that can be represented in fewer than 10k lines of code there is a reasonable chance o3 can either solve it, or help you solve it.

## Benchmarking o3 using CVE-2025-37778

Lets first discuss CVE-2025-37778, a vulnerability that I found manually and which I was using as a benchmark for o3’s capabilities when it found the zeroday, CVE-2025-37899.

CVE-2025-37778 is a use-after-free vulnerability. The issue occurs during the Kerberos authentication path when handling a “*session setup*” request from a remote client. To save us referring to CVE numbers, I will refer to this vulnerability as the “*kerberos authentication vulnerability*“.

The root cause looks as follows:

```
static int krb5_authenticate(struct ksmbd_work *work,
			     struct smb2_sess_setup_req *req,
			     struct smb2_sess_setup_rsp *rsp)
{
...
	if (sess->state == SMB2_SESSION_VALID)
		ksmbd_free_user(sess->user);

	retval = ksmbd_krb5_authenticate(sess, in_blob, in_len,
					 out_blob, &out_len);
	if (retval) {
		ksmbd_debug(SMB, "krb5 authentication failed\n");
		return -EINVAL;
	}
...
```

If `krb5_authenticate` detects that the session state is `SMB2_SESSION_VALID` then it frees `sess->user`. The assumption here appears to be that afterwards either `ksmbd_krb5_authenticate` will reinitialise it to a new valid value, or that after returning from `krb5_authenticate` with a return value of `-EINVAL` that `sess->user` will not be used elsewhere. As it turns out, this assumption is false. We can force `ksmbd_krb5_authenticate` to not reinitialise `sess->user`, and we can access `sess->user` even if `krb5_authenticate` returns `-EINVAL`.

This vulnerability is a nice benchmark for LLM capabilities as:

1. It is interesting by virtue of being part of the remote attack surface of the Linux kernel.
2. It is not trivial as it requires:
   * (a) Figuring out how to get `sess->state == SMB2_SESSION_VALID` in order to trigger the free.
   * (b) Realising that there are paths in `ksmbd_krb5_authenticate` that do not reinitialise sess->user and reasoning about how to trigger those paths.
   * (c) Realising that there are other parts of the codebase that could potentially access `sess->user` after it has been freed.
3. While it is not trivial, it is also not insanely complicated. I could walk a colleague through the entire code-path in 10 minutes, and you don’t really need to understand a lot of auxiliary information about the Linux kernel, the SMB protocol, or the remainder of ksmbd, outside of connection handling and session setup code. I calculated how much code you would need to read at a minimum if you read every ksmbd function called along the path from a packet arriving to the ksmbd module to the vulnerability being triggered, and it works out at about 3.3k LoC.

OK, so we have the vulnerability we want to use for evaluation, now what code do we show the LLM to see if it can find it? My goal here is to evaluate how o3 would perform were it the backend for a hypothetical vulnerability detection system, so we need to ensure we have clarity on how such a system would generate queries to the LLM. In other words, it is no good arbitrary selecting functions to give to the LLM to look at if we can’t clearly describe how an automated system would select those functions. The *ideal* use of an LLM is we give it all the code from a repository, it ingests it and spits out results. However, due to context window limitations and regressions in performance that occur as the amount of context increases, this isn’t practically possible right now.

Instead, I thought one possible way that an automated tool could generate context for the LLM was through expansion of each SMB command handler individually. So, I gave the LLM the code for the ‘session setup’ command handler, including the code for all functions it calls, and so on, up to a call depth of 3 (this being the depth required to include all of the code necessary to reason about the vulnerability). I also include all of the code for the functions that read data off the wire, parses an incoming request, selects the command handler to run, and then tears down the connection after the handler has completed. Without this the LLM would have to guess at how various data structures were set up and that would lead to more false positives. In the end, this comes out at about 3.3k LoC (~27k tokens), and gives us a benchmark we can use to contrast o3 with prior models. If you’re interested, the code to be analysed is [here](https://github.com/SeanHeelan/o3_finds_cve-2025-37899/blob/master/session_setup_code.prompt) as a single file, created with the [files-to-prompt](https://github.com/simonw/files-to-prompt) tool.

The final decision is what prompt to use. You can find the system prompt and the other information I provided to the LLM in the .prompt files in [t...