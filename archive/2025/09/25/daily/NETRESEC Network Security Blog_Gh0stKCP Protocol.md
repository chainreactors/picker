---
title: Gh0stKCP Protocol
url: https://www.netresec.com/?page=Blog&month=2025-09&post=Gh0stKCP-Protocol
source: NETRESEC Network Security Blog
date: 2025-09-25
fetch_date: 2025-10-02T20:39:00.842356
---

# Gh0stKCP Protocol

Experts in network security monitoring and network forensics
[![Netresec](/images/Netresec_Logo_550x140.png)](https://www.netresec.com/)

[NETRESEC](/?page=Home)|

[Products](/?page=Products)|

[Training](/?page=Training)|

[Resources](/?page=Resources)|

[Blog](/?page=Blog)|

[About Netresec](/?page=AboutNetresec)

[NETRESEC](/)
»
[Blog](/?page=Blog)

Erik Hjelmvik

,

Wednesday, 24 September 2025 09:40:00 (UTC/GMT)

## [Gh0stKCP Protocol](/?page=Blog&month=2025-09&post=Gh0stKCP-Protocol)

Gh0stKCP is a transport protocol based on KCP, which runs on top of UDP. Gh0stKCP has been used to carry command-and-control (C2) traffic by malware families such as [PseudoManuscrypt](https://www.youtube.com/watch?v=uakw2HMGZ-I) and [ValleyRAT](https://malpedia.caad.fkie.fraunhofer.de/details/win.valley_rat)/[Winos4.0](https://unit42.paloaltonetworks.com/espionage-campaign-targets-south-asian-entities/#section5SubHeading42).

![Gh0stKCP ghost](https://media.netresec.com/images/Gh0stKCP_1492x839.webp)

@Jane\_0sint recently [tweeted](https://x.com/Jane_0sint/status/1966982647499899210) about ValleyRAT using a new UDP based C2 protocol. I wanted to take a closer look at the protocol, so I downloaded the PCAP from [any.run](https://app.any.run/tasks/de6167ca-1728-4e6a-b7b8-65404d49b5f3) and opened it with [CapLoader](https://www.netresec.com/?page=CapLoader). To my surprise CapLoader claimed that the C2 traffic was using a known protocol called “KCP”.

![ValleyRAT UDP traffic identified as KCP by CapLoader](https://media.netresec.com/images/CapLoader_ValleyRAT-KCP_877x521.webp)

The protocol detection feature in [CapLoader](https://www.netresec.com/?page=CapLoader) compares traffic in TCP and UDP sessions to statistical models of known protocols. This means that no protocol specification or RFC is required to identify a protocol. All that is needed is some example traffic to build a protocol model from (see [this XenoRAT detection video](https://netresec.com/?b=258f641) for a demonstration of this feature).
In this case CapLoader’s KCP protocol model was built from UDP based C2 traffic from PseudoManuscrypt, which was [reported to have been using KCP](https://www.bitsight.com/blog/zero-50k-infections-pseudomanuscrypt-sinkholing-part-1).

**What is KCP?**

[KCP](https://github.com/skywind3000/kcp/blob/master/README.en.md) is a UDP based protocol designed as a low-latency alternative to TCP. The protocol was created by [Lin Wei](https://x.com/skywind3000) in the early 2010s, primarily to transport p2p voice chat audio in games. The protocol is, however, very generic and can be used to transport basically any type of data.
The [KCP protocol specification](https://github.com/skywind3000/kcp/blob/master/protocol.txt) includes the following packet structure:

![KCP packet structure](https://media.netresec.com/images/KCP-packet-structure_1920x1080.webp)

The first field “conv” is a 32 bit (4 byte) unique ID for a KCP session. This conversation ID is used to uniquely identify a connection and will remain constant throughout the connection. KCP doesn’t include any handshake mechanism for establishing new sessions, which means that KCP endpoints typically start transmitting payload data already in the first KCP packet.

**The Gh0stKcp Protocol**

The UDP based KCP C2 protocol used by PseudoManuscrypt as well as the ValleyRAT C2 traffic that CapLoader reported being “KCP” both deviated from the original KCP specification in several ways. For instance, KCP packets have a 24 byte header, which means that packets shorter than 24 bytes can’t be KCP. In fact, the KCP source code actually [ignores UDP packets that carry less than 24 bytes of payload](https://github.com/skywind3000/kcp/blob/f4f3a89cc632647dabdcb146932d2afd5591e62e/ikcp.c#L766). Yet, both the PseudoManuscrypt and ValleyRAT UDP C2 traffic initially transmit several 12-byte packets.

![CapLoader transcript of Gh0stKCP session](https://media.netresec.com/images/Gh0stKCP-transcript_984x502.webp)

*Image:Flow transcript of Gh0stKCP traffic in CapLoader*

These 12-byte Gh0stKCP handshake packets are generated by an open source library called [HP-Socket](https://github.com/ldcsaa/HP-Socket/), which includes a custom Automatic Repeat reQuest (ARQ) handshake mechanism.

The following behavior can be deduced by examining UDP traffic from Valley RAT or by analyzing the UDP handshake mechanism in HP-Socket's [ArqHelper.h](https://github.com/ldcsaa/HP-Socket/blob/dev/Windows/Src/ArqHelper.h).

The client (bot) starts by sending an empty UDP packet to the C2 server, followed by a UDP packet carrying a 12 byte payload structured like this:

4f bb 01 00 xx xx xx xx 00 00 00 00

The first four bytes can be decoded as follows:

* 4f bb = Magic bytes
* 01 = Handshake command
* 00 = Handshake is not completed

The “xx” bytes represent a KCP conversation ID (conv) proposed by the bot. This initial handshake packet can easily be detected and alerted on with the following Suricata IDS signature:

alert udp $HOME\_NET any -> $EXTERNAL\_NET any (msg:"Gh0stKCP handshake"; dsize:12; content:"|4f bb 01 00|"; offset:0; depth:4; content:"|00 00 00 00|"; within:8; distance:4; classtype:trojan-activity; reference:url,https://netresec.com/?b=259a5af; sid:1471101; rev:1;)

The C2 server also transmits a UDP packet containing a 12 byte handshake using the exact same structure as the client. However, the C2 server proposes a 32 bit conversation ID of its own. In “normal” KCP implementations the client and server agree on a single shared conversation ID, but Gh0stKCP actually uses one separate ID for each direction. This allows the server to transmit its handshake packet without having seen the client’s handshake.

4f bb 01 00 yy yy yy yy 00 00 00 00

The “yy” bytes represent the C2 server’s 32-bit conversation ID (conv).

The communicating parties frequently re-transmit this initial handshake packet until they have received a handshake from the other end.

Upon receiving the other end’s handshake both the bot and C2 server acknowledge the other end’s conversation ID with a UDP packet carrying the following 12 byte payload:

4f bb 01 00 xx xx xx xx yy yy yy yy

Where “xx” is the sender’s conversation ID and “yy” is the other end’s conversation ID. After having received the other end’s acknowledgment packet both parties additionally transmit a final ack packet, indicating that the handshake is completed and they will start communicating using KCP. This final ack packet is identical to the previous one, except the fourth byte (handshake complete flag) has changed from 0x00 to 0x01.

4f bb 01 01 xx xx xx xx yy yy yy yy

From this point on Gh0stKCP communicates using the KCP protocol, with the exception that each end transmits packets using their own conversation ID rather than a common ID. The KCP traffic that follows can therefore be parsed and inspected in Wireshark with help of a KCP Lua parser, such as CandyMi’s [kcp\_dissector.lua](https://github.com/cfadmin-cn/kcp_dissector/blob/master/kcp_dissector.lua).

![Gh0stKCP traffic in Wireshark with Lua script to decode KCP](https://media.netresec.com/images/KCP_Wireshark_914x1034.png)

*Image: KCP traffic from [ValleyRAT sample any.run](https://app.any.run/tasks/2ec47a05-8e51-4dd1-9dd8-e2c768ed02b1) in Wireshark*

Finally, the Gh0stKCP session is terminated by sending a UDP packet containing the following hard coded 16 bytes:

be b6 1f eb da 52 46 ba 92 33 59 db bf e6 c8 e4

This unique byte sequence is defined in HP-Socket as [s\_szUdpCloseNotify](https://github.com/ldcsaa/HP-Socket/blob/37b9f834a394f3f5747e57ef2602f88259572a52/Windows/Src/SocketHelper.cpp#L40), which can be detected with the following Suricata IDS signature:

alert udp any any -> any any (msg:"Gh0stKCP close"; dsize:16; content:"|be b6 1f eb da 52 46 ba 92 33 59 db bf e6 c8 e4|"; offset:0; depth:16; classtype:trojan-activity; reference:url,https://netresec.com/?b=259a5af; sid:1471102; rev:1;)

**Hole Punching in NAT Firewalls**

The ela...