---
title: Exploiting null-dereferences in the Linux kernel
url: https://googleprojectzero.blogspot.com/2023/01/exploiting-null-dereferences-in-linux.html
source: Project Zero
date: 2023-01-20
fetch_date: 2025-10-04T04:23:02.908320
---

# Exploiting null-dereferences in the Linux kernel

# [Project Zero](https://googleprojectzero.blogspot.com/)

News and updates from the Project Zero team at Google

## Thursday, January 19, 2023

### Exploiting null-dereferences in the Linux kernel

Posted by Seth Jenkins, Project Zero

For a fair amount of time, null-deref bugs were a highly exploitable kernel bug class. Back when the kernel was able to access userland memory without restriction, and userland programs were still able to map the zero page, there were many easy techniques for exploiting null-deref bugs. However with the introduction of modern exploit mitigations such as SMEP and SMAP, as well as mmap\_min\_addr preventing unprivileged programs from mmap’ing low addresses, null-deref bugs are generally not considered a security issue in modern kernel versions. This blog post provides an exploit technique demonstrating that treating these bugs as universally innocuous often leads to faulty evaluations of their relevance to security.

## Kernel oops overview

At present, when the Linux kernel triggers a null-deref from within a process context, it generates an [oops](https://en.wikipedia.org/wiki/Linux_kernel_oops), which is distinct from a kernel panic. A panic occurs when the kernel determines that there is no safe way to continue execution, and that therefore all execution must cease. However, the kernel does not stop all execution during an oops - instead the kernel tries to recover as best as it can and continue execution. In the case of a task, that involves throwing out the existing kernel stack and going directly to make\_task\_dead which calls do\_exit. The kernel will also publish in dmesg a “crash” log and kernel backtrace depicting what state the kernel was in when the oops occurred. This may seem like an odd choice to make when memory corruption has clearly occurred - however the intention is to allow kernel bugs to more easily be detectable and loggable under the [philosophy that a working system is much easier to debug than a dead one.](https://yarchive.net/comp/linux/BUG.html)

The unfortunate side effect of the oops recovery path is that the kernel is not able to perform any associated cleanup that it would normally perform on a typical syscall error recovery path. This means that any locks that were locked at the moment of the oops stay locked, any refcounts remain taken, any memory otherwise temporarily allocated remains allocated, etc. However, the process that generated the oops, its associated kernel stack, task struct and derivative members etc. can and often will be freed, meaning that depending on the precise circumstances of the oops, it’s possible that no memory is actually leaked. This becomes particularly important in regards to exploitation later.

## Reference count mismanagement overview

Refcount mismanagement is a fairly well-known and exploitable issue. In the case where software improperly decrements a refcount, this can lead to a classic UAF primitive. The case where software improperly doesn’t decrement a refcount (leaking a reference) is also often exploitable. If the attacker can cause a refcount to be repeatedly improperly incremented, it is possible that given enough effort the refcount may overflow, at which point the software no longer has any remotely sensible idea of how many refcounts are taken on an object. In such a case, it is possible for an attacker to destroy the object by incrementing and decrementing the refcount back to zero after overflowing, while still holding reachable references to the associated memory. 32-bit refcounts are particularly vulnerable to this sort of overflow. It is important however, that each increment of the refcount allocates little or no physical memory. Even a single byte allocation is quite expensive if it must be performed 232 times.

## Example null-deref bug

When a kernel oops unceremoniously ends a task, any refcounts that the task was holding remain held, even though all memory associated with the task may be freed when the task exits. Let’s look at an example - an otherwise unrelated bug I coincidentally discovered in the very recent past:

|  |
| --- |
| static int show\_smaps\_rollup(struct seq\_file \*m, void \*v)  {          struct proc\_maps\_private \*priv = m->private;          struct mem\_size\_stats mss;          struct mm\_struct \*mm;          struct vm\_area\_struct \*vma;          unsigned long last\_vma\_end = 0;          int ret = 0;            priv->task = get\_proc\_task(priv->inode); //task reference taken          if (!priv->task)                  return -ESRCH;            mm = priv->mm; //With no vma's, mm->mmap is NULL          if (!mm || !mmget\_not\_zero(mm)) { //mm reference taken                  ret = -ESRCH;                  goto out\_put\_task;          }            memset(&mss, 0, sizeof(mss));            ret = mmap\_read\_lock\_killable(mm); //mmap read lock taken          if (ret)                  goto out\_put\_mm;            hold\_task\_mempolicy(priv);            for (vma = priv->mm->mmap; vma; vma = vma->vm\_next) {                  smap\_gather\_stats(vma, &mss);                  last\_vma\_end = vma->vm\_end;          }            show\_vma\_header\_prefix(m, priv->mm->mmap->vm\_start,last\_vma\_end, 0, 0, 0, 0); //the deref of mmap causes a kernel oops here          seq\_pad(m, ' ');          seq\_puts(m, "[rollup]\n");            \_\_show\_smap(m, &mss, true);            release\_task\_mempolicy(priv);          mmap\_read\_unlock(mm);    out\_put\_mm:          mmput(mm);  out\_put\_task:          put\_task\_struct(priv->task);          priv->task = NULL;            return ret;  } |

This file is intended simply to print a set of memory usage statistics for the respective process. Regardless, [this bug report](https://lore.kernel.org/lkml/20221003224531.1930646-1-sethjenkins%40google.com/T/) reveals a classic and otherwise innocuous null-deref bug within this function. In the case of a task that has no VMA’s mapped at all, the task’s mm\_struct mmap member will be equal to NULL. Thus the priv->mm->mmap->vm\_start access causes a null dereference and consequently a kernel oops. This bug can be triggered by simply read’ing /proc/[pid]/smaps\_rollup on a task with no VMA’s (which itself can be stably created via ptrace):

[![Kernel log showing the oops condition backtrace](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjW-7Gf0dWd5QJfxXYwRAdtMX7uoynsldEgf9C7saF7MLL_iwIUVaagMyOAa8r-e4_KDf33viQn5U2w1LirUQnx7Vk1fJgpACWUijAl8Pgtiu8ZrDTaiEzJYSo3pJUX_nh4Mh4EQ2GPclwSCHcA-OmGfexegm4WykTZyKnIq9ktGTiLcCJo0QW0VKx6/s1138/image1.png "Kernel log showing the oops condition backtrace")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjW-7Gf0dWd5QJfxXYwRAdtMX7uoynsldEgf9C7saF7MLL_iwIUVaagMyOAa8r-e4_KDf33viQn5U2w1LirUQnx7Vk1fJgpACWUijAl8Pgtiu8ZrDTaiEzJYSo3pJUX_nh4Mh4EQ2GPclwSCHcA-OmGfexegm4WykTZyKnIq9ktGTiLcCJo0QW0VKx6/s1138/image1.png)

This kernel oops will mean that the following events occur:

1. The associated struct file will have a refcount leaked if fdget took a refcount (we’ll try and make sure this doesn’t happen later)
2. The associated seq\_file within the struct file has a mutex that will forever be locked (any future reads/writes/lseeks etc. will hang forever).
3. The task struct associated with the smaps\_rollup file will have a refcount leaked
4. The mm\_struct’s mm\_users refcount associated with the task will be leaked
5. The mm\_struct’s mmap lock will be permanently readlocked (any future write-lock attempts will hang forever)

Each of these conditions is an unintentional side-effect that leads to buggy behaviors, but not all of those behaviors are useful to an attacker. The permanent locking of events 2 and 5 only makes exploitation more difficult. Condition 1 is unexploitable because we cannot leak the struct file refcount again without taking a mutex that will never be unlocked. Condition 3 is unexploitable because a task struct uses a safe saturating kernel refcount\_t which prevents th...