---
title: 浅谈恶意样本の反沙箱分析
url: https://forum.butian.net/share/4050
source: 奇安信攻防社区
date: 2025-01-21
fetch_date: 2025-10-06T20:04:31.921248
---

# 浅谈恶意样本の反沙箱分析

#

[问答](https://forum.butian.net/questions)

*发起*

* [提问](https://forum.butian.net/question/create)
* [文章](https://forum.butian.net/share/create)

[攻防](https://forum.butian.net/community)
[活动](https://forum.butian.net/movable)

Toggle navigation

* [首页 (current)](https://forum.butian.net)
* [问答](https://forum.butian.net/questions)
* [商城](https://forum.butian.net/shop)
* [实战攻防技术](https://forum.butian.net/community)
* [漏洞分析与复现](https://forum.butian.net/articles)
  NEW
* [活动](https://forum.butian.net/movable)
* [摸鱼办](https://forum.butian.net/questions/Play)

搜索

* [登录](https://forum.butian.net/login)
* [注册](https://user.skyeye.qianxin.com/user/register?next=http://forum.butian.net/btlogin)

### 浅谈恶意样本の反沙箱分析

说实话单纯的静态免杀其实不是很难，只要通过足够新颖的加壳手段就能够成功将木马加载到内存中，但是抵御不了蓝队（比如微步云沙箱）使用沙箱的动态分析，所以通常只能够免杀小一天就上传了病毒库，从而免杀失效了。
本文就是来介绍几种反沙箱的思路来帮助红队搞出耐得住沙箱考验的payload

说实话单纯的静态免杀其实不是很难，只要通过足够新颖的加壳手段就能够成功将木马加载到内存中，但是抵御不了蓝队（比如微步云沙箱）使用沙箱的动态分析，所以通常只能够免杀小一天就上传了病毒库，从而免杀失效了。
本文就是来介绍几种反沙箱的思路来帮助红队搞出耐得住沙箱考验的payload
硬件检测法
-----
### BIOS检测法
win下可以直接通过wql来实现检测BIOS相关的信息
```php
package main
import (
"fmt"
"strings"
"github.com/StackExchange/wmi"
)
// 定义用于存储 WMI 查询结果的结构体
type Win32\_BIOS struct {
SMBIOSBIOSVersion string
Manufacturer string
Name string
SerialNumber string
}
func containsVMware(output string) bool {
return strings.Contains(strings.ToLower(output), "vmware")
}
func getBIOSInfoWindows() (string, error) {
var biosInfo []Win32\_BIOS
// 使用 WMI 查询 BIOS 信息
err := wmi.Query("SELECT SMBIOSBIOSVersion, Manufacturer, Name, SerialNumber FROM Win32\_BIOS", &biosInfo)
if err != nil {
return "", err
}
// 拼接所有 BIOS 信息字段
var result []string
for \_, bios := range biosInfo {
result = append(result, bios.SMBIOSBIOSVersion)
result = append(result, bios.Manufacturer)
result = append(result, bios.Name)
result = append(result, bios.SerialNumber)
}
return strings.Join(result, " "), nil
}
func main() {
biosInfo, err := getBIOSInfoWindows()
if err != nil {
fmt.Println("Error fetching BIOS information:", err)
return
}
fmt.Println("BIOS Information:")
fmt.Println(biosInfo)
if containsVMware(biosInfo) {
fmt.Println("VMware detected in BIOS information.")
} else {
fmt.Println("No VMware detected in BIOS information.")
}
}
```
在Linux下可以通过读取虚拟路径下的文件配置/sys来实现获取bios信息。
```php
package main
import (
"fmt"
"io/ioutil"
"strings"
)
// 检查字符串是否包含特定关键字（不区分大小写）
func containsIgnoreCase(s, substr string) bool {
return strings.Contains(strings.ToLower(s), strings.ToLower(substr))
}
// 从指定文件路径读取内容
func readFile(path string) (string, error) {
data, err := ioutil.ReadFile(path)
if err != nil {
return "", err
}
return strings.TrimSpace(string(data)), nil
}
// 检测是否运行在 WSL 环境中
func isWSL() (bool, error) {
// 检查 /proc/version 文件
version, err := readFile("/proc/version")
if err == nil && (containsIgnoreCase(version, "Microsoft") || containsIgnoreCase(version, "WSL")) {
return true, nil
}
// 检查 /proc/sys/kernel/osrelease 文件
osrelease, err := readFile("/proc/sys/kernel/osrelease")
if err == nil && (containsIgnoreCase(osrelease, "Microsoft") || containsIgnoreCase(osrelease, "microsoft-standard")) {
return true, nil
}
// 检查 /proc/self/mounts 文件
mounts, err := readFile("/proc/self/mounts")
if err == nil && (containsIgnoreCase(mounts, "lxfs") || containsIgnoreCase(mounts, "wslfs")) {
return true, nil
}
return false, nil
}
// 检测是否运行在 Hyper-V 环境中
func isHyperV() (bool, error) {
// 检查 /sys/class/dmi/id/bios\_vendor 文件
biosVendor, err := readFile("/sys/class/dmi/id/bios\_vendor")
if err == nil && containsIgnoreCase(biosVendor, "Microsoft") {
return true, nil
}
// 检查 /sys/class/dmi/id/product\_name 文件
productName, err := readFile("/sys/class/dmi/id/product\_name")
if err == nil && (containsIgnoreCase(productName, "Virtual Machine") || containsIgnoreCase(productName, "Hyper-V")) {
return true, nil
}
// 检查 /proc/cpuinfo 文件
cpuInfo, err := readFile("/proc/cpuinfo")
if err == nil && containsIgnoreCase(cpuInfo, "hypervisor") {
return true, nil
}
return false, nil
}
// 检测是否运行在其他虚拟机中
func isVirtualMachine() (bool, error) {
checkFiles := map[string][]string{
"/sys/class/dmi/id/bios\_vendor": {"VMware", "QEMU", "VirtualBox", "Microsoft", "Xen", "Alibaba Cloud", "OVMF"},
"/sys/class/dmi/id/bios\_version": {"VMware", "QEMU", "VirtualBox", "Hyper-V", "OVMF"},
"/sys/class/dmi/id/product\_name": {"VirtualBox", "VMware", "KVM", "Alibaba Cloud ECS", "OpenStack"},
"/sys/class/dmi/id/sys\_vendor": {"VMware", "QEMU", "VirtualBox", "Microsoft", "Xen", "Alibaba Cloud"},
}
for file, keywords := range checkFiles {
content, err := readFile(file)
if err != nil {
// 如果文件不存在或无法读取，跳过
continue
}
for \_, keyword := range keywords {
if containsIgnoreCase(content, keyword) {
return true, nil
}
}
}
return false, nil
}
func main() {
// 检测 WSL 环境
if isWSL, \_ := isWSL(); isWSL {
fmt.Println("The system is running in WSL (Windows Subsystem for Linux).")
return
}
// 检测 Hyper-V 环境
if isHyperV, \_ := isHyperV(); isHyperV {
fmt.Println("The system is running in a Hyper-V virtual machine.")
return
}
// 检测其他虚拟机环境
if isVM, \_ := isVirtualMachine(); isVM {
fmt.Println("The system is running in a virtual machine.")
return
}
// 如果都不是，则认为是物理机
fmt.Println("The system is running on a physical machine.")
}
```
### 检测MAC地址
一般来说VM的MAC地址会以特殊数据开头：例如00,这里收集了一些常见的数据用于检测(兼容win/linux)
```php
package main
import (
"fmt"
"net"
"strings"
)
// 常见虚拟机的 MAC 地址前缀
var vmMacPrefixes = []string{
"00:05:69", "00:0C:29", "00:1C:14", "00:50:56", // VMware
"08:00:27", // VirtualBox
"00:03:FF", "00:15:5D", // Hyper-V
"00:1C:42", // Parallels
"00:16:3E", // Xen
"52:54:00", // QEMU/KVM
}
// 检查 MAC 地址是否属于虚拟机
func isVirtualMachine(mac string) bool {
mac = strings.ToUpper(mac)
for \_, prefix := range vmMacPrefixes {
if strings.HasPrefix(mac, prefix) {
return true
}
}
return false
}
// 获取系统的所有 MAC 地址
func getMacAddresses() ([]string, error) {
var macAddresses []string
// 获取所有网络接口
interfaces, err := net.Interfaces()
if err != nil {
return nil, fmt.Errorf("failed to get network interfaces: %v", err)
}
// 遍历所有接口，提取 MAC 地址
for \_, iface := range interfaces {
// 检查接口是否有有效的硬件地址（MAC 地址）
if iface.HardwareAddr != nil && len(iface.HardwareAddr) > 0 {
macAddresses = append(macAddresses, iface.HardwareAddr.String())
}
}
// 如果没有找到任何 MAC 地址，返回错误
if len(macAddresses) == 0 {
return nil, fmt.Errorf("no MAC addresses found")
}
return macAddresses, nil
}
func main() {
// 获取所有 MAC 地址
macAddresses, err := getMacAddresses()
if err != nil {
fmt.Printf("Error: %v\n", err)
return
}
if len(macAddresses) == 0 {
fmt.Println("No MAC addresses found.")
return
}
// 检查是否为虚拟机
// isVM := false
for \_, mac := range macAddresses {
if isVirtualMachine(mac) {
fmt.Printf("VM MAC Address detected! This maybe a Virtual Machine or Host Machine MAC Address: %s\n", mac)
// isVM = true
break
}
}
}
```
但是有个问题，一般来说宿主机也会创建对应的虚拟网卡用于做NAT桥接，所以这个代码会把部分宿主机器当作虚拟机
### 检测CPU温度
例如在windows下我们能够通过别人写好的第三方库获取CPU温度，本质上还是在调用wmi查询，需要admin权限。
```php
package main
import (
"fmt"
"strings"
"github.com/shirou/gopsutil/host"
)
func main() {
// 获取传感器温度信息
sensors, err := host.SensorsTemperatures()
if err != nil {
fmt.Println("Error retrieving sensor data:", err)
return
}
// 如果没有传感器数据，可能是虚拟机
if len(sensors) == 0 {
fmt.Println("No temperature sensors detected. This might be a virtual machine.")
return
}
// 遍历传感器数据并输出
isVirtualMachine := false
for \_, sensor := range sensors {
fmt.Printf("Sensor: %s, Temperature: %.2f°C\n", sensor.SensorKey, sensor.Temperature)
// 检查传感器名称是否包含虚拟化相关信息
if strings.Contains(strings.ToLower(sensor.SensorKey), "virtual") ||
strings.Contains(strings.ToLower(sensor.SensorKey), "vmware") ||
strings.Contains(strings.ToLower(sensor.SensorKey), "hyperv") {
isVirtualMachine = true
}
}
// 判断是否为虚拟机
if isVirtualMachine {
fmt.Println("Virtualization-related sensors detected. This is likely a virtual machine.")
} else {
fmt.Println("No virtualization-related sensors detected. This is likely a physical machine.")
}
}
```
同理，Linux下就是去/sys查询就是了。这个代码也兼容Linux
进程判断法
-----
### 进程黑白名单
例如在虚拟机器中会有些用于管理的进程例如`vmtools.exe`这类，可以被标记为黑名单，还有就是普通的办公软件，例如微信，飞书这一类的，可以视为白名单
```php
package main
im...