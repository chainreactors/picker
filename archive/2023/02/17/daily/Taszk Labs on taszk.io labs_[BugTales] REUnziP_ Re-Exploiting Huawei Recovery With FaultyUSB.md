---
title: [BugTales] REUnziP: Re-Exploiting Huawei Recovery With FaultyUSB
url: https://labs.taszk.io/articles/post/reunzip/
source: Taszk Labs on taszk.io labs
date: 2023-02-17
fetch_date: 2025-10-04T07:16:44.418807
---

# [BugTales] REUnziP: Re-Exploiting Huawei Recovery With FaultyUSB

[![logo](https://labs.taszk.io/images/taszk_logo.png)
![logo](https://labs.taszk.io/images/taszk_logo_white.png)](https://labs.taszk.io)

* [Home](https://labs.taszk.io/)
* [Articles](https://labs.taszk.io/articles)
* [Advisories](https://labs.taszk.io/blog)
* [Get in touch](https://taszk.io/contact)

## [[BugTales] REUnziP: Re-Exploiting Huawei Recovery With FaultyUSB](https://labs.taszk.io/articles/post/reunzip/)

2023-02-16
 by Lorant Szabo
 [Huawei](/articles/tags/huawei) [ota](/articles/tags/ota) [recovery](/articles/tags/recovery) [toctou](/articles/tags/toctou)

Last year we published [UnZiploc](https://labs.taszk.io/articles/post/unziploc/), our research into Huawei’s OTA update implementation. Back then, we have successfully identified logic vulnerabilities in the implementation of the Huawei recovery image that allowed root privilege code execution to be achieved by remote or local attackers. After Huawei fixed the vulnerabilities we have reported, we decided to take a second look at the new and improved recovery mode update process.

This time, we managed to identify a new vulnerability in a proprietary mode called “SD-Update”, which can once again be used to achieve arbitrary code execution in the recovery mode, enabling unauthentic firmware updates, firmware downgrades to a known vulnerable version or other system modifications.
Our advisory for the vulnerability is published [here](https://labs.taszk.io/blog/post/80_update_toctou/).

The story of exploiting this vulnerability was made interesting by the fact that, since the exploit abuses wrong assumptions about the behavior of an external SD card, we needed some hardware-fu to actually be able to trigger it.
In this blog post, we describe how we went about creating “FaultyUSB” - a custom Raspberry Pi based setup that emulates a maliciously behaving USB flash drive - and exploiting this vulnerability to achieve arbitrary code execution as root!

## Huawei SD-update: Updates via SD Card

Huawei devices implement a proprietary update solution, which is identical throughout Huawei’s device lineup regardless of the employed chipset (Hisilicon, Qualcomm, Mediatek) or the used base OS (EMUI, HarmonyOS) of a device.

This common update solution has in fact many ways to apply a system update, one of them is the “SD-update”.
As its name implies, the “SD-update” method expects the update file to be stored on an external media, such as on an SD card or on an USB flash drive.
After reverse engineering how Huawei implements this mode, we have identified a logic vulnerability in the handling of the update file located on external media, where the update file gets reread between different verification phases.

While this basic vulnerability primitive is straightforward, exploitation of it presented some interesting challenges, not least of which was that we needed to develop a custom software emulation of an USB flash drive to be able to provide the recovery with different data on each read, as well as we had to identify additional gaps of the update process authentication implementation to make it possible to achieve arbitrary code execution as root in recovery mode.

## Time-of-Check to Time-of-Use

The root cause of the vulnerability lies in an unfortunate design decision of the external media update path of the recovery binary: when the user supplies the update files on a memory card or a USB mass-storage device, the recovery handles them in-place.

In bird’s-eye view the update process contains two major steps: verification of the ZIP file signature and then applying the actual system update. The problem is that the recovery binary accesses the external storage device numerous times during the update process; e.g. first it discovers the relevant update files, then reads the version and model numbers, verifies the authenticity of the archive, etc.

So in case of an legitimate update archive, once the verification succeeds, the recovery tries to read the media again to perform the actual installation.
But a malicious actor can swap the update file just between the two stages, thus the installation phase would use a different, thus unverified update archive.
In essence, we have a textbook “Time-of-Check to Time-of-Use” (ToC-ToU) vulnerability, indicating that a race condition can be introduced between the “checking” (verification) and the “using” (installation) stages.
The next step was figuring out how we could actually trigger this vulnerability in practice!

## Attacking Multiple Reads in the Recovery Binary

With an off-the-shelf USB flash drive it is very clear that by considering a specific offset, two reads without intermediate writes must result in the same data, otherwise the drive would be considered faulty.
So in terms of the update procedure this means the data-consistency is preserved: during the update for each point in time the data on the external drive matches up with what the recovery binary reads.
Consequently, as long as a legitimate USB drive is used, the design decision of using the update file in-place is functionally correct.

Now consider a “faulty” USB flash drive, which returns different data when the same offset if read twice (of course, without any writes between them).
This would break the data-consistency assumption of the update process, as it may happen that different update steps see the update file differently.

The update media is basically accessed for three distinct reasons: listing and opening files, opening the update archive as a traditional ZIP file, and reading the update archive for Android-specific signature verification.
These access types could enable different modes of exploiting this vulnerability by changing the data returned by the external media.
For example, in the case of multiple file system accesses of the same location, the `update.zip` file itself can be replaced as-is with a completely unrelated file.
Alternatively, multiple reads during the ZIP parsing can be turned into smuggling new ZIP entries inside the original archive (see the [CVE-2021-40045: Huawei Recovery Update Zip Signature Verification Bypass](https://labs.taszk.io/blog/post/75_hw_eocd_sig/) vulnerability in [UnZiploc](https://labs.taszk.io/articles/post/unziploc/)).

Accordingly, multiple kinds of exploitation goals can be set.
For example by only modifying the content of the `UPDATE.APP` file of the update archive at install time, an arbitrary set of partitions can be written with arbitrary data on the main flash.
A more generic approach is to gain code execution just before writing to flash in the `EreInstallPkg` function, by smuggling a custom `update-binary` into the ZIP file.

In the following we are going to use the approach of injecting a custom binary in order to achieve the arbitrary code execution by circumventing the update archive verification.

At this point we must mention a crucial factor: the caching behavior of the underlying Linux system and its effects on exploitability.
For readability reasons this challenge is outlined in the next section, so for now we continue with the assumption that we will be able to swap results between repeated read operations.

Sketching out the code flow of an update procedure helps understanding exactly where multiple reads can occur.
Since our [last exploit](%28https%3A//labs.taszk.io/blog/post/75_hw_eocd_sig/%29)) of Huawei’s recovery mode some changes have occured (e.g. functions got renamed), so the update flow is detailed again here for clarity.

First of all, the “SD-update” method is handled by `HuaweiUpdateNormal`, which essentially wraps the `HuaweiUpdateBase` function.
Below is an excerpt of the function call tree of `HuaweiUpdateBase`, mostly indicating the functions which interact with the update media or contain essential verification functions.

```
HuaweiUpdateBase
├── [> DoCheckUpdateVersion <]
│   ├── {> hw_ensure_path_mounted("/usb") <}
│   ├── CheckVersionInZipPkg
│   │   ├── mzFindZipEntry("SOFTWARE_VER_LIST...