---
title: CVE-2021-22555_Netfilter堆溢出提权漏洞
url: https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458477025&idx=2&sn=c1d30434d9df949a29f0acb219c1214a&chksm=b18e516b86f9d87d7ab1131d064b815b4057d53d80f43a64d033635efc6d40be4aa915335daf&scene=58&subscene=0#rd
source: 看雪学院
date: 2022-10-19
fetch_date: 2025-10-03T20:16:22.307053
---

# CVE-2021-22555_Netfilter堆溢出提权漏洞

![cover_image](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8FgPSukd6ZqsBP73HyIX8ZIfXluRPYKL7PoSZk5nZiaxAPFJtD5PGJr6ttF44JTVysD63Z1L2pEZuQ/0?wx_fmt=jpeg)

# CVE-2021-22555\_Netfilter堆溢出提权漏洞

PIG-007

看雪学苑

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8FgPSukd6ZqsBP73HyIX8ZI9TibZibUPI651pN3C8ia2icxgN5F7CXugOEuQNu5APMOmb1ABh4WHk9r9w/640?wx_fmt=jpeg)

本文为看雪论坛精华文章

看雪论坛作者ID：PIG-007

#

##

```
一

环境搭建
```

参考文章：

CVE-2021-22555 2字节堆溢出写0漏洞提权分析

*https://www.anquanke.com/post/id/254027*

或者我写的项目：

KernelAll

*https://www.anquanke.com/post/id/254027*

##

## 注：

要注意的是，在我写的项目里的CVE环境中，去掉了配置：CONFIG\_SECURITY=n，原因是在load\_msg()函数中申请msg\_msg结构体时，如下所示，会调用到security\_msg\_msg\_alloc()函数，给msg\_msg结构体中的security指针赋值，导致下面漏洞利用时读取伪造msg\_msg结构体由于检测security导致出错。

```
//v5.11.14 /ipc/msgutil.cstruct msg_msg *load_msg(const void __user *src, size_t len){    struct msg_msg *msg;    struct msg_msgseg *seg;    int err = -EFAULT;    size_t alen;     msg = alloc_msg(len);    //....    err = security_msg_msg_alloc(msg);    if (err)        goto out_err;    return msg;out_err:    free_msg(msg);    return ERR_PTR(err);}
```

而去掉了配置：CONFIG\_SECURITY=n，可以不用security指针，这样就不会出错了。

```
//v5.11.14 /include/linux/security.h#ifdef CONFIG_SECURITY//.....int security_msg_msg_alloc(struct msg_msg *msg);void security_msg_msg_free(struct msg_msg *msg);int security_msg_queue_alloc(struct kern_ipc_perm *msq);void security_msg_queue_free(struct kern_ipc_perm *msq);int security_msg_queue_associate(struct kern_ipc_perm *msq, int msqflg);int security_msg_queue_msgctl(struct kern_ipc_perm *msq, int cmd);int security_msg_queue_msgsnd(struct kern_ipc_perm *msq,                  struct msg_msg *msg, int msqflg);int security_msg_queue_msgrcv(struct kern_ipc_perm *msq, struct msg_msg *msg,                  struct task_struct *target, long type, int mode);//....#else /* CONFIG_SECURITY *///....static inline int security_msg_msg_alloc(struct msg_msg *msg){return 0;}static inline void security_msg_msg_free(struct msg_msg *msg){ } static inline int security_msg_queue_alloc(struct kern_ipc_perm *msq){return 0;} static inline void security_msg_queue_free(struct kern_ipc_perm *msq){ } static inline int security_msg_queue_associate(struct kern_ipc_perm *msq,                           int msqflg){return 0;} static inline int security_msg_queue_msgctl(struct kern_ipc_perm *msq, int cmd){return 0;} static inline int security_msg_queue_msgsnd(struct kern_ipc_perm *msq,                        struct msg_msg *msg, int msqflg){return 0;} static inline int security_msg_queue_msgrcv(struct kern_ipc_perm *msq,                        struct msg_msg *msg,                        struct task_struct *target,                        long type, int mode){return 0;}//....#endif    /* CONFIG_SECURITY */
```

但是在bsauce师傅提供的环境中有添加该配置，而security指针的值却还是为空。简单看了一下源码，如下函数链：

```
load_msg()->security_msg_msg_alloc()->lsm_msg_msg_alloc()
```

对于lsm\_msg\_msg\_alloc()函数如下定义：

```
static int lsm_msg_msg_alloc(struct msg_msg *mp){    if (blob_sizes.lbs_msg_msg == 0) {        mp->security = NULL;        return 0;    }     mp->security = kzalloc(blob_sizes.lbs_msg_msg, GFP_KERNEL);    if (mp->security == NULL)        return -ENOMEM;    return 0;}
```

可以看到这里进行相关赋值，如果满足blob\_sizes.lbs\_msg\_msg == 0那么其security指针为空，后续检测时也依据此判断不检测。而对于这个blob\_sizes.lbs\_msg\_msg不是很熟悉，可能是我的相关配置问题吧。这里为了方便，我就直接将这个配置去掉了。

此外经过实际测试，源码也可以看出来，其实security也就是一个堆地址(以0x8递增)，是不断变化的，但是如果能泄露出其中一个，那么后续检测就能都通过了。

#

#

```
二

前置知识
```

完成这个漏洞的利用还是需要一些前置知识的，刚好利用这个漏洞重新完善一下相关的知识点。

##

## **1.msg\_msg结构体---kmalloc-16至kmalloc-1024**

这个在之前也总结过，不过总结得有些错误，也不太完善，这里再好好总结一下。

参照：

【NOTES.0x08】Linux Kernel Pwn IV：通用结构体与技巧 - arttnba3's blog

*https://arttnba3.cn/2021/11/29/NOTE-0X08-LINUX-KERNEL-PWN-PART-IV/#%E5%88%86%E9%85%8D%EF%BC%88GFP-KERNEL-ACCOUNT%EF%BC%89%EF%BC%9Amsgsnd-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8*

Linux内核中利用msg\_msg结构实现任意地址读写 - 安全客，安全资讯平台 (anquanke.com)

*https://www.anquanke.com/post/id/252558*

Linux的进程间通信 - 消息队列 · Poor Zorro's Linux Book (gitbooks.io)

*https://zorro.gitbooks.io/poor-zorro-s-linux-book/content/linuxde-jin-cheng-jian-tong-xin-xiao-xi-dui-lie.html*

《Linux系统编程手册》

虽然写的是最大kmalloc-1024，但是在堆喷时，可以连续kmalloc(1024)从而获得连续的堆内存分布，这样都释放掉之后再经过回收机制就可以申请到更大的kmallo-xx了。

###

### (1)使用方法

####

#### ①创建

####

#### 首先创建queue\_id管理标志，对应于内核空间的msg\_queue管理结构。

```
//key要么使用ftok()算法生成,要么指定为IPC_PRIVATE//代表着该消息队列在内核中唯一的标识符//使用IPC_PRIVATE会生成全新的消息队列IPC对象int32_t make_queue(key_t key, int msg_flag){    int32_t result;    if ((result = msgget(key, msg_flag)) == -1)    {        perror("msgget failure");        exit(-1);    }    return result;} int queue_id = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);
```

####

#### 使用简单封装的msgget函数或者系统调用号\_\_NR\_msgget，之后保存数据的消息就会在这个queue\_id管理标志，以及内核空间的msg\_queue管理结构下进行创建。

####

#### ②数据传输

####

#### 写入消息：

####

#### 然后就可以依据queue\_id写入消息了，不同于pipe和socketpair，这个需要特定的封装函数（msgsnd/msgrcv）或者对应的系统调用（\_\_NR\_msgrcv/\_\_NR\_msgsnd）来实现。

```
typedef struct{        long mtype;        char mtext[1];}msgp; //msg_buf实际上为msgp,里面包含mtype,这个mtype在后面的堆块构造中很有用void send_msg(int msg_queue_id, void *msg_buf, size_t msg_size, int msg_flag){    if (msgsnd(msg_queue_id, msg_buf, msg_size, msg_flag) == -1)    {        perror("msgsend failure");        exit(-1);    }    return;} char queue_send_buf[0x2000];m_ts_size = 0x400-0x30;//任意指定msg *message = (msg *)queue_send_buf;message->mtype = 0;send_msg(queue_id, message, m_ts_size, 0);
```

####

#### 读取消息：

####

#### 之后即可依据queue\_id读取消息。

```
void get_msg(int msg_queue_id, void *msg_buf, size_t msg_size, long msgtyp, int msg_flag){    if (msgrcv(msg_queue_id, msg_buf, msg_size, msgtyp, msg_flag) < 0)    {        perror("msgrcv");        exit(-1);    }    return;} char queue_recv_buf[0x2000];m_ts_size = 0x400-0x30;//任意指定get_msg(queue_id, queue_recv_buf, m_ts_size, 0, IPC_NOWAIT | MSG_COPY);
```

####

#### mtype

####

#### 可通过设置该值来实现不同顺序的消息读取，在之后的堆块构造中很有用。

####

#### 在写入消息时，指定mtype，后续接收消息时可以依据此mtype来进行非顺序接收。

####

#### 在读取消息时，指定msgtyp，分为如下情况：

#### msgtyp大于0：那么在find\_msg函数中，就会将遍历寻找消息队列里的第一条等于msgtyp的消息，然后进行后续操作。

#### msgtyp等于0：即类似于顺序读取，find\_msg函数会直接获取到消息队列首个消息。

#### msgtyp小于0：会将等待的消息当成优先队列来处理，mtype的值越小，其优先级越高。

####

#### msg\_flag

可以关注一下MSG\_NOERROR标志位，比如说msg\_flag没有设置MSG\_NOERROR的时候，那么情况如下：

假定获取消息时输入的长度m\_ts\_size为0x200，且这个长度大于通过find\_msg()函数获取到的消息长度0x200，则可以顺利读取，如果该长度小于获取到的消息长度0x200，则会出现如下错误。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GO396vFaljRjhzsaUe9ibXx8rJS4MuAypotwKjquoJDezTFpZq8Bc3KzRXV8rVOMmbSMn7Siad7wrQ/640?wx_fmt=png)

但是如果设置了MSG\_NOERROR，那么即使传入接收消息的长度小于获取到的消息长度，仍然可以顺利获取，但是多余的消息会被截断，相关内存还是会被释放，这个在源代码中也有所体现。

```
//v5.11 /ipc/msg.c do_msgrcv函数中if ((bufsz < msg->m_ts) && !(msgflg & MSG_NOERROR)) {    msg = ERR_PTR(-E2BIG);    goto out_unlock0;}
```

此外还有更多的msg\_flag，就不一一举例了。

####

#### ③释放

这个主要是用到msgctl封装函数或者\_\_NR\_msgctl系统调用，直接释放掉所有的消息结构，包括申请的msg\_queue的结构。

```
//其中IPC_RMID这个cmd命令代表释放掉该消息队列的所有消息,各种内存结构体等if(msgctl(queue_id,IPC_RMID,NULL)==-1){    perror("msgctl");    exit(-1);}
```

不过一般也用不到，可能某些合并obj的情况能用到?

此外还有更多的cmd命令，常用来设置内核空间的msg\_queue结构上的相关数据，不过多介绍了。

####

#### 总结

总结一下大致的使用方法如下：

```
typedef struct{        long mtype;        char mtext[1];}msgp; int32_t make_queue(key_t key, int msg_flag){    int32_t result;    if ((result = msgget(key, msg_flag)) == -1)    {        perror("msgget failure");        exit(-1);    }    return result;}   void get_msg(int msg_queue_id, void *msg_buf, size_t msg_size, long msgtyp, int msg_flag){    if (msgrcv(msg_queue_id, msg_buf, msg_size, msgtyp, msg_flag) < 0)    {        perror("msgrcv");        exit(-1);    }    return;} void send_msg(int msg_queue_id, void *msg_buf, size_t msg_size, int msg_flag){    if (msgsnd(msg_queue_id, msg_buf, msg_size, msg_flag) == -1)    {        perror("msgsend failure");        exit(-1);    }    return;}  int main(){    int queue_id, m_ts_size;    char queue_recv_buf[0x2000];    char queue_send_buf[0x2000];     m_ts_size = 0x400-0x30;    msgp *message = (msgp *)queue_send_buf;    message->mtype = 0;     memset(message->mtext,'\xaa...