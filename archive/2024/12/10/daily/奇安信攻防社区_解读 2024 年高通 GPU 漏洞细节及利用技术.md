---
title: 解读 2024 年高通 GPU 漏洞细节及利用技术
url: https://forum.butian.net/share/3936
source: 奇安信攻防社区
date: 2024-12-10
fetch_date: 2025-10-06T19:33:40.285790
---

# 解读 2024 年高通 GPU 漏洞细节及利用技术

#

[问答](https://forum.butian.net/questions)

*发起*

* [提问](https://forum.butian.net/question/create)
* [文章](https://forum.butian.net/share/create)

[攻防](https://forum.butian.net/community)
[活动](https://forum.butian.net/movable)

Toggle navigation

* [首页 (current)](https://forum.butian.net)
* [问答](https://forum.butian.net/questions)
* [商城](https://forum.butian.net/shop)
* [实战攻防技术](https://forum.butian.net/community)
* [漏洞分析与复现](https://forum.butian.net/articles)
  NEW
* [活动](https://forum.butian.net/movable)
* [摸鱼办](https://forum.butian.net/questions/Play)

搜索

* [登录](https://forum.butian.net/login)
* [注册](https://user.skyeye.qianxin.com/user/register?next=http://forum.butian.net/btlogin)

### 解读 2024 年高通 GPU 漏洞细节及利用技术

本文主要分析 2024 年高通 GPU 上的一些漏洞细节
CVE-2024-23380
与 Mali 类似高通的 GPU 驱动使用 kgsl\_mem\_entry 和 kgsl\_memdesc 结构体来管理物理页
kgsl\_mem\_entry 对象分配的逻辑位于 kg...

本文主要分析 2024 年高通 GPU 上的一些漏洞细节
CVE-2024-23380
--------------
与 Mali 类似高通的 GPU 驱动使用 kgsl\\_mem\\_entry 和 kgsl\\_memdesc 结构体来管理物理页
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/11/attach-ef9f8ca2b3c07ef2850b82a19e8b9745b3f4bf22.png)
kgsl\\_mem\\_entry 对象分配的逻辑位于 kgsl\\_ioctl\\_gpuobj\\_alloc 接口：
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/11/attach-7afc0ddb70e3510060ef5591ea02607f69dddd60.png)
大体逻辑是通过 kgsl\\_allocate\\_user 给 kgsl\\_memdesc 分配物理页，然后调用 kgsl\\_mem\\_entry\\_attach\\_and\\_map 将其映射到 GPU 侧，如果用户态进程也需要映射则需要通过驱动的 mmap 回调
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/11/attach-787d5906efb0ebfb3b8ec85ef49536b74ac98b93.png)
kgsl\\_mem\\_entry 的释放则是位于 kgsl\\_ioctl\\_gpuobj\\_free 接口：
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/11/attach-0fc1c57c4659dcb20187b4a305adf142d947111e.png)
通过分析释放流程可知 entry 对象使用引用计数来管理生命周期（refcount​ 成员），当引用计数为 0 时进入 kgsl\\_mem\\_entry\\_destroy 首先需要解除 entry 中的相关物理页映射，然后才能释放物理页和 entry 对象本身，和物理页相关（kgsl\\_memdesc​）的释放逻辑位于 kgsl\\_sharedmem\\_free
```c
void kgsl\_sharedmem\_free(struct kgsl\_memdesc \*memdesc)
{
if (!memdesc || !memdesc->size)
return;
/\* Assume if no operations were specified something went bad early \*/
if (!memdesc->ops)
return;
if (memdesc->ops->put\_gpuaddr)
memdesc->ops->put\_gpuaddr(memdesc); // 接触 GPU 页表映射
if (memdesc->ops->free)
memdesc->ops->free(memdesc); // 释放 memdesc 中的物理页内存
}
```
memdesc-&gt;ops 目前有多种定义，不同的内存类型会有其对应的回调函数
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/11/attach-2a8ad96c4740de5181de3fbf2434029a2748e888.png)
以 kgsl\\_page\\_ops 为例，该类型的 memdesc 的物理页是通过 alloc\\_page 分配，然后映射的
```python
static const struct kgsl\_memdesc\_ops kgsl\_page\_ops = {
.free = kgsl\_free\_pages,
.vmflags = VM\_DONTDUMP | VM\_DONTEXPAND | VM\_DONTCOPY | VM\_MIXEDMAP,
.vmfault = kgsl\_paged\_vmfault,
.map\_kernel = kgsl\_paged\_map\_kernel,
.unmap\_kernel = kgsl\_paged\_unmap\_kernel,
.put\_gpuaddr = kgsl\_unmap\_and\_put\_gpuaddr,
};
```
kgsl\\_sharedmem\\_free 销毁 memdesc 中的资源时会先调用 put\\_gpuaddr 接触页表映射
```python
void kgsl\_unmap\_and\_put\_gpuaddr(struct kgsl\_memdesc \*memdesc)
{
if (!kgsl\_memdesc\_is\_reclaimed(memdesc) &&
kgsl\_mmu\_unmap(memdesc->pagetable, memdesc)) // 清理页表项
return;
kgsl\_mmu\_put\_gpuaddr(memdesc->pagetable, memdesc); // 清理页表管理结构 pagetable 中的对象
}
```
然后在 free 回调里面释放物理页资源
```python
static void kgsl\_free\_pages(struct kgsl\_memdesc \*memdesc)
{
kgsl\_paged\_unmap\_kernel(memdesc);
WARN\_ON(memdesc->hostptr);
if (memdesc->priv & KGSL\_MEMDESC\_MAPPED)
return;
atomic\_long\_sub(memdesc->size, &kgsl\_driver.stats.page\_alloc);
\_kgsl\_free\_pages(memdesc, memdesc->page\_count);
memdesc->page\_count = 0;
kvfree(memdesc->pages);
memdesc->pages = NULL;
}
```
大概了解高通 GPU 内存分配后，下面进入漏洞相关逻辑，分析 [patch commit](https://git.codelinaro.org/clo/la/platform/vendor/qcom/opensource/graphics-kernel/-/commit/919306871384731b35cbfafb208bbd13bff08605) 可以漏洞出现在处理 VBO 内存映射时
```python
Currently, VBO buffers are mapped after releasing the target memdesc's mutex lock.
This could introduce a race which can lead to use after free of VBO buffers.
Thus, map VBO buffers inside mutex lock.
```
VBO 分配相关的代码如下：
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/11/attach-22a9f2465ee7580ffa333e9a3657c9920bd5062e.png)
可以看到分配 VBO 内存区域过程中没有分配物理页，只是分配了 GPU VA 并将这些 VA 都映射为 零页（类似Linx内核的 零页）
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/11/attach-8a12f8ec878b540f40f331efde88181631d13b10.png)
VBO 内存区域分配后需要使用 kgsl\\_ioctl\\_gpumem\\_bind\\_ranges 将其他 kgsl\\_mem\\_entry 的内存映射到 VBO 的 VA 范围，关键代码如下：
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/11/attach-bf02b6eca9dabb382f49ed138d862668c75ed05e.png)
大致思路是先找到要映射内存的 VBO entry （op-&gt;target​），然后找到所有被绑定的 entry(op-&gt;ops\[i\].entry​)，最后启动内核 work 线程进入 kgsl\\_sharedmem\\_bind\\_worker 处理.
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/11/attach-7a45a42f30ff2513fa3a287ab0415f542ace0ee5.png)
> 图示展示 VBO entry 映射其他 kgsl\\_mem\\_entry 的物理页的情况，映射过程通过获取 op-&gt;ops\[i\].entry 的引用计数来确保物理内存不被释放
此外通过前面的代码可知 kgsl\\_sharedmem\\_bind\\_worker 运行在内核 work 线程中，所以同时可能会有多个内核线程在 kgsl\\_sharedmem\\_bind\\_worker 函数，本节的漏洞正是因为多线程竞争导致的 UAF。
kgsl\\_memdesc\\_add\\_range 负责在 vbo entry 里面增加一个映射，核心代码如下：
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/11/attach-82ce76a45a98aed5672c2bf6f526f44638d073d7.png)
大概逻辑是先分配 range 用户存放映射的信息，比如地址信息、引用的 entry 等，然后把 \[start, last\] VA 处原有的映射 unmap，最后调用 kgsl\\_mmu\\_map\\_child 操作 GPU 页表映射 entry-&gt;memdesc 中的物理页
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/11/attach-14b4efae38c1097e2413b21f80cf2579318e52b1.png)
再看一下 kgsl\\_memdesc\\_remove\\_range 的逻辑：
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/11/attach-5e7ddc58e3c08bbafebcde4258b4b7e414fafd3b.png)
核心思路就是会先清理 range 在 GPU 侧的映射，然后释放 range-&gt;entry 的引用，最后释放 range.
漏洞点在 kgsl\\_memdesc\\_add\\_range 他会在释放锁之后调用 kgsl\\_mmu\\_map\\_child 映射物理页到 GPU 页表
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/11/attach-43ebce867a366be5b09ca04a1948586b6cfc3689.png)
但这个时候其他线程可以并发调用 kgsl\\_memdesc\\_remove\\_range 提前走释放流程，这样等到真实释放时就会导致页表没有清理，从而物理页 UAF
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/11/attach-ca8cd81d4e5cbbab6dff0dfbb58098822ada5e1a.png)
当 kgsl\\_memdesc\\_add\\_range 线程执行完 1 后，kgsl\\_memdesc\\_remove\\_range 线程执行 尝试解映射并释放 range-&gt;entry 的引用，最后执行 3 将 entry 的物理页插入 GPU 的页表。
之后由于 vbo entry 已经不持有刚刚映射的 range-&gt;entry 引用计数，可以通过 kgsl\\_ioctl\\_gpuobj\\_free 释放，这条路径释放不会去清理 vbo entry 的页表导致物理页 UAF。（VBO的页表清理在 kgsl\\_memdesc\\_remove\\_range 执行）
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/11/attach-3b17db4e9cc8cea0ca5dc377f5523d8866be2183.png)
由于该对象通过 kmalloc 分配，对于高通 GPU 手机来说其他内核漏洞也可以通过 篡改 kgsl\\_mem\\_entry 对象的 refcount 或者 memdesc 来将漏洞转换为 GPU 漏洞进行利用。
```c
static struct kgsl\_mem\_entry \*kgsl\_mem\_entry\_create(void)
{
struct kgsl\_mem\_entry \*entry = kzalloc(sizeof(\*entry), GFP\_KERNEL);
if (entry != NULL) {
kref\_init(&entry->refcount);
kref\_get(&entry->refcount);
atomic\_set(&entry->map\_count, 0);
}
return entry;
}
```
CVE-2023-33107
--------------
因为后面介绍的漏洞，或多或少和这个漏洞有点关联，这里先介绍一下这个非常精妙的漏洞利用，这是 [Google's Project Zero](https://googleprojectzero.github.io/0days-in-the-wild//0day-RCAs/2023/CVE-2023-33107.html) 抓到的在野利用。
漏洞是 kgsl\\_iommu\\_set\\_svm\\_region 里面对地址的校验存在整数溢出，会导致重叠映射区存在，进而导致页表映射时出错，最终会导致物理页UAF，整个漏洞触发过程非常依赖驱动的逻辑，下面具体介绍。
首先漏洞位于 iommu\\_addr\\_in\\_svm\\_ranges 函数，相关补丁如下：
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/11/attach-ea8c011e466931ecacb2745f9a27e6e8513c98f8.png)
当 gpuaddr + size 发生整数溢出时 gpuaddr + size &lt; gpuaddr ，此时只要 gpuaddr 在 pt-&gt;svm\\_start 和 pt-&gt;svm\\_end 之间就能通过上述检查，该函数的调用路径如下：
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/11/attach-442a6cc0a22b0e48d1c2528ed1d4ad590f61eb96.png)
该路径的目标就是把用户态进程的物理页导入到 GPU 中供其使用，还有一点是 驱动使用 pagetable-&gt;rbtree 红黑树来记录目前在 GPU 侧已经分配的 VA.
kgsl\\_ioctl\\_gpuobj\\_import 的大概逻辑是通过 \\_gpuobj\\_map\\_useraddr 获取用户态 VA 对应的物理页并分配 GPU VA （插入到 pagetable-&gt;rbtree），然后调用 kgsl\\_mem\\_entry\\_attach\...