---
title: 在 EDR 时代恶意软件通过虚拟化逃避终端检测
url: https://forum.butian.net/share/3825
source: 奇安信攻防社区
date: 2024-10-31
fetch_date: 2025-10-06T18:49:28.219452
---

# 在 EDR 时代恶意软件通过虚拟化逃避终端检测

#

[问答](https://forum.butian.net/questions)

*发起*

* [提问](https://forum.butian.net/question/create)
* [文章](https://forum.butian.net/share/create)

[攻防](https://forum.butian.net/community)
[活动](https://forum.butian.net/movable)

Toggle navigation

* [首页 (current)](https://forum.butian.net)
* [问答](https://forum.butian.net/questions)
* [商城](https://forum.butian.net/shop)
* [实战攻防技术](https://forum.butian.net/community)
* [漏洞分析与复现](https://forum.butian.net/articles)
  NEW
* [活动](https://forum.butian.net/movable)
* [摸鱼办](https://forum.butian.net/questions/Play)

搜索

* [登录](https://forum.butian.net/login)
* [注册](https://user.skyeye.qianxin.com/user/register?next=http://forum.butian.net/btlogin)

### 在 EDR 时代恶意软件通过虚拟化逃避终端检测

* [渗透测试](https://forum.butian.net/topic/47)

本博客文章回顾了一种逃避工具的演变，旨在在红队合作中协助有效载荷传递。我们将涉及该工具的历史以及在进攻和防御进展面前的未来潜力。

介绍
==
- - - - - -
随着防御性安全产品的改进，攻击者必须不断完善他们的技术。执行恶意二进制文件的时代已经过去，尤其是那些被杀毒软件和终端检测与响应（EDR）供应商熟知的二进制文件。现在，攻击者专注于对内存中的有效载荷进行执行，以逃避防御产品的检测，无论是本地应用程序还是托管应用程序。与此同时，防御技术变得越来越复杂，这迫使攻击者进一步适应。在这种军备竞赛的时代，攻击者如何保持领先？恶意软件如何能够未雨绸缪，以逃避当前存在并正在积极开发的复杂 EDR 系统？
本博客文章回顾了一种逃避工具的演变，旨在在红队合作中协助有效载荷传递。我们将涉及该工具的历史以及在进攻和防御进展面前的未来潜力。
历史视角
====
- - - - - -
恶意软件和反恶意软件之间的军备竞赛的核心如下：反恶意软件必须在一组约束条件下将任意程序分类为良性或恶意，无论是在内存中还是静止状态下。产品受到用户或客户愿意在 CPU 时间、内存或带宽方面放弃的性能量的限制，以及产品生成的误报数量的限制。如果产品消耗资源过多，客户会抱怨速度慢。如果隔离重要文件，可能会带来更多害处。这些约束塑造并限制了反恶意软件产品演进中的每一步。编写工具时，不仅杀毒软件供应商需要担心性能。恶意软件作者在部署恶意软件时也需要考虑执行速度或其他系统变化。例如，最近发现的 XZ 后门是由一名软件工程师发现的，因为登录时间从 0.2 秒增加到 0.8 秒。 如果这段代码的作者没有明显改变系统的行为，后门很可能会成功部署。
自软盘上流传病毒的早期，编写未被检测出的恶意软件一直是攻击者和防御者之间的一场猫鼠游戏。最初，杀毒软件严格专注于基于程序指令中的签名和模式的病毒的真阳性检测。在签名数据库中没有错误的情况下，唯一的签名匹配保证了恶意样本的真阳性匹配，之后恶意文件可以被删除或隔离。这种检测方法严格遵守对抗恶意软件产品的限制，因为简单的模式匹配是高效的，真阳性检测几乎是有保证的。
对于恶意软件作者来说，解决方案很简单：为了规避检测，病毒必须通过独特模式变得不可能被检测到。这可以通过改变代码或者在运行时加密代码然后解密来实现。如果自动化这个过程，就会得到所谓的打包工具：一种工具，用于加密、压缩或以其他方式改变病毒以规避检测。打包工具会改变病毒中的大部分代码并向代码中添加一个存根。这个存根通常是程序启动时执行的第一段代码。它的作用是撤销先前对原始代码所做的所有更改（例如压缩或加密）。在所有更改被撤销后，执行将传递给原始代码。这个存根还可以利用反逆向/防篡改，试图保护原始代码免受窥探。
这减少了磁盘上或其他存储在静止状态的样本创建签名的“攻击面”数量。这种方法还用于压缩二进制文件以进行分发，从而允许更小的发布包。因此，并非所有压缩的二进制文件都可以标记为恶意。
然而，即使是非常小的解包程序存根也可能与一个可以唯一与打包程序本身相关联的签名匹配。将此签名与一些与文件中熵量相关的规则相结合，打包程序仍然可以被高度准确地检测到。在这一点上，反恶意软件解决方案已经发展到利用有关文件的元数据，如熵，获得检测打包文件的能力，但代价是更高的误报率。
恶意软件作者在军备竞赛中的下一步是消除解包器存根中的签名匹配潜力。这意味着存根必须在创建新样本时每次由不同指令组成。一个重要的见解是，“代码的功能”和“代码的外观”并非一一对应。编写计算机代码以实现特定效果或结果有无限多种方式。因此，特定解包算法可以编写无限多种方式。设计用于创建每次外观不同的解包存根的打包器可以称为多态的。执行更改的算法或代码称为多态引擎。
将打包程序与多态引擎结合起来，可以消除对静态恶意软件简单签名匹配的“攻击面”。自 2015 年以来，作者编写并维护了两个类似的多态打包程序。尽管它们仍然对现代 EDR 产生良好的效果，但即使是这些工具也越来越难以绕过防御。这是因为多态打包程序存在一个概念性缺陷：原始恶意代码在某个时刻仍然会被解密以执行。如果反恶意软件产品能够在打包程序完成解码恶意代码时计时开始扫描恶意模式，那么检测恶意软件将再次变得容易。
现代操作系统和处理器试图确保计算机内存中的所有数据都不能作为代码执行，以确保安全性。特别是，系统通常设计为防止从可写页面执行代码。因此，想要解密或解压缩自己的代码的病毒或恶意软件样本必须首先在可写内存页面中进行更改。然后，病毒将页面保护更改为可读和可执行，并将控制权转移到新修改的可执行内存。配备分析运行时其他程序行为的防恶意软件产品利用这样的行为模式来决定何时扫描进程的内存以查找恶意模式。因为一旦解密，内存就不能再更改，由于前述限制，扫描进程在使内存可执行后是发现恶意模式的理想时机。
配备规则以生成额外信号以确定程序是否恶意的反恶意软件产品被称为使用“启发式”。 从概念上讲，反恶意软件产品已经实现了一套全面的功能来检测恶意软件执行。 自这些功能完整产品的早期以来，我们看到的演变都可以理解为试图放松或解除上述约束的尝试：“基于云的保护”在他人的计算机上运行资源密集型的启发式; 添加人类监督，“EDR”中的“R”降低了误报的影响，并将人类引入检测和响应循环。
然后，红队如何能够将他们的恶意软件成功地绕过这些新的和先进的防御措施呢？在过去，病毒作者可能会使用所谓的“变形”引擎。这是一个旨在每次感染新文件时重新编写整个病毒的算法，包括整个变形引擎本身。使用它可以确保没有一个“真正”的病毒样本可以通过静态签名检测到；每个病毒副本都是完全不同的。有了这样的工具，您就不需要一个打包程序，因为没有静态模式可以唯一地与您的病毒联系起来。然而，现代软件复杂性的爆炸式增长以及恶意软件需要在多种系统上运行的要求，给这种方法带来了挑战。
逃避分析：虚拟化
========
- - - - - -
为了隐藏有效载荷的静态和动态分析，生成的样本必须能够抵抗代码检查和代码流分析。如果真实指令没有向观察者透露，几乎无法从外壳中得出任何结论。如果这一点得以实现，防御产品在检查有效载荷时将面临以下限制：
- 难以观察指令模式；
- 难以修补指令；
- 难以忽略指令；
- 难以预测行为。
隐藏指令并不是什么新鲜事。像VMProtect这样的产品通过嵌入虚拟机并生成在此虚拟机上执行的独特指令来掩盖代码的部分内容。要虚拟化的代码必须通过源代码中添加的标记或包含符号的PDB文件的存在来识别。这一要求在使用第三方工具时并不总是能够满足。此外，这种类型的保护旨在保护特定功能，例如许可证密钥检查算法，这限制了对手的使用。最后，使用现有工具可能会对检测率产生负面影响，因为这些产品经过大量研究，可能包含硬编码的节名等静态签名。
然而，考虑到虚拟化层的好处，很明显，这项技术非常强大。
创建自定义虚拟化层
=========
- - - - - -
决定创建一个虚拟化层。该层由实现操作码的虚拟机组成，以及在虚拟机上执行的字节码。将要创建的虚拟化层必须符合以下要求和限制：
1. 字节码指令按顺序执行;
2. 字节码指令在执行前后被隐藏;
3. 指令集仅支持基本的 x86-64 指令；
4. 虚拟机必须提供一个接口给系统 API；
5. 虚拟机实现必须简单且位置无关，以支持变形；
6. 虚拟化层必须在没有访问源代码或调试符号的情况下工作。
创建虚拟化层始于要执行的指令、虚拟机和支持的指令集的设计。此外，创建了最终有效负载的布局，其中所有数据必须以位置无关格式存在，并且可以像 shellcode 一样执行。这使得有效负载可以嵌入到其他可执行格式（例如可执行文件或 DLL）中，并且在分阶段恶意软件时允许动态执行。
例如，以下布局将允许上述功能。在这个例子中，虚拟机必须以一个修正存根开始，该存根正确地设置虚拟机参数寄存器为它们各自的值：
| ![](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/09/attach-51d85ac4b602d790f31872038b7588655ed38f8e.png) |
|---|
| 包含位置独立代码内所有必需构建块的数据结构示例 |
一条指令的解剖
=======
- - - - - -
为了保持虚拟机架构简单，创建了一个指令格式，使指令和操作数类型之间的长度保持一致。这种设计决定允许省略长度反汇编引擎（LDE），并且可以简单地使用指令指针作为当前指令的索引。必须包含在正常的非 SSE/AVX x86 指令中的所有信息。
在其核心，指令确定必须执行的操作，以及可选地以操作数形式提供的数据。操作数可以是三种类型之一：
1. \*\*立即数\*\*：嵌入指令中的常数值；
2. \*\*内存位置\*\*：指令指向的内存位置；
3. \*\*寄存器\*\*：由指令识别的寄存器或其部分。
为了从操作数中获取数据，必须创建一个通用格式，该格式涵盖不同的操作数类型。决定使用单个 64 位字段来保存不同类型的操作数，因为前述类型的所有必要数据都可以嵌入到 64 位中。
下面的结构显示了每种操作数类型的布局：
`struct ImmediateOperand {  Value value;           // 常数值 }; // 大小：8字节 struct MemoryOperand {  uint8\_t size;          // 操作数的有效大小（8, 16, 32, 64位）  uint8\_t base;          // 存储基地址指针值的寄存器  uint8\_t index;         // 存储数组索引的寄存器  uint8\_t scale;         // 1, 2, 4 或 8 的常量乘数  int32\_t displacement;  // 被加到计算地址上的值 }; // 大小：8字节 struct RegisterOperand {  uint8\_t reg;           // x86-64寄存器集中的基础寄存器  uint8\_t chunk;         // 特定的寄存器部分：低位，高位，字，双字，四字  uint16\_t size;         // 操作数的有效大小（8, 16, 32, 64位）  uint32\_t pad;          // 用于满足64位大小要求的填充 }; // 大小：8字节 union Operand {  ImmediateOperand imm;  // 将数据视为立即数操作数  MemoryOperand    mem;  // 将数据视为内存操作数  RegisterOperand  reg;  // 将数据视为寄存器操作数 }; // 大小：8字节`
注意：立即操作数的值类型是一个简单的联合体，包含了从(uint8\\_t)到(uint64\\_t)成员。这使得在实现操作码时索引正确的数据变得非常简单。
为了指示指令的“操作码”，可以使用单个 1 字节值。这提供了 256 个独特的操作码，应该足以实现基本行为。最后，每个操作数的类型必须嵌入在指令格式中，因为操作码实现必须能够查询这些类型。
`struct Instruction {     uint8\_t opcode;             // 指令的操作码     uint8\_t lparam\_type : 4;    // 第一个（左）操作数的类型     uint8\_t rparam\_type : 4;    // 第二个（右）操作数的类型     Operand lparam;             // 第一个（左）操作数     Operand rparam;             // 第二个（右）操作数 }; // 大小：18 字节`
保护说明
====
- - - - - -
为了满足要求二，“`字节码指令在执行前后被隐藏`”，指令使用加密进行保护。许多加密算法可以用来隐藏指令。然而，指令的大小需要保持不变，因为指令将在原地解密和加密，不会被移动到临时缓冲区。这消除了虚拟机内部动态内存分配的必要性。此外，所选的加密方案必须易于实现，因为代码将位于虚拟机中，从而为签名检测创建一个“攻击面”。实现复杂算法会损害使用多态引擎有效操纵代码的能力。
虚拟机的解剖
======
- - - - - -
虚拟机类似于虚拟 CPU，实现了所有可用的操作码。此外，可用的寄存器、CPU 标志和堆栈都是虚拟机对象的一部分。最后，虚拟机保存了指向执行所需的字节码缓冲区的指针。实现虚拟机的一个附加好处是真实堆栈也被抽象化了。试图从堆栈中识别恶意行为的启发式方法将不会成功。
`struct Context {     uint32\_t            ip;                 // 指令指针     uint8\_t             flags;              // 要由操作码操作的CPU标志     Register            registers[17];      // 通用寄存器（rax, … r15 和 gs）     Instruction\*        instructions;       // 指向字节码缓冲区开头的指针     uint8\_t             stack[STACK\_SIZE];  // 虚拟机堆栈 };`
初始化虚拟机上下文的功能，获取当前指令，并根据指令操作数加载和存储值的功能被创建，以帮助实现虚拟机内的操作码。
一旦初始化，虚拟机可以进入其调度循环。该循环包括获取当前指令并执行指令对象中的操作码字段标识的操作码。在执行之前对指令进行解密，执行后进行加密。调度函数可以实现如下：
`void dispatch\_instruction(Context\* vm) {     uint32\_t ip = vm->ip;     decrypt\_instruction(vm, ip);     switch (vm->instructions[ip].opcode) {     case Opcode::ADD: opcode\_add(vm); next\_instruction(vm); break;     case Opcode::AND: opcode\_and(vm); next\_instruction(vm); break;     case Opcode::BT:  opcode\_bt(vm);  next\_instruction(vm); break;     …     }     encrypt\_instruction(vm, ip); }`
一个细心的读者可能已经注意到临时变量`ip`的构造，它在进一步的操作中被使用。这源于任何修改指令指针的指令，比如`jcc`、`call`和`ret`，在操作码完成时会导致指令指针被修改。因此，指令指针不能再用于重新加密已执行的原始指令。
实施基本操作码
=======
- - - - - -
以下函数实现了位测试（`bt`）操作码:
`void opcode\_bt(Context\* vm) {  // get the current instruction from the context  Instruction\* i = get\_current\_instruction(vm);  // load the value and the bit to test  Value dst = fetch\_value(vm, i->lparam\_type, i->lparam);  Value src = fetch\_value(vm, i->rparam\_type, i->rparam);  // get the size in bits of the value to check  size\_t size = get\_operand\_size(i->lparam\_type, i->lparam);  // set the carry flag to the result of the bit test  switch (size) {  case 8:  vm->flags.cf = (dst.u8 & (1 << src.u8))      != 0; break;  case 16: vm->flags.cf = (dst.u16 & (1 << src.u16))    != 0; break;  case 32: vm->flags.cf = (dst.u32 & (1 << src.u32))    != 0; break;  case 64: vm->flags.cf = (dst.u64 & (1ull << src.u64)) != 0; break;  } }`
改进字节码处理：转译
==========
- - - - - -
最初，所有在虚拟环境中执行的字节码都是手工用汇编语言编写的。这提供了所需的控制，以确保使用特定的操作码和操作数类型，并且作为测试，实现了一个字节码中的 PE 加载程序。由于这...