---
title: CVE-2023-41112: Samsung Baseband RLC Data Re-Assembly Heap Buffer Overflow
url: https://labs.taszk.io/blog/post/94_rlc_heap_bof/
source: Taszk Labs on taszk.io labs
date: 2024-07-30
fetch_date: 2025-10-06T17:47:18.624258
---

# CVE-2023-41112: Samsung Baseband RLC Data Re-Assembly Heap Buffer Overflow

[![logo](https://labs.taszk.io/images/taszk_logo.png)
![logo](https://labs.taszk.io/images/taszk_logo_white.png)](https://labs.taszk.io)

* [Home](https://labs.taszk.io/)
* [Articles](https://labs.taszk.io/articles)
* [Advisories](https://labs.taszk.io/blog)
* [Get in touch](https://taszk.io/contact)

## [CVE-2023-41112: Samsung Baseband RLC Data Re-Assembly Heap Buffer Overflow](https://labs.taszk.io/blog/post/94_rlc_heap_bof/)

2024-07-29
 by Daniel Komaromy
 [Samsung](/blog/tags/samsung) [baseband](/blog/tags/baseband)

We have identified several new heap buffer overflow vulnerabilities in Samsung’s baseband implementation (mainly used in Exynos chipsets): three different heap buffer overflows in the same function, to be precise.

The most critical of these vulnerabilities can be exploited to achieve arbitrary code execution in the baseband runtime.

The vulnerabilities we are disclosing in this advisory affected a wide range of Samsung devices, including phones on the newest Exynos chipsets. The vulnerability report covering all three that we reported together was assigned CVE-2023-41112, which was published in the 2023 November issue of Samsung Semiconductor Security Bulletin.

# Vulnerability Details

## Background: RLC Data Block Formats in GPRS vs E-GPRS

In GPRS, an LLC layer PDU can be up to 1560 bytes long, but the maximum size for an RLC data block is between 22 and 52 bytes for GPRS, depending on the Coding Scheme used (22/32/38/52 for the GPRS coding schemes CS-1/2/3/4, respectively).

While the GPRS RLC data block format is defined in 10.0a.1 and 10.2 of 44.060, the E-GPRS RLC data block format is defined in 10.0a.2 and 10.3a. E-GPRS uses different coding schemes (MCS1-9 instead of CS1-4) and accordingly, the data block formats are different and together with that, the segmentation and re-assembly procedures are different as well. (Sidenote: it actually gets even more complicated, with more changed in E-GPRS2 and then E-GPRS2B, but this is not important for this vulnerability.)

The most important difference is that E-GPRS supports something called 2 block re-segmentation. (This procedure is defined in clause 9 of the same specification 44.060.) As the specification explains, the idea is to group blocks based on coding scheme formats into sizes such that the four families of EGPRS RLC data blocks C, B, A and A padding based on a common size basis (22, 28, 37 and 68 octets respectively) enable link adaptation retransmission as described in sub-clause 9.

The idea behind retransmission is that when transmission with a higher coding scheme (e.g. MCS-8) fails, then re-transmission can be attempted with the same data split into several lower coding scheme type blocks, such as MCS-6 or MCS-3. (You can see J.3 appendix of 44.060 for a concrete example.) In fact, becssue of this re-transmission procedure, E-GPRS introduces a new concept of an “E-GPRS data unit” which may span multiple RLC data blocks on the (re-transmission downgraded) coding scheme.

Due to the above, RLC data block formats and also the segmentation/re-assembly procedure details, differ for GPRS and E-GRPS.

## Background: Segment Re-Assembly in Samsung in GPRS vs E-GPRS

Precise details of fragment re-assembly in GPRS have been included in the advisory for CVE-2023-41111. For E-GRPS, we only need to consider the fact that one E-GPRS data unit may span several RLC blocks and therefore the way fragments are taken out of arriving RLC data blocks is different for E-GPRS. In fact, it is possible to save multiple fragments of a given LLC PDU when processing a single arriving E-GPRS data unit.

For this reason, the fragment saving logic for E-GPRS RLC data units in the Samsung code differs from how LLC PDU fragments extracted from GPRS RLC data blocks are saved. Despite these differences, however, the Samsung implementation uses shared code between GPRS and E-GPRS for much of the procedure: the same `RLC_handle_DATA_IND`, `RLC_DecodeDLData`, and `RLC_addPDUFragm` functions described in our advisory for CVE-2024-41111 are used when parsing the headers and storing fragments respectively, the only difference in code flow path is the usage of `RLC_DecodeDLDataGPRS` vs `RLC_DecodeDLDataEGPRS` for deciding what fragments to store (extract from an RLC data block), when to store fragments, and when to trigger concatenation. In the end, also the same one function, that we labeled `rlc_DLPduConcatenate`, handles LLC PDU re-assembly for both GPRS and E-GPRS. So the code flows for GPRS and E-GPRS respectively are:

* `RLC_handle_DATA_IND` -> `RLC_DecodeDLData` -> `RLC_DecodeDLDataGPRS` -> `RLC_addPDUFragm` and/or `rlc_DLPduConcatenate`
* `RLC_handle_DATA_IND` -> `RLC_DecodeDLData` -> `RLC_DecodeDLDataEGPRS` -> `RLC_addPDUFragm` and/or `rlc_DLPduConcatenate`

In the case of `RLC_addPDUFragm`, we can see that, unlike the GPRS case, an additional array of E-GPRS fragments may also be collected, when this function is reached via `RLC_DecodeDLDataEGPRS` as opposed to `RLC_DecodeDLDataGPRS`.

```
void RLC_addPDUFragm(uint sim,int bsn,big_ctx *ctx,rlc_fragms_desc *fragm_desc)

{

  /* E-GPRS */
  if (ctx->rlc_type[bsn] == 5) {
    fragm_desc->fragms[index] = ctx->rlc_ptrs[bsn];
    fragm_desc->egprs_plus_fragms[index] = (int)ctx->rlc_egprs_ptrs[bsn];
    ctx->rlc_egprs_ptrs[bsn] = (rlcmac_struct *)0x0;
    ctx->rlc_ptrs[bsn] = (rlcmac_struct *)0x0;
    dStack_30.val = sim * 0x40000 + 0x40000 | 0x3e1;
                    /*  State : VN_FIRST_OK_SECOND_OK bsn %d index %d rx_void_ptr is set to NULL  */
    dStack_30.ptr = &dbt_msg_434d1f18;
    pal_dbgLog(&dStack_30,bsn,index,&SUB_fecdba98);
  }
  /* GPRS */
  else {
    (...)
 }

  fragm_desc->block_offs[index] = ctx->rlc_offset[bsn];

  fragm_desc->block_sizes[index] = ctx->rlc_lens[bsn];
  fragm_desc->is_alloced_fragm[index] = ctx->rlc_allocated[bsn];

  /*  n_blks number of fragments increase - no check! OVERFLOW ! */
  fragm_desc->n_blks = fragm_desc->n_blks + 1;

}
```

This difference explains the additional array (`egprs_plus_fragms`) in the fragment descriptor structure:

```
byte                state
byte                bsn
byte                LI_h_offset
char                pad
int                 pdu_len
char[79]            block_offs
char[79]            is_alloced_fragm
char                pad2
char                pad3
int[79]             block_sizes
rlcmac_struct *[79] fragms
int[79]             egprs_plus_fragms
int                 n_blks
```

Finally, in the case of both GPRS and E-GPRS, the code flow reaches `rlc_DLPduConcatenate`. This function essentially loops through each previously stored plus the last arrived fragment, concatenates the LLC PDU, and either sends it to the upper layer, or executes the RLC Loopback upstream message sending when Test Mode for RLC is enabled.

The following decompiled pseudocode shows this function, first focusing on the path when `n_blks` is > 0.

```
uint rlc_DLPduConcatenate(uint sim,int data_length,int bsn,rlc_fragms_desc *rlc_fragm_desc)

{

  (...) /* local variable defs and logging */

  pdu_alloc_ = (char *)0x0;
  max_pdu_len_remaining = rlc_fragm_desc->pdu_len;
  data_offset = (uint)rlc_fragm_desc->LI_h_offset;
  is_edge_mode = get_is_edge_mode(sim);
  rlc_ctx = RLC_get_cxt_unk_sim(sim);

  if ((int)max_pdu_len_remaining < 1561) {
    if ((int)max_pdu_len_remaining < 0) {
      (...)
      goto RETURN;
    }
    if (max_pdu_len_remaining != 0) {
      pdu_size_over_1560 = 0;
      goto PROCESS_CONCATENATION;
    }
  }
  else {

    /*
    [1] we never alloc more than 1560, if it is over 1560, we alloc to 1560 and store
    the difference in a variable

    BUGs come from the fact that this pdu_size_over_1560 variable is no actually
    taken into consideration everywhere it should be
    */

    pdu_size_over_1560 = max_pdu_len_remaining - 1560;
    rlc_fragm_desc->pdu_len = 1560;
    max_pdu_len_remaining = 1560;

PROCESS_CONCATENATION:

    pdu_alloc = (char *)pal_MemAlloc(4,max_pdu_len_re...