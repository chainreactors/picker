---
title: Chrome Browser Exploitation, Part 2: Introduction to Ignition, Sparkplug and JIT Compilation via TurboFan
url: https://jhalon.github.io/chrome-browser-exploitation-2/
source: Jack Hacks
date: 2022-11-17
fetch_date: 2025-10-03T23:03:58.159414
---

# Chrome Browser Exploitation, Part 2: Introduction to Ignition, Sparkplug and JIT Compilation via TurboFan

* [Jack Hacks](https://jhalon.github.io/)
* [Posts](https://jhalon.github.io/posts.html)
* [Categories](https://jhalon.github.io/categories.html)
* [About](https://jhalon.github.io/about.html)

# Chrome Browser Exploitation, Part 2: Introduction to Ignition, Sparkplug and JIT Compilation via TurboFan

![Jack Halon](https://jhalon.github.io/images/bio_chibi.png)

### Jack Halon

I like to break into things; both physically and virtually.

Follow

* United States
* Email
* [Twitter](https://twitter.com/jack_halon)
* [LinkedIn](https://www.linkedin.com/in/jacek-halon-683912b0)
* [Github](https://github.com/jhalon/)
* [YouTube](https://www.youtube.com/user/../JackHacks)

In my previous post “[Chrome Browser Exploitation, Part 1: Introduction to V8 and JavaScript Internals](https://jhalon.github.io/chrome-browser-exploitation-1/)”, we took our first deep dive into the world of browser exploitation by covering a few complex topics that were necessary for fundamental knowledge. We mainly covered topics on how JavaScript and V8 worked under the hood by exploring what objects, maps and shapes were, how these objects were structured in memory, and we also covered some basic memory optimizations such as pointer tagging and pointer compression. We also touched on the compiler pipeline, bytecode interpreter, and code optimizations.

Now, if you haven’t read my previous post yet - then I **highly** recommend that you do so. Otherwise, you might be lost and totally unfamiliar with some of the topics presented within this post, since we are pretty much building off of the knowledge presented in Part 1 and further expanding on it.

In today’s blog post, we’ll go back to the compiler pipeline and will further expand on some of the concepts that we talked about, such as V8’s bytecode, code compilation, and code optimization. Overall, in this post we will be taking a deep dive into understanding what happens under the hood in Ignition, Sparkplug, and TurboFan as they are critical for our understanding in how certain “features” can lead to exploitable bugs.

The following topics will be discussed:

* Chrome Security Model
  + Multi-Process Sandbox Architecture
  + V8’s Isolate and Context
* Ignition Interpreter
  + Understanding V8’s Bytecode
  + Understanding the Register-Based Machine
* Sparkplug
  + 1:1 Mapping
* TurboFan
  + Just-In-Time Compilation (JIT)
  + Speculative Optimization and Type Guards
  + Feedback Lattice
  + “Sea of Nodes” Intermediate Representation (IR)
* Common Optimizations
  + Typer
  + Range Analysis
  + Bounds Checking Elimination (BCE)
  + Redundancy Elimination
  + Other Optimizations
    - Control Optimization
    - Alias Analysis & Global Value Numbering
    - Dead Code Elimination (DCE)
* Common JIT Compiler Vulnerabilities

Alright, with that long and scary list of complex topics out of the way, let’s take a deep breath and dive right in!

> **Note**: Most, if not all of the highlighted code paths are clickable links. Use these links to be taken to the relevant part of the Chromium source code so that you can examine the code more closely and follow along with the post.
>
> Also, take the time to read through the code comments. The Chromium source code, while complex, has some pretty good comments that can help you in understanding what part of the code is and what it does.

# Chrome Security Model

Before we dive into understanding the complexities of the compiler pipeline, how it does optimizations, and where bugs can appear, we first need to take a step back and look at the bigger picture. While the compiler pipeline plays a big role in JavaScript execution, it’s only one piece of the puzzle within the whole architecture of browsers.

As we’ve seen, V8 can run as a standalone application, but when it comes to the browser as a whole, V8 is actually embedded into Chrome and then utilized via [bindings](https://en.wikipedia.org/wiki/Language_binding) by another engine. Because of this, there are nuances and certain implications that we need to be aware of on how JavaScript code within an application is processed because that information is critical to our understanding of security issues within a browser.

For us to see this “bigger picture”, and to put together all the pieces of the puzzle, we need to start off by understanding the Chrome Security Model. This blog post series is a journey through browser internals and exploitation after all. So, to better understand why certain bugs are more trivial than others, and why exploitation of just one bug might not lead to direct remote code execution, we need to understand the architecture of Chromium.

As we know, JavaScript engines are an integral part to the execution of JavaScript code on systems. While they play a big role in making browsers fast and efficient, they also can open up a browser to crashes, application hang-ups, and even security risks. But JavaScript engines aren’t the only part of a browser that can have issues or vulnerabilities. Many other components such as the API’s or HTML and CSS render engines being used can also have stability issues and vulnerabilities that could potentially be exploited - albeit intentionally or not.

Now, it’s almost rather impossible to build a JavaScript or rendering engine that will never crash. And it’s also nearly impossible to build these types of engines to be safe and secure from bugs and vulnerabilities - especially because most of these components are programmed in the statically-typed language of C++ which needs to handle the dynamic nature of web applications.

So how does Chrome handle such an “impossible” task of trying to keep the browser running efficiently while also trying to keep the browser, system, and its users secure? In two ways, by using a multi-process architecture and sandboxing.

## Multi-Process Sandbox Architecture

Chromium’s [multi-process architecture](https://www.chromium.org/developers/design-documents/multi-process-architecture/) is just that, an architecture that uses multiple processes to protect the browser from instability issues and bugs that can stem from the JavaScript engine, render engine, or other components. Chromium also restricts access between each of these processes by only allowing certain processes to talk to one another. This type of architecture can be viewed as the incorporation of memory protection and access controls within an application.

In general, browsers have one main process that runs the UI and manages all the other processes - this is known as the “**browser process**” or “browser” for short. Very unique, I know. The processes that handle the web content are known as the “**renderer processes**” or “renderers”. These render processes utilize something called [Blink](https://www.chromium.org/blink/) which is the open-source rendering engine used by Chrome. Blink implements many other libraries that help it run, such as [Skia](https://skia.org/), which is an open-source 2D graphics library, and of course V8 for JavaScript.

Now, here are where things get a little bit complicated. In Chrome, each new window or tab opens up in a **new process** - which usually will be a new render process. This new render process has a global `RenderProcess` object that manages communication with the parent browser process and maintains global state of the web page or application within that window or tab. In turn, the main browser process will maintain a corresponding [`RenderProcessHost`](https://source.chromium.org/chromium/chromium/%2B/trunk%3Acontent/public/browser/render_process_host.h) object for each renderer, which manages browser state and communication for the renderer.

To communicate between each of these processes, Chromium uses either a [legacy IPC system](https://www.chromium.org/developers/design-documents/inter-process-communication/) or [Mojo](https://chromium.googlesource.com/chromium/src/%2B/HEAD/mojo/README.md). I’m not going to get into too much detail into how these work, b...