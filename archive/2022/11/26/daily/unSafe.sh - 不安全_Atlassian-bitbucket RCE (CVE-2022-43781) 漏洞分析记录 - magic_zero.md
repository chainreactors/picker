---
title: Atlassian-bitbucket RCE (CVE-2022-43781) 漏洞分析记录 - magic_zero
url: https://buaq.net/go-137233.html
source: unSafe.sh - 不安全
date: 2022-11-26
fetch_date: 2025-10-03T23:47:20.830757
---

# Atlassian-bitbucket RCE (CVE-2022-43781) 漏洞分析记录 - magic_zero

* [unSafe.sh - 不安全](https://unsafe.sh)
* [我的收藏](/user/collects)
* [今日热榜](/?hot=true)
* [公众号文章](/?gzh=true)
* [导航](/nav/index)
* [Github CVE](/cve)
* [Github Tools](/tools)
* [编码/解码](/encode)
* [文件传输](/share/index)
* [Twitter Bot](https://twitter.com/buaqbot)
* [Telegram Bot](https://t.me/aqinfo)
* [Search](/search/search)

[Rss](/rss.xml)

[ ]
黑夜模式

![](https://8aqnet.cdn.bcebos.com/b433710a0a9fd2d8c84b72d5661e38ae.jpg)

Atlassian-bitbucket RCE (CVE-2022-43781) 漏洞分析记录 - magic\_zero

前言距离上次写博客转眼已过去快三年，“空白”的这三年中也曾遇到很多有趣可成文的东西，但是因各种原因未能在此畅快抒怀。而在忙中偷闲的时候，也曾反省自己，以免迷失。回想最初入行安全的时候，全因一本早期
*2022-11-25 21:47:0
Author: [www.cnblogs.com(查看原文)](/jump-137233.htm)
阅读量:102
收藏*

---

## 前言

距离上次写博客转眼已过去快三年，“空白”的这三年中也曾遇到很多有趣可成文的东西，但是因各种原因未能在此畅快抒怀。而在忙中偷闲的时候，也曾反省自己，以免迷失。回想最初入行安全的时候，全因一本早期的黑客杂志而对漏洞研究有了独特的热情，再后来在Wooyun看过前辈们精彩的漏洞之后更加坚定的将漏洞研究作为自己未来努力的方向。但是在入行5,6年之后回头来看，却也常因外部嘈杂的声音淹没自己内心真实的想法，慢慢于繁重、枯燥的工作中磨灭了自己。深夜辗转之时，不免在难过之余暗自唏嘘。《周易》有卦，外险内动名之为屯，如何把握未来的路，或许只能先做好当下了罢。

## 环境搭建

[官方仓库](https://hub.docker.com/r/atlassian/bitbucket-server/tags)维护了各种版本的Bitbicket，我们根据[漏洞描述](https://confluence.atlassian.com/bitbucketserver/bitbucket-server-and-data-center-security-advisory-2022-11-16-1180141667.html)选择一个可以触发漏洞的版本即可。

然后根据镜像启动一个容器即可:

## 补丁对比

这次漏洞的更新并没有直接给出一个类似之前Confluence的bash脚本，因此给漏洞位置的确定带来了一定的困难。我本地选择了8.0.4和8.0.5的版本进行比对，得到的结果如下图：

![](https://img2022.cnblogs.com/blog/892186/202211/892186-20221125213217041-1947415443.png)

其中licenses目录忽略，osgi-framework-bundles目录为osgi的bundle 所在目录，打开可以看到对比结果：

![](https://img2022.cnblogs.com/blog/892186/202211/892186-20221125213239631-838455274.png)

大小相差只有1字节，排除。接着是 atlassian-bundled-plugins目录为插件目录，根据大小和jar包的名称过一圈，最终锁定为app/WEB-INF/lib/bitbucket-process-8.0.x.jar：

![](https://img2022.cnblogs.com/blog/892186/202211/892186-20221125213255277-702691464.png)

然后diff对比一下：

![](https://img2022.cnblogs.com/blog/892186/202211/892186-20221125213308526-496115615.png)

然后使用Idea的对比工具查看：

![](https://img2022.cnblogs.com/blog/892186/202211/892186-20221125213326849-1135338630.png)

可以看到在8.0.5的版本新增了environmentPut和environmentPutIfAbsent两个函数，其中核心的判断逻辑是对传入值是否为0x00进行了检查，并且在`com.atlassian.bitbucket.internal.process.RemoteUserNioProcessConfigurer`中在将用户名放入环境变量时使用environmentPut代替了原先直接put的操作（代码上边为8.0.5，下边为8.0.4）：

![](https://img2022.cnblogs.com/blog/892186/202211/892186-20221125213357724-1642203823.png)

而漏洞的描述信息说是由用户控制用户名从而控制环境变量导致命令注入，至此推断基本吻合：

![](https://img2022.cnblogs.com/blog/892186/202211/892186-20221125213420395-1497589094.png)

## 漏洞触发

搞清楚漏洞原理之后，开始寻找能够触发命令执行的Git环境变量，搜索到了[Git官方的文档](https://git-scm.com/book/zh/v2/Git-%25E5%2586%2585%25E9%2583%25A8%25E5%258E%259F%25E7%2590%2586-%25E7%258E%25AF%25E5%25A2%2583%25E5%258F%2598%25E9%2587%258F)：

![](https://img2022.cnblogs.com/blog/892186/202211/892186-20221125213522789-1689313414.png)

但是该命令不支持命令行参数，文档中也说如果需要支持参数，最好自己去封装一个脚本，然后我开始看Git的详细手册：

![](https://img2022.cnblogs.com/blog/892186/202211/892186-20221125213547630-500943908.png)

其中GIT\_SSH\_COMMAND是支持参数的！

![](https://img2022.cnblogs.com/blog/892186/202211/892186-20221125213559727-756398021.png)

然后开始研究能够触发漏洞的路由，根据NioCommand在网络上搜索找到了这样的一个报错堆栈：
![](https://img2022.cnblogs.com/blog/892186/202211/892186-20221125213614064-1388902944.png)

找到RepositoryController之后，经过几轮调试发现：

1. 注册用户必须有仓库的访问权限，否则没办法触发Git相关的操作
2. 注册用户需要拥有创建或者访问仓库的权限

因此我为了调试本漏洞，首先开启注册功能，正如官方的缓解措施中告诉我们要关闭注册的那样，我们先将它打开 \_

![](https://img2022.cnblogs.com/blog/892186/202211/892186-20221125213634524-1118454792.png)

注册用户，使用burp修改空格为NULL空字符：

![](https://img2022.cnblogs.com/blog/892186/202211/892186-20221125213709998-517105637.png)

发包之后注册成功，登录的时候也要把这个字符修改掉，发包之后断点命中(com.zaxxer.nuprocess.linux.LinuxProcess#toEnvironmentBlock)：

![](https://img2022.cnblogs.com/blog/892186/202211/892186-20221125213722010-73274908.png)

跟进toEnvironmentBlock这个函数：

![](https://img2022.cnblogs.com/blog/892186/202211/892186-20221125213736451-1843564578.png)

这里有两个需要重点关注，也是这个漏洞能利用成功的关键：

1. 环境变量初始化的时候使用了byte数组，数组初始值全为0，从调试窗口可以看到
2. 每次复制一个数据，都会跳过一个位置将0字节(NULL)放到该值的末尾。这个从for循环最后一行可以体现出来

接着我让循环走两轮来证明以上的分析：

![](https://img2022.cnblogs.com/blog/892186/202211/892186-20221125213749945-1827371034.png)

可以看到两轮复制之后数据中间明显有一个空字节。这样我们创建的 用户名+NULL+环境变量，就很自然会注入一个新的环境变量：

![](https://img2022.cnblogs.com/blog/892186/202211/892186-20221125213802783-979348901.png)

将字节数组转化为字符串后，放到文本工具中将<0x00>替换为换行符方便查看：

![](https://img2022.cnblogs.com/blog/892186/202211/892186-20221125213818440-233186571.png)

但是执行过后并没有在目标/tmp/创建文件。因为触发这个命令执行的必要条件是Git连接SSH主机，而在Bitbucket中却很难找寻到这样的场景。

正当我搜索枯肠且感觉距离真相不远的时候，朋友直接丢来了[一篇文章](https://petrusviet.medium.com/cve-2022-43781-32bc29de8960)，顿时兴趣全无(╥╯^╰╥)，虽然这篇文章中的越南文字我不认识，但是看到了关键性的GIT\_EXTERNAL\_DIFF。manual手册的说明如下：

![](https://img2022.cnblogs.com/blog/892186/202211/892186-20221125214314906-1699586815.png)

大意是当设置了该环境变量，git diff的时候将会调用该程序。要比GIT\_SSH\_COMMADN触发条件要容易得多了。

## 完整复现步骤

1. 注册一个用户名为 字符串+NULL+GIT\_EXTERNAL\_DIFF=命令 的用户

![](https://img2022.cnblogs.com/blog/892186/202211/892186-20221125213831034-1551524025.png)

2. 访问任何一个public的仓库

![](https://img2022.cnblogs.com/blog/892186/202211/892186-20221125213842983-825182657.png)

3. 访问Commit记录有变更过的文件触发git diff命令

![](https://img2022.cnblogs.com/blog/892186/202211/892186-20221125213852806-2069244934.png)

4. 命令执行成功

![](https://img2022.cnblogs.com/blog/892186/202211/892186-20221125213902040-835752935.png)

文章来源: https://www.cnblogs.com/magic-zero/p/16926491.html
 如有侵权请联系:admin#unsafe.sh

© [unSafe.sh - 不安全](https://unsafe.sh) Powered By [PaperCache](https://github.com/code-scan/PaperCache)

* admin#unsafe.sh
* [安全马克](https://aq.mk)
* [星际黑客](https://xj.hk)
* [T00ls](https://t00ls.net)