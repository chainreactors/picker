---
title: 源代码与二进制漏洞的融合
url: https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458499499&idx=1&sn=b9163880e1d230947cb4c7011d6618c2&chksm=b18e892186f9003768dc8d960ed3181f73eeca2b3998bd00fd2d97f0a22cbac13db4d9f05aa6&scene=58&subscene=0#rd
source: 看雪学苑
date: 2023-03-26
fetch_date: 2025-10-04T10:43:40.923134
---

# 源代码与二进制漏洞的融合

![cover_image](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8GbQvhTibRqum43S5vS4kHrE24ic9dnWuY4t439aIN0L0jQTnICs1iaP0Loa4cklJcmbict4o7MzdJgKw/0?wx_fmt=jpeg)

# 源代码与二进制漏洞的融合

TUGOhost 【译】

看雪学苑

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8GbQvhTibRqum43S5vS4kHrEeAFib1rgYmgGMjUHQczGJJe6v5ZYrjTvKOuLBjYeibCmncProXoR3vqA/640?wx_fmt=jpeg)

本文为看雪论坛优秀文章

看雪论坛作者ID：TUGOhost

#

```
一

摘要
```

反编译器是用来从程序二进制恢复到高级语言表示（通常是C代码）的工具。在过去的五年中，反编译器有了很大的改进，不仅是在产生的伪代码的可读性方面，而且在恢复的相似性方面也有了很大的改进。尽管反编译器经常被不同学科的逆向工程师所使用 (例如，支持漏洞发现或恶意软件分析），它们还没有被用来为源代码静态分析工具提供输入。特别是，源代码漏洞发现和二进制漏洞发现在今天仍然是两个非常不同的研究领域，尽管反编译器有可能弥合这一差距，并能对二进制文件进行源代码分析。

在本文中，我们在真实世界的漏洞上进行了一些实验，以评估这种方法的可行性。特别是，我们的测量旨在显示原始代码和反编译代码之间的差异如何影响静态分析工具的准确性。

值得注意的是，我们的结果显示，在71%的情况下，在反编译的代码上运行静态分析器可以检测到相同的漏洞，尽管在一些情况下我们观察到假阳性的数量急剧增加。为了了解这些差异背后的原因，我们对所有的案例进行了人工调查，我们发现了一些影响静态工具 "理解 "生成代码的能力的根本原因。

# **关键词：****反编译器，SAST，漏洞，逆向。**

#

#

#

```
二

简介
```

随着我们的世界继续迅速加速进入以软件为动力的未来，日益支持我们的生活和生计的软件中的漏洞正在增加。这给软件开发和测试带来了一系列独特的挑战。软件往往由两类测试人员来检查是否有漏洞：一类是开发软件的人，因此可以接触到源代码（源码级程序分析）；另一类是外部安全研究人员，他们往往无法接触到源代码 往往不能接触到源代码（二进制程序分析）。

源码级的漏洞分析与二进制的漏洞分析有着本质的区别，因为软件的关键信息，如类型、结构和大小信息，在软件被编译时就会丢失。这使得在二进制代码上执行某些分析范式，如静态漏洞检测，成为一项艰巨的挑战：在检测二进制代码中的漏洞之前，必须以某种方式恢复这些丢失的信息。这就解释了为什么在这个方向上的工作很少[7]，以及为什么能够分析二进制代码的商业工具（如Veracode）需要用调试符号编译应用程序[18]（即，本质上需要源代码）。缺乏源代码也阻碍了其他分析范式，如模糊分析和符号执行，因为即使是这些技术也受益于编译的能力，而不是在分析目标中加装instrumentation[55]。因此，静态分析技术往往需要源代码来有效地检测漏洞，而动态技术在有源代码时也能更好地发挥作用。

有趣的是，有一个相关的研究领域关注恢复编译过程中丢失的信息：反编译。近年来，人们提出了一些技术来改善数据类型[46,53]、代码结构[35,63,64]、甚至确切的语法特征的恢复[57]。这些技术已经被整合到越来越强大、准确和公开可用的反编译器原型中[33,39,40]。

我们的见解是，从概念上讲，反编译所离开的地方接近于漏洞检测的地方。也就是说，我们意识到，由反编译器恢复的类型信息、结构信息和伪代码可以被漏洞检测工具分析，以代替原始源代码，至少有一定的功效。此外，随着新兴技术不断改进反编译结果，原始代码和程序二进制反编译的伪代码之间的差距越来越小，反编译器可以成为基于源代码的漏洞检测技术的一个越来越有效的"拐杖"。

在本文中，我们进行了一项研究，以确定当前静态应用安全测试（SAST）工具在反编译器生成的代码上执行时检测漏洞的能力。虽然看起来很明显，反编译的代码仍然不适合静态分析，但我们的案例研究希望通过实验来量化我们离静态分析工具成为反编译代码的有效解决方案还有多远。为了做到这一点，我们测量了8个最先进的SAST工具的精度和召回率，因为它们在9个真实世界的应用程序的原始代码上操作，而这些应用程序的伪代码是由3个不同的最先进的反编译器反编译出来的。

我们的研究得出了四个主要结论。首先，当前反编译器的输出不适合大多数SAST工具在没有人类分析师干预的情况下进行任何分析，必须在基于编译的分析器（例如那些基于LLVM传递的分析器）应用之前进行修复。其次，当编译问题被手动修复时，SAST工具的运行召回率降低了71%，这表明在反编译器/SAST中可能实际存在着一种潜在的潜力。不幸的是，SAST工具在反编译代码上的精确度受到影响，平均误报率增加了232%。第三，我们发现，编译器的优化，特别是函数的内联，有时可以帮助（而在其他时候，阻碍）SAST工具。第四，通过分析原始代码和反编译代码之间SAST结果的差异，我们确定并描述了影响假阳性和真阳性检测性能差异的7个根本原因。

反过来，我们设想了一些可以从我们的结果中得到启发的直接的前进步骤。我们的研究巩固了这样一种认识：现代反编译器的设计是为了生成对人类来说容易理解的代码，而SAST工具的设计则不是为了摄入这种机器生成的代码。这为研究人员提出了一系列新的方向：尽管反编译器在设计时考虑到了源代码的要求，但即使是对反编译器的微小改进也能极大地提高SAST工具对二进制代码的功效。另外，未来的研究可以集中在SAST工具上，使它们在解析反编译的代码时更具有抗噪音能力。

例如，在我们的研究中表现良好的SAST工具之一Joern[65]所执行的模糊解析方法已经朝这个方向发展了。此外，使用反编译器作为源码级静态分析的第一阶段，可以在我们的数据集上使用SAST工具以外的应用。例如，嵌入式设备固件仍然难以用动态（由于在不模拟特定硬件环境的情况下执行固件的困难，即所谓的重新托管问题）和静态（由于固件通常以二进制形式分布）技术进行测试。虽然在这两方面都取得了一些有限的进展[27,41,54]，但反编译器辅助的静态分析器可以在没有标准替代品的情况下对这些情况进行自动化的漏洞评估。

综上所述，本文有三个主要贡献：

* 我们将反编译和源码级静态分析 "连在一起"，意识到后者在接近前者的地方接续。
* 我们对具有已知漏洞的真实世界的应用程序进行了彻底的评估，测量了检测效率的变化。
* 我们分析了反编译代码的SAST分析所产生的问题的根本原因，并提出了反编译技术研究人员可以进行的具体改进，以改善端到端的SAST结果。

所有与该论文相关的工件都存在于
https://github.com/elManto/SAST\_on\_Decompilers

#

#

```
三

相关工作
```

我们现在介绍与静态应用测试和反编译有关的技术现状。

##

## **SAST**

正如Chess等人所认为的，静态应用安全测试（SAST）的目的是在开发阶段消除源代码中的漏洞[25]。

这个研究领域提出的第一个方法包括对源代码进行简单的词汇分析，旨在检测已知的缺陷结构（例如危险的API调用）的存在[16,56,60]。

为了克服这些天真的技术的局限性，研究人员提出了新的方法，利用应用程序的源代码的更详细的模型，通常是依靠编译器的解析组件来获得。例如，作者[47,59,66]提出不同的方法，在编译时提取源代码的AST，并将其用于漏洞检测。

其他研究人员则倾向于尝试提高对特定类别错误的检测精度。其中，缓冲区溢出[34,36,42,61,62]、释放后使用[23,67-69]和空指针解构[37,38,50]就是这种情况。

也就是说，我们的论文并没有提出一种新的静态分析方法。相反，它更接近于许多专注于程序分析工具基准的研究，例如[20,21,24,30,31,43,52]，在这些研究中，从创建一个全面的测试案例到在实验中采用不同的工具集等几个方面进行分析。

## **反编译器**

关于反编译器的最早研究之一是由Cifuentes[26]在1995年进行的，作为她博士论文的一部分，她描述了反编译器如何工作，该领域的未来挑战，并提出了dcc，一个用于英特尔80286的反编译器。

在过去的二十年里，出现了两种主要的反编译器开发方法：基于规则的反编译和基于NMT（神经机器翻译）的反编译。基于规则的方法[10,11,23,44]是目前最流行的，尽管制作一个基于规则的反编译器特别耗时。例如，根据其作者的说法，RetDec的开发在一个由24名开发人员组成的团队中总共花费了7年时间[1]。

基于NMT的方法[33,39,40]的诞生与Katz等人[39]的开创性工作相吻合，作者将反编译问题概括为一项语言翻译任务，即由于采用了自然语言处理（NLP），从汇编到C。

另一个研究方向是提高反编译代码的质量，主要集中在两个方面：提高可读性和改进控制流布局。第一类包括旨在更好地恢复变量类型[46,53]和建议更有意义的变量名称[45]的工作。第二类传统上侧重于减少反编译器[35,63,64]（DREAM /DREAM++反编译器）生成的GOTO语句的数量。

需要强调的是，所有这些研究都只关注于改善人类的可读性（也就是反编译器输出的可用性）。迄今为止，还没有任何研究分析过机器处理所产生的代码有多容易。

最后，在2018年，Schulte等人[57]提出了一种新颖的方法来生成可以成功重新编译的二进制等价的反编译代码。Schulte等人的论文依赖于一些创新技术，如采用现有的反编译器作为提升过程的种子，并使用人写的代码摘录来生成人类可读的代码，即使该工具（名为BED）没有发布。

#

```
四

方法和实验设计
```

本文从漏洞检测的角度，研究现代静态分析工具如何受到反编译过程的影响。为此，我们研究了以下实体的互动。SAST工具、易受攻击的应用程序和反编译器。

对于每个易受攻击的应用程序，我们按照图1的总结进行（由于篇幅原因在附录中报告），其中有两个主要管道被执行。
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GbQvhTibRqum43S5vS4kHrEQIQS0lA5X2eWGuYHRCsX1ibPKUjOy9RgTTgH65pp0JdCbK7pvbiaicODg/640?wx_fmt=png)

**基线分析。**在源代码分析管道中，我们将应用程序的原始源代码输入到不同的静态分析器中，并存储其生成的报告供以后分析。

**编译。**我们根据提供的构建脚本（如Makefiles）编译每个应用程序，使用与开发人员建议的相同的编译器选项，以获得编译后的二进制文件，进而送入反编译的代码分析管道。附录4.8提出了进一步的见解，在那里我们展示了我们对易受攻击的应用程序的一个子集进行的差异化分析的结果，以评估编译器优化的影响。

**反编译和分析。**在反编译的代码分析管道中，我们使用我们的反编译器对二进制文件进行反编译，并通过不需要重新编译的SAST工具运行所得到的代码。

大多数的SAST工具需要编译目标应用程序（例如，执行LLVM传递）。因此，由于反编译器通常会产生类似于C语言的伪代码，而这些伪代码不能被重新编译，我们手动应用所需的修正，使反编译器的结果可以被gcc和clang编译器编译。这个耗时的过程是有趣的，原因有很多。首先，它使我们能够用我们研究中选择的所有静态分析工具完成实验。此外，它为我们提供了一个宝贵的反馈，即如果分析人员想在二进制程序上应用源代码静态分析，他们应该采取哪些步骤。换句话说，它使我们能够量化人类在环路解决方案的可行性和所需的努力。

在手动修复反编译的结果后，我们通过基于编译的SAST工具处理可重新编译的代码。

**结果比较。**最后，我们对实验中获得的三组报告（关于原始源代码的报告，以及关于反编译和可重新编译代码的两组报告）进行人工比较，以评估检测率和假阳性率如何受到前面步骤的影响。这一比较的结果将在第4节中介绍。

每当结果不同时（即如果以前检测到的漏洞不再被检测到，或者如果工具产生了新的错误警报 工具产生了新的错误警报），我们进行了根本原因分析 以确定其原因。这个步骤也是手动进行的。要求我们逐步修改反编译后的代码，使其与原代码越来越相似。使其与原始源码越来越相似，直到我们想要研究的效果消失。直到我们想要研究的效果消失为止（即检测到漏洞或不再发出错误警报）。

在本节的其余部分，我们将讨论我们用来选择缺陷的应用程序、SAST工具和反编译器的方法。值得注意的是，应用程序和SAST工具必须一起选择。事实上，为了有足够的结果供我们比较，我们要求每个漏洞至少被两个SAST工具检测到，而每个SAST工具至少检测到两个漏洞。这个限制被证明是很难满足的，并迫使我们执行一个漫长的预选阶段，在这个阶段我们评估了许多候选者（包括漏洞和静态工具）。

## **漏洞和应用选择**

我们对缺陷代码的选择是由五个主要要求驱动的。

代码库规模。我们希望包括一个小型的代码库，以评估代码复杂性对反编译和漏洞检测阶段的影响。检测阶段的影响。

C++。我们包括一个C++代码库，以评估反编译器只产生C代码作为输出的事实。

真实的漏洞。我们想收集真实世界的 CVE 和 bug，它们可以适当地代表典型的 bug 类别。这将使我们在实际的评估阶段尽可能地通用，而不关注人为生成的漏洞。

错误的复杂性。影响静态分析精度的一个重要因素是，需要检测的错误是程序间的（即，它的发现需要经过多个函数）还是程序内的（即，它在一个程序中是自成一体的）。在我们的数据集中，我们希望包括这两类的例子，更倾向于程序内的。事实上，我们的测试平台的目的不仅仅是为SAST工具设定基准，还包括具有不同检测复杂性的错误。

漏洞的可发现性。最后，我们还受到一个事实的限制，即所选的漏洞应该由所选的SAST工具在原始源代码上识别，以便在观察反编译代码的判决时进行比较。

为了满足我们所有的限制条件，我们从九个不同的应用程序中收集了10个漏洞（表1）。这些应用的范围从4千到2.1百万LOC不等（所有LOC的统计数字在表4中报告）。请注意，对于两个项目，即Xorg和OpenCV，漏洞存在于应用程序的一个子组件中，可以被编译为一个独立的模块。我们的数据集涵盖了以下五类漏洞。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GbQvhTibRqum43S5vS4kHrE8tmH1GokRRibqficicJ3Xc5NE6Biav4G2eRxGUVJAS4MhlaMqBUNu5FDGQ/640?wx_fmt=png)

缓冲区溢出BOF可能是最普遍的一类漏洞，这就是为什么我们决定在我们的评估中包括这类漏洞的五种变化，例如，对缓冲区处理API的三种错误使用（分别是scanf、memcpy和strcpy），一个基于堆的逐一缓冲区溢出的例子（程序间），最后是另一个基于堆的BOF。在一个C++代码库中，位于实现 父类中的一个抽象方法的实现。

整数溢出IOF错误是软件中未定义行为的一个常见原因。我们的数据集包括一个IOF的例子，它影响了动态内存分配的大小，因此可能导致堆BOF。

当一个NULL指针被取消引用时，就会出现空指针定义 NPD错误。我们在数据集中包括了一个NPD的例子：在这个例子中，指针是由calloc调用返回的，它被存储在一个结构的字段中。这个错误是由于调用者没有检查指针的有效性。

双重释放、释放后使用 DF(Double Free)、UAF漏洞。一方面，我们期望从反编译的角度来看，这种缺陷更容易，因为反编译器可以在没有任何类型系统/大小问题的情况下重构free的使用。另一方面，检测DF/UAF的SAST工具需要在内部跟踪释放的指针并检查所有后续的指针访问。作为进一步的复杂性，这两个错误中的一个（DF），是两个程序间漏洞中的第二个。

除以零 DBZ并不是一个内存损坏的漏洞，但它在过去影响了几个真实世界的软件，可以被用作拒绝服务漏洞。可被用作拒绝服务的漏洞。

## **SAST工具选择**

由于我们不确定反编译过程对SAST工具所进行的分析的影响，我们想评估一系列依靠不同功能和技术的产品。我们最初确定了12个工具（9个开源的，3个商业的）。

在12个候选的SAST工具中，我们选择了那些能够满足选择标准的工具，即在我们的数据集中检测到至少两个漏洞。最后，我们的静态分析器集合，在表2中列出，包括。CPPCheck、Joern、Infer、Scan-build、Ikos、Codeql、Comm 1和Comm 2，这是两个流行的商业工具，由于法律原因，我们必须匿名。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GbQvhTibRqum43S5vS4kHrEoKa241p6Q7v2EPUKPtPQc8I4Us3qPqpzeUheYhRsjiaVypoPCTm6zOA/640?wx_fmt=png)

在选择这八个工具之前，我们进行了一系列的初步实验，其中我们测试了许多其他的SAST工具。在其他工具中，我们考虑了Comm 3（另一个流行的商业工具）、Frama-C[9]、CPACheck[22]和Flawfinder[8]。然而，我们放弃了它们，因为在对一个错误的子集执行后，它们没有显示出足够的检测率和分析的准确性。

## **反编译器选择**

我们选择了三个最先进的反编译器进行评估。IDAPro 7.1[11]（来自HexRays的最先进的商业反编译器），Ghidra 9.2[10]（领先的开源反编译器），以及Retdec 4.0[44]（新兴的挑战者）。

两个主要原因影响了我们对这三种工具的选择。首先，其他新出现的替代方案在精度和生成代码的质量方面都远远落后。此外，以前关于反编译器[35,57,63,64]的工作在进行评估时只关注这三种反编译器。

非反编译提升器。一些工具，如MCSema[28]，可以直接将二进制代码提升到LLVM IR，而不是反编译[49]。乍一看，这些可能是在二进制代码上应用需要编译的SAST工具的一个可用途径。然而，这些工具只执行由反编译器执行的分析的一个子集，事实上，可以被视为反编译过程的 "第一阶段"。因此，与反编译器的结果相比，它们的输出将包含不充分的信息，使产生的代码不适合SAST分析。例如，由Lifters产生的字节码不包含调试信息，而在llvm pass之上工作的SAST工具通常需要编译器生成的符号。尽管有可能开发出更复杂的SAST工具，在静态提升器的输出和它们的预期输入之间架起桥梁，但这正是反编译器已经从另一个方向所做的。

#

```
五

实验
```

在这一节中，我们讨论了我们的实验，特别关注...