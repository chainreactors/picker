---
title: Exploiting the Synology DiskStation with Null-byte Writes
url: https://blog.ret2.io/2025/04/23/pwn2own-soho-2024-diskstation/
source: RET2 Systems Blog
date: 2025-04-24
fetch_date: 2025-10-06T22:05:13.951401
---

# Exploiting the Synology DiskStation with Null-byte Writes

# [![](/assets/img/logo-full.svg)](/) ENGINEERING BLOG

[# Exploiting the Synology DiskStation with Null-byte Writes](/2025/04/23/pwn2own-soho-2024-diskstation/)

## Achieving remote code execution as root on the Synology DS1823xs+ NAS April 23, 2025 / Jack Dates

---

In October, we attended [Pwn2Own Ireland 2024](https://www.zerodayinitiative.com/blog/2024/7/16/announcing-pwn2own-ireland-2024) and successfully exploited the Synology DiskStation DS1823xs+ to obtain remote code execution as root. This issue has been fixed as CVE-2024-10442.

The DiskStation is a popular line of NAS (network-attached storage) products by Synology. It has been succesfully exploited a few times at Pwn2Own events in the past, though it remained untouched in the prior yearâs event (Pwn2Own Toronto 2023).
Then Ireland 2024 saw three successful entries, all using unique bugs.

This post will detail our experience researching the Synology DiskStation and writing an exploit against it for the event.

[![](/assets/img/pwn2own_soho24_diskstation_title.jpg)](/assets/img/pwn2own_soho24_diskstation_title.jpg)

Prepping to throw an exploit at the Synology DiskStation, Pwn2Own Ireland 2024

## Reviewing Synology Packages

As mentioned, the past year or two of Pwn2Own had garnered no entries against the Synology DiskStation. In 2024, ZDI opted
to place a few non-default, but first-party packages authored by Synology in-scope for the competition:

> For the Synology DiskStation target, the following packages will be installed and are in scope for contest:
>
> * MailPlus
> * Drive
> * Virtual Machine Manager
> * Snapshot Replication
> * Surveillance Station
> * Photos

âPackagesâ are optional add-on applications / services (etc.) that can be easily installed on the device via Synologyâs Package Center in the DiskStation Manager.

For us, this meant more attack surface, and as this was the first year these packages were in-scope,
we figured there was good opportunity to find some relatively shallow vulnerabilities, as these packages likely hadnât seen as much security-oriented review. This turned out to be very true.

The first package we looked at was Virtual Machine Manager, which we installed directly from the built-in Package Center on a physical DiskStation.

[![](/assets/img/pwn2own_soho24_synology_vm_man.png)](/assets/img/pwn2own_soho24_synology_vm_man.png)

We could then enumerate any new network listeners with `netstat` via an SSH shell we had on our test device. This revealed a handful of localhost-only services, save for a single service bound to all interfaces, running the following command (as root):

```
/var/packages/ReplicationService/target/sbin/synobtrfsreplicad --port 5566
```

This listener was actually part of Replication Service, a separate package which was a dependency of Virtual Machine Manager (and is also a dependency of Snapshot Replication). Our interest was piqued given the high privilege-level and ease of communication with this service.

[![](/assets/img/pwn2own_soho24_synology_replication_service.png)](/assets/img/pwn2own_soho24_synology_replication_service.png)

The next step was to examine the binary. Since we had installed the service on a real device, we were able to pull the files via SSH.

Alternatively, software downloads are available [directly](https://www.synology.com/en-us/support/download) from Synology for both DSM (the core operating system) and packages. An [extraction tool](https://github.com/K4L0dev/Synology_Archive_Extractor) can then be used to parse the custom Synology archives and spit out the contents of packages, firmware images, or updates. Note that this particular tool is an FFI wrapper around native first-party Synology shared libraries, which can be pulled off a real device, or extracted from a DSM archive with a [separate tool](https://github.com/technorabilia/syno-extract-system-patch).

## Finding the Bug

With the relevant binaries in hand, we can start to look at the code for this TCP service listening on port 5566.
The main binary `synobtrfsreplicad` is just a driver shim to invoke functionality in `libsynobtrfsreplicacore.so.7`, which starts the TCP listener.

The service is a minimal linux-based forking server, with the main process continually calling `accept()` and forking off a child process to handle each new remote client. In turn, the child process runs a basic command loop to parse incoming messages sent to the service.

Each command has a simple binary format, with an opcode optionally followed by a variably-sized data payload:

unsigned cmd // command opcode

unsigned seq // sequence number

unsigned len

char data[len]

Two globals are defined to facilitate parsing these command messages. One is for the command itself, and the other is a ring-buffer-esque structure to hold up to 3 variably-sized command payloads.

struct

{

unsigned char sector; // ring buffer index

char bufs[3][65536]; // ring buffer of 3 payloads

unsigned buf\_lens[3]; // populated lengths of 3 payloads

} g\_recvbuf;

struct

{

ReplicaCmdHeader header; // opcode, seq, len

char \*data; // will point into one of the 3 g\_recvbuf bufs

} g\_cmd;

The command loop for reading messages looks something like this:

void runCmdLoop() {

while(1) {

g\_cmd.data = g\_recvbuf.bufs[g\_recvbuf.sector];

int err = recvCmd(&g\_cmd);

if (err)

bail;

g\_cmd.data[g\_cmd.header.len] = 0;

// ... handle cmd ...

}

}

// function to read both the header and payload of a message

int recvCmd(ReplicaCmd\* cmd) {

int err = raw\_tcp\_recv(cmd->header, 12);

if (err)

return err;

if (cmd->header.len > 0x10000)

return err;

// read actual payload data

err = raw\_tcp\_recv(cmd->data, cmd->header.len);

// ...

}

If the attacker-supplied length is too large, `recvCmd` bails out without reading any payload. However, its return value is zero, indicating no error, a bit odd considering the header length was invalidâ¦ Back in the caller, which is unaware of any error, things proceed normally, and the command payload is null terminated, using the arbitrarily large header length.

This bug is trivial enough that for our initial POC, we can use netcat to send a message consisting solely of Aâs (at least 12), in classic pwnable fashion:

[![](/assets/img/pwn2own_soho24_synology_crash.png)](/assets/img/pwn2own_soho24_synology_crash.png)

Unless youâre attached to the service using gdb, thereâs no on-device indication that anything has gone wrong. The fault doesnât seem to be logged to syslog or any other DSM logging facilities, and due to the nature of a forking server, there is no immediate loss of functionality.

The primitive afforded by this vulnerability will allow us to make repeated null byte writes into arbitrary offsets of the shared libraryâs BSS (data segment). Very CTF-like. Although the vulnerability is rather simple, the exploitation of it will be a bit more interesting.

Regardless, as all mitigations were enabled, we first had to somehow turn this into an info leak.

## Forking Server

Before we move on, recall that weâre dealing with a forking server, which can be very useful for breaking ASLR.
Each child process that is forked will have the same exact address space as the parent, and crashing them has no consequences: we simply reconnect to the service and get a clean slate, in the form of a new child process.
A bit like a time loop, each connection is an opportunity to glean new information about the address space in a cumulative manner.

At a high level, each iteration has the following structure:

1. Guess something (e.g. an address)
2. Have the binary use the guessed value such that it will behave differently if itâs correct or not (e.g. a wrong address will crash)
3. Observe the binaryâs behavior to determine if the value was correct
4. If correct, we have found the right value. Otherwise, repeat with the next guess

Weâll see how this can be applied to this specific binary as we continue.

## Functionality Ove...