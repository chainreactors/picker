---
title: CVE-2018-17463详细分析及复现
url: https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458480115&idx=1&sn=8e3211890f0da696ad3be2371a2fe2eb&chksm=b18e5d7986f9d46faeddc98950ea0a2f82fbac0677c761cef3fc43934133aa9563e5ef59fa8b&scene=58&subscene=0#rd
source: 看雪学院
date: 2022-10-30
fetch_date: 2025-10-03T21:19:27.872960
---

# CVE-2018-17463详细分析及复现

![cover_image](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8HpIfmoah1dOUIuxHB8sibPRpaP2boRnO2zIohicsX4WjMJscBKgJgSKuu1mpxmrXP07d9NImIjRryg/0?wx_fmt=jpeg)

# CVE-2018-17463详细分析及复现

h1J4cker

看雪学苑

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8HpIfmoah1dOUIuxHB8sibPRoxbIDmtQV2M1pjicJXQXOZvUx9fhuJJjQSooHSG7tRA6rQqAQZuiaCsg/640?wx_fmt=jpeg)

本文为看雪论坛优秀文章

看雪论坛作者ID：h1J4cker

本文为CVE-2018-17463的分析以及复现，CVE-2018-17463是一个由于TurboFan优化所产生的漏洞，因为我也是刚接触浏览器这方面不久，是个新手，也是第一次复现真实环境中的漏洞，所以我会尽可能的把分析的过程以及自己在复现过程中遇到的问题写清楚，希望能够帮助到和我一样刚入门的师傅。

*本文参考文章：**http://p4nda.top/2019/06/11/%C2%96CVE-2018-17463/?utm\_source=tuicool&utm\_medium=referral#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA*

##

```
一

前置准备
```

这个漏洞在Chrome Bug的网页上，有很多的相关信息，我们可以在其中找到存在漏洞的版本，可以看到相关的PoC，为我们的复现做准备，这里放一下链接(第一次复现不了解，当时找链接找了半天)：

漏洞*：**https://bugs.chromium.org/p/chromium/issues/detail?id=888923*

漏洞详情：*https://chromium.googlesource.com/v8/v8/+/52a9e67a477bdb67ca893c25c145ef5191976220*

PoC：*https://chromium.googlesource.com/v8/v8/+/52a9e67a477bdb67ca893c25c145ef5191976220/test/mjsunit/compiler/regress-888923.js*

基础的V8调试环境的搭建这里就不再赘述了，需要的师傅可以参考我博客里的这一篇文章：v8调试环境搭建/)，讲的是Ubuntu22.04下的环境搭建。

用如下命令先切换到漏洞所在的版本并编译v8：

```
git checkout 568979f4d891bafec875fab20f608ff9392f4f29./tools/dev/v8gen.py x64.debug -vvninja -C out.gn/x64.debug #如果需要release版本的话，把x64.debug换成x64.release即可，这里为了调试方便，我是用的debug版本
```

```
二

漏洞分析
```

**PoC分析**

官方给出的PoC如下：

```
//poc.js(function() {  function f(o) {    o.x;    Object.create(o);    return o.y.a;  }  f({ x : 0, y : { a : 1 } });  f({ x : 0, y : { a : 2 } });  %OptimizeFunctionOnNextCall(f);  assertEquals(3, f({ x : 0, y : { a : 3 } }));})();(function() {  function f(o) {    let a = o.y;    Object.create(o);    return o.x + a;  }  f({ x : 42, y : 21 });  f({ x : 42, y : 21 });  %OptimizeFunctionOnNextCall(f);  assertEquals(63, f({ x : 42, y : 21 }));})();
```

这里首先创建了一个名为f的函数，其中参数o是一个对象，在函数中调用了Object.Create(o)，并返回o.y.a，Object.create(o)会以其中的参数o为原型，再创建出一个对象并返回，但是这里并没有接收返回值，说明返回的对象并不是重点。接下来调用了两次f函数，然后通过%OptimizeFunctionOnNextCall来触发优化，最后再次调用f函数，并判断返回值是否与3相等。

根据传入的参数可以看出，在f函数并未修改o.y.a的值的情况下，最后一次调用f函数，返回的应该是3，说明这里由于某种原因o.y.a的值被改变了，而在PoC中，只调用了Object.create，那么很明显正是这个函数直接或间接引起了值的改变。

**补丁分析**

根据官方给出的补丁：

```
@@ -622,7 +622,7 @@   V(CreateKeyValueArray, Operator::kEliminatable, 2, 1)                \   V(CreatePromise, Operator::kEliminatable, 0, 1)                      \   V(CreateTypedArray, Operator::kNoProperties, 5, 1)                   \-  V(CreateObject, Operator::kNoWrite, 1, 1)                            \+  V(CreateObject, Operator::kNoProperties, 1, 1)                       \   V(ObjectIsArray, Operator::kNoProperties, 1, 1)                      \   V(HasProperty, Operator::kNoProperties, 2, 1)                        \   V(HasInPrototypeChain, Operator::kNoProperties, 2, 1)                \
```

补丁中可以看出，用kNoProperties代替了kNoWrite，那么为了了解kNoWrite是个啥，我们需要在源码中进行查看，在operator.h文件中，我们可以发现kNoWrite定义在一个枚举类型中：

```
//operator.h enum Property {    kNoProperties = 0,    kCommutative = 1 << 0,  // OP(a, b) == OP(b, a) for all inputs.    kAssociative = 1 << 1,  // OP(a, OP(b,c)) == OP(OP(a,b), c) for all inputs.    kIdempotent = 1 << 2,   // OP(a); OP(a) == OP(a).    kNoRead = 1 << 3,       // Has no scheduling dependency on Effects    kNoWrite = 1 << 4,      // Does not modify any Effects and thereby                            // create new scheduling dependencies.    kNoThrow = 1 << 5,      // Can never generate an exception.    kNoDeopt = 1 << 6,      // Can never generate an eager deoptimization exit.    kFoldable = kNoRead | kNoWrite,    kKontrol = kNoDeopt | kFoldable | kNoThrow,    kEliminatable = kNoDeopt | kNoWrite | kNoThrow,    kPure = kNoDeopt | kNoRead | kNoWrite | kNoThrow | kIdempotent  };
```

其中kNoWrite的注释的大致意思是：不会产生副作用而创造出一个新的依赖项，根据前面的PoC文件，我们可以看出，简单的调用Object.create()并不会导致值的改变，但当优化之后，值却改变了，再根据补丁文件可以看出CreateObject这个函数被kNoWrite所标记，所以我们可以猜测出CreateObject被认为是不会产生副作用的，为了进一步了解发生了什么，我们需要借助一个工具：Turbolizer。

通过增加参数来生成Turbolizer所需要的文件：

```
../../out.gn/x64.debug/d8 poc.js --allow-natives-syntax --trace-turbo
```

然后运行Turbolizer：

```
python -m SimpleHTTPServer
```

将生成的json文件打开就行了，经过观察以后发现，CreateObject节点在generic lowering阶段，变为了Call：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HpIfmoah1dOUIuxHB8sibPRq6CmeQ9Pcdjazr9Xx4USHD4gVNwGCGVaFOX3DHXWYhE5SlerBibpc6g/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HpIfmoah1dOUIuxHB8sibPRDheFtWtl1la2dTKcOYpP8bUhiaxpXagGhsDFGwVibH8NIFZMgibmus5Lg/640?wx_fmt=png)

鼠标放上去就能看见这里用CreateObjectWithoutProporties来代替了原本的JSCreateObject函数，那么我们继续查看源码(由于本人水平有限，源码阅读部分的分析大多是参考的参考文章中的描述)。

**源码分析**

在builtins-object-gen.cc中：

```
TF_BUILTIN(CreateObjectWithoutProperties, ObjectBuiltinsAssembler) {  Node* const prototype = Parameter(Descriptor::kPrototypeArg);  Node* const context = Parameter(Descriptor::kContext);  Node* const native_context = LoadNativeContext(context);  Label call_runtime(this, Label::kDeferred), prototype_null(this),      prototype_jsreceiver(this);  {    Comment("Argument check: prototype");    GotoIf(IsNull(prototype), &prototype_null);    BranchIfJSReceiver(prototype, &prototype_jsreceiver, &call_runtime);  }    ..........  BIND(&call_runtime);  {    Comment("Call Runtime (prototype is not null/jsreceiver)");    Node* result = CallRuntime(Runtime::kObjectCreate, context, prototype,                               UndefinedConstant());    Return(result);  }}
```

从源码中可以看出，call\_runtime函数实际上又调用了另一个Runtime::kObjecrCreate函数，它的源码在runtime-object.cc中：

```
RUNTIME_FUNCTION(Runtime_ObjectCreate) {  HandleScope scope(isolate);  Handle<Object> prototype = args.at(0);  Handle<Object> properties = args.at(1);  Handle<JSObject> obj;  // 1. If Type(O) is neither Object nor Null, throw a TypeError exception.  if (!prototype->IsNull(isolate) && !prototype->IsJSReceiver()) {    THROW_NEW_ERROR_RETURN_FAILURE(        isolate, NewTypeError(MessageTemplate::kProtoObjectOrNull, prototype));  }  // 2. Let obj be ObjectCreate(O).  ASSIGN_RETURN_FAILURE_ON_EXCEPTION(      isolate, obj, JSObject::ObjectCreate(isolate, prototype));   // 3. If Properties is not undefined, then  if (!properties->IsUndefined(isolate)) {    // a. Return ? ObjectDefineProperties(obj, Properties).    // Define the properties if properties was specified and is not undefined.    RETURN_RESULT_OR_FAILURE(        isolate, JSReceiver::DefineProperties(isolate, obj, properties));  }  // 4. Return obj.  return *obj;}
```

可以看到，当O的类型是一个Object或者Null的时候，就会调用JSObject::ObjectCreate，他的位置在源码中的objects.cc：

```
// 9.1.12 ObjectCreate ( proto [ , internalSlotsList ] )// Notice: This is NOT 19.1.2.2 Object.create ( O, Properties )MaybeHandle<JSObject> JSObject::ObjectCreate(Isolate* isolate,                                             Handle<Object> prototype) {  // Generate the map with the specified {prototype} based on the Object  // function's initial map from the current native context.  // TODO(bmeurer): Use a dedicated cache for Object.create; think about  // slack tracking for Object.create.  Handle<Map> map =      Map::GetObjectCreateMap(isolate, Handle<HeapObject>::cast(prototype));   // Actually allocate the object.  Handle<JSObject> object;  if (map->is_dictionary_map()) {    object = isolate->factory()->NewSlowJSObjectFromMap(map);  } else {    object = isolate->factory()->NewJSObjectFromMap(map);  }  return object;}
```

可以看出，这段代码首先获取了Map，并根据Map的类型来选择调用NewSlowJSObjectFromMap或者NewJSObjectFromMap，我们跟进GetObjectCreateMap函数中继续观察：

```
Handle<Map> Map::GetObjectCreateMap(Isolate* isolate,                                    Handle<HeapObject> prototype) {  Handle<Map> map(isolate->native_context()->object_function()->initial_map(),                  isolate);  if (map->prototype() == *prototype) return map;  if (prototype->IsNull(isolate)) {    return isolate->slow_object_with_null_prototype_map();  }  if (prototype->IsJSObject()) {    Handle<JSObject> js_prototype = Handle<JSObject>::cast(prototype);    if (!js_prototype->map()->is_prototype_map()) {      JSObject::OptimizeAsPrototy...