---
title: 魔形女再袭？最新Android通杀漏洞CVE-2024-31317分析与利用研究
url: https://blog.flanker017.me/the-new-mystique-bug-cve-2024-31337/
source: Flanker Sky
date: 2024-08-22
fetch_date: 2025-10-06T18:01:38.224663
---

# 魔形女再袭？最新Android通杀漏洞CVE-2024-31317分析与利用研究

# [Flanker Sky](https://blog.flanker017.me/ "Flanker Sky")

## About security and coding

Menu
[Skip to content](#content "Skip to content")

* [Home](https://blog.flanker017.me/)
* [An online source browsing site](https://blog.flanker017.me/an-online-source-browsing-site/)
* [Contact & GPG](https://blog.flanker017.me/contact-gpg/)
* [Publications & Presentations](https://blog.flanker017.me/publications-presentations/)
* [关于我 & My CVEs](https://blog.flanker017.me/about-me/)
* [微信公众号，欢迎关注](https://blog.flanker017.me/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%8C%E6%AC%A2%E8%BF%8E%E5%85%B3%E6%B3%A8/)

# 魔形女再袭？最新Android通杀漏洞CVE-2024-31317分析与利用研究

[2 Replies](https://blog.flanker017.me/the-new-mystique-bug-cve-2024-31317/#comments)

# 摘要

本文分析了CVE-2024-31317这个Android用户态通杀漏洞的起因，并分享了笔者的利用研究和方法。通过这个漏洞，我们可以获取任意uid的权限，近似于突破Android沙箱获取任意app的权限。这个漏洞具有类似于笔者当年发现的[魔形女漏洞](https://dawnslab.jd.com/mystique/)（黑客奥斯卡[Pwnie Award最佳提权漏洞](https://pwnies.com/mystique-in-the-house-the-droid-vulnerability-chain-that-owns-all-your-userspace/)）的效果，但又各有千秋。

# 漏洞缘起

数月之前，[Meta X Red Team](https://rtx.meta.security/exploitation/2024/06/03/Android-Zygote-injection.html)发表了两篇非常有意思的，可以用来提权到任意UID的Android Framework漏洞，其中CVE-2024-0044因简单直接，在技术社区已经有了广泛的分析和公开的exp，但CVE-2024-31317仍然没有公开的详细分析和exp，虽然后者比前者有着更大的威力（能获取system-uid权限）。这个漏洞也颇为令人惊讶，因为这已经是2024年了，我们居然还能在Android的心脏组件（Zygote）中发现命令注入。

这让我们想起了当年我们所发现的[mystique漏洞](https://dawnslab.jd.com/mystique-paper-en/)，这个漏洞同样能让攻击者获得任意uid的权限。需要注意的是，两个漏洞都有一定的前提条件，例如CVE-2024-31317需要`WRITE_SECURE_SETTINGS` 权限。虽然这个权限获取难度并不大，但理论上仍需要配合一个额外的漏洞，因为普通的 `untrusted_app` 无法获得该权限（但似乎在一些品牌的手机上普通应用似乎有一些方法可以直接获得该权限）。ADB shell原生具有这个权限，同样一些特殊预置签名应用也具有这个权限。

但这个逻辑漏洞的利用效果和普适性，仍然足以让我们觉得，这是继魔形女之后近年来最有价值的Android用户态漏洞。Meta的原文对该漏洞成因有非常好的分析，但对于利用过程和方式缺少关键细节，本文将基于我们的分析和理解对该漏洞进行详细的研究，并介绍完整的及一些新的利用方式，据我们所知，尚属首次公开。

附利用效果图，成功在获得system权限。目前厂商均已修复：
![demo](https://i2.wp.com/s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2024-08-22-11-358KzyvzGbYs9Ce11Z.gif?w=625&ssl=1)![demo](https://i2.wp.com/s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2024-08-22-11-358KzyvzGbYs9Ce11Z.gif?w=625&ssl=1)

## Detailed Analysis of this Vulnerability

虽然这个漏洞的核心是命令注入，但利用这个漏洞需要对Android系统有相当的了解，特别是Android的基石——Zygote fork机制是如何工作的，以及它和system\_server如何交互。

### Zygote与system\_server的bootstrap流程

每个Android人员都知道Zygote会fork出Android中Java世界的所有进程，而对于system\_server，它也不例外，如下图所示。

![zygoteandsystemserver](https://i1.wp.com/s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2024-08-21-14-34fzSmVTWa34tDZZYP.png?w=625&ssl=1)![zygoteandsystemserver](https://i1.wp.com/s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2024-08-21-14-34fzSmVTWa34tDZZYP.png?w=625&ssl=1)

Zygote进程实际上从system\_server中接收指令，并根据指令孵化出子进程。这是通过[ZygoteServer.java](https://cs.android.com/android/platform/superproject/main/%2B/main%3Aframeworks/base/core/java/com/android/internal/os/ZygoteServer.java;l=521;drc=efb735f4d5a2f04550e33e8aa9485f906018fe4e)中的poll机制来实现的：

```
 Runnable runSelectLoop(String abiList) {
 //...
 if (pollIndex == 0) {
                        // Zygote server socket
                        ZygoteConnection newPeer = acceptCommandPeer(abiList);
                        peers.add(newPeer);
                        socketFDs.add(newPeer.getFileDescriptor());
                    } else if (pollIndex < usapPoolEventFDIndex) {
                        // Session socket accepted from the Zygote server socket

                        try {
                            ZygoteConnection connection = peers.get(pollIndex);
                            boolean multipleForksOK = !isUsapPoolEnabled()
                                    && ZygoteHooks.isIndefiniteThreadSuspensionSafe();
                            final Runnable command =
                                    connection.processCommand(this, multipleForksOK);

                            // TODO (chriswailes): Is this extra check necessary?
                            if (mIsForkChild) {
                                // We're in the child. We should always have a command to run at
                                // this stage if processCommand hasn't called "exec".
                                if (command == null) {
                                    throw new IllegalStateException("command == null");
                                }

                                return command;
                            } else {
                                // We're in the server - we should never have any commands to run.
                                if (command != null) {
                                    throw new IllegalStateException("command != null");
                                }

                                // We don't know whether the remote side of the socket was closed or
                                // not until we attempt to read from it from processCommand. This
                                // shows up as a regular POLLIN event in our regular processing
                                // loop.
                                if (connection.isClosedByPeer()) {
                                    connection.closeSocket();
                                    peers.remove(pollIndex);
                                    socketFDs.remove(pollIndex);
                                }
                            }
                        }

                        //...
      Runnable processCommand(ZygoteServer zygoteServer, boolean multipleOK) {
        ZygoteArguments parsedArgs;
```

随后进入到 `processCommand` 函数，这个函数是用于解析command buffer并提取出参数的核心函数。具体的格式在`ZygoteArguments` 中定义，我们接下来的工作很多就是需要围绕这个格式展开。

```
    Runnable processCommand(ZygoteServer zygoteServer, boolean multipleOK) {
//...
  try (ZygoteCommandBuffer argBuffer = new ZygoteCommandBuffer(mSocket)) {
            while (true) {
                try {
                    parsedArgs = ZygoteArguments.getInstance(argBuffer);
                    // Keep argBuffer around, since we need it to fork.
                } catch (IOException ex) {
                    throw new IllegalStateException("IOException on command socket", ex);
                }
               //...
                if (parsedArgs.mBootCompleted) {
                    handleBootCompleted();
                    return null;
                }

                if (parsedArgs.mAbiListQuery) {
                    handleAbiListQuery();
                    return null;
                }

                if (parsedArgs.mPidQuery) {
                    handlePidQuery();
                    return null;
                }
//...
                if (parsedArgs.mInvokeWith != null) {
                    try {
                        FileDescriptor[] pipeFds = Os.pipe2(O_CLOEXEC);
                        childPipeFd = pipeFds[1];
                        serverPipeFd = pipeFds[0];
                        Os.fcntlInt(childPipeFd, F_SETFD, 0);
                        fdsToIgnore = new int[]{childPipeFd.getInt$(), serverPipeFd.getInt$()};
                    } catch (ErrnoException errnoEx) {
                        throw new IllegalStateException("Unable to set up pipe for invoke-with",
                                errnoEx);
                    }
                }
//...
        if (parsedArgs.mInvokeWith != null || parsedArgs.mStartChildZygote
                        || !multipleOK || peer.getUid() != Process.SYSTEM_UID) {
                    // Continue using old code for now. TODO: Handle these cases in the other path.
                    pid = Zygote.forkAndSpecialize(parsedArgs.mUid, parsedArgs.mGid,
                            parsedArgs.mGids, parsedArgs.mRuntimeFlags, rlimits,
                            parsedArgs.mMountExternal, parsedArgs.mSeInfo, parsedArgs.mNiceName,
                            fdsToClose, fdsToIgnore, parsedArgs.mStartChildZygote,
                            parsedArgs.mInstructionSet, parsedArgs.mAppDataDir,
                            parsedArgs.mIsTopApp, parsedArgs.mPkgDataInfoList,
                            parsedArgs.mAllowlistedDa...