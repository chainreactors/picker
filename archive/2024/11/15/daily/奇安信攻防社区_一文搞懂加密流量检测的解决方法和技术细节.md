---
title: 一文搞懂加密流量检测的解决方法和技术细节
url: https://forum.butian.net/share/3866
source: 奇安信攻防社区
date: 2024-11-15
fetch_date: 2025-10-06T19:13:36.796318
---

# 一文搞懂加密流量检测的解决方法和技术细节

#

[问答](https://forum.butian.net/questions)

*发起*

* [提问](https://forum.butian.net/question/create)
* [文章](https://forum.butian.net/share/create)

[攻防](https://forum.butian.net/community)
[活动](https://forum.butian.net/movable)

Toggle navigation

* [首页 (current)](https://forum.butian.net)
* [问答](https://forum.butian.net/questions)
* [商城](https://forum.butian.net/shop)
* [实战攻防技术](https://forum.butian.net/community)
* [漏洞分析与复现](https://forum.butian.net/articles)
  NEW
* [活动](https://forum.butian.net/movable)
* [摸鱼办](https://forum.butian.net/questions/Play)

搜索

* [登录](https://forum.butian.net/login)
* [注册](https://user.skyeye.qianxin.com/user/register?next=http://forum.butian.net/btlogin)

### 一文搞懂加密流量检测的解决方法和技术细节

* [渗透测试](https://forum.butian.net/topic/47)

这篇文章从一个略懂密码学的安全分析工程师的角度围绕加密流量检测的问题开展详细的分析；让每一位读者明白加密流量的检测原理，以及目前市面上常见的检测方法落地。

0x01 背景
=======
这篇文章从一个略懂密码学的安全分析工程师的角度围绕加密流量检测的问题开展详细的分析；让每一位读者明白加密流量的检测原理，以及目前市面上常见的检测方法原理。
为什么突然想写这么一篇文章呢，事情的起因是周四看了xx公司的新产品发布会：《轻解密——加密流量检测产品》。
其实早在2022年的时候，笔者曾写过一篇文章，里面提到了对于加密流量的检测原理以及方法，但是由于那篇问题涉及一些其他的敏感东西被噶了，正好就这个机会我把之前文章中的对于加密流量的相关部分也腾挪过来。
0x02 分析
=======
一、加密流量分类
--------
从一个安全分析工程师的威胁分析的角度笔者这里把加密流量分为两大类的：
- 1、以SSL协议为代表的加密通信流量
- 2、以冰蝎webshell管理为首的常见安全工具相关的及数据传输业务相关加密流量
简单的说，第一种是大家公认的数据传输加密协议；第二种是应需求而生的各应用自己私设的相关加密数据传输。
二、加密流量的威胁检测
-----------
对于加密流量的威胁检测，从检测位置来看可以分为两种，一种是串连在网络结构中，一种是旁路部署在网络结构中；串联这种解决方案其实就是密码学里面所说的中间人攻击（MITM）;双向欺骗，欺骗客户端我们是服务端，欺骗服务端我们是客户端；在中间传话即可（和渗透场景中的代理抓https包一样的原理）。但是其短板也非常明显，就是需要串联部署在网络结构里面，如果设备出问题了，整个网络都会受影响，所以使用一定要谨慎并做好备份处理以及应急解决方案。
\*\*本文我们主要来讨论另一种检测方案即旁路部署的方案实现加密流量的威胁检测\*\*
我们来谈谈目前对于上述两种类型的加密威胁检测方法
### 对于第一种：以SSL协议为代表的加密通信流量
使用解密的方法来实现这以类型加密流量的威胁检测，其实很多ids类产品的探针会有此项功能，主要支持用户处的tls（http+ssl：https）流量的威胁检测，需要用户导入对应https网站的证书以及私钥；
这里笔者来尝试说清楚其中的原理，当尽量不牵扯复杂的密码学知识；
\*\*为什么需要用户导入公钥和私钥呢？\*\*
以tls1.2举例，我们先来了解其通信的整个过程，笔者将其简化为4步：
> 1、客户端对服务端发送请求：你好我要和你建立链接
>
> 2、服务端收到请之后发送，自己的证书给客户端：好的，你要和我建立链接你就按协议预设好的计划行事把，这是我的证书
>
> 3、客户端收到服务端的证书，拿到证书中的权威机构对相关内容的签名，然后使用内置在电脑上的各根权威机构的公钥对该签名进行校验，确认该证书的确是对应的服务器端；确认之后就获取证书中的公钥的；然后自己随机生成一个密钥，使用从证书中获取的公钥对该密钥加密，传输给服务端：好的，我先验验你这个证书，确认没问题了我就给你发我们之后交流使用的对称加密密钥，发的时候就使用你给我的公钥加密；
>
> 4、服务端收到客户的加密内容，使用私钥对加密内容解密，从而拿到了对称加密密钥，从而开始传输真正的要传输的内容，并且是使用这个对称加密密钥来加密：好的，我们之后就正常使用http通信，但是记得把通信内容都使用对称加密处理，密钥就用刚刚你给我传的那个；
如下图。
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/10/attach-2c4b0c1be402a1f219e463bfd66c9edf3f1c29bd.png)
\*\*然后我们回到之前的问题：为什么需要用户导入公钥和私钥呢？\*\*
上面的第三步里面我们可以看到，客户端发送了一个被加密的密钥给服务端，加密的方式使用服务端证书里面的公钥加密的；也就是流量中我们是可以直接看到这个内容的；所以此时只要我们有了服务端的私钥，那么就可以使用私钥对该内容进行解密；从而拿到里面的由客户端生成的，并且之后会用于加密通信内容的对称加密密钥；那么只要有了这个对称加密密钥，之后所有的通信流量都可以直接使用这个密钥解密，检测设备可以透明的看到里面的http流量；从而实现了对加密流量的威胁检测。
这里我们简单思考几个问题：
1、为什么要搞这么复杂，既然客户端都使用公钥加密对称密钥传输给服务端了，直接使用公钥加密后续的通信流量给服务端不就行了；
> 答：这种想法完全没问题，只有有服务端私钥的人才能获取到具体解密后传输的内容；但是这里面需要考虑性能的问题，这就涉及对称加密和非对称加密的原理了，简单的来说计算机对相同长度的密文进行对称加密的速度是非对称加密的速度的百倍甚至上千倍；这是由于两种加密算法的性质决定的（这里还只是考虑了加密，解密更夸张，对称加密算法的加解密速度其实是相当的，但是非对称加密算法，其解密通常要涉及高位数的运算从而其解密比加密还要慢不少）。非对称加密算法都是基于单项陷门函数实现的，即数学界的相关问题的难解性，如非对称加密算法RSA是基于大整数难分解的数学难题；
>
> 总结下来就是，可以，但是使用前者对称加密更优；
2、服务端的证书里面有什么，证书到底有哪些内容？一会服务端公钥，一会权威机构签名乱七八糟的；
这个问题其实对没有专门学习过密码学的人来说是比较模糊的，但是我们只需要抓住一点即可知道证书中的主要内容，即证书是用来干什么的：
我们常见证书有两种性质，如下图，左边的是通过浏览器访问google下载的，右图是查看chrom软件的签名里面使用的证书；
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/10/attach-16277a3340c8618bfd9acc43ef63d3381014289e.png)
从目的来看，证书其实就是证明你是你，你不是我，你也不是他；
那么就需要的那些东西来证明呢，
1、证书里面需要要你的基本信息对吧，如，如果是一家公司，那证书里面要记录公司名称，公司地址等等
2、需要生成一对公私钥，将公钥放入证书
3、需要有根证书或相关子机构使用私钥对你的证书进行签名，那不然谁来保证上面的信息的真实性呢，所以找了个权威来证明（这一步是需要花不少钱的）
4、证书的其他基本信息，谁颁发给你的，有效期多久（一般来说权威机构颁发的证书有效期不会超过三年，除非是非常稳定的大公司，因为一旦私钥泄露，证书里面公钥也报废了，证书也随即报废了，而且时间越长要缴纳的钱也越多），使用的签名算法是什么（后续验证的时候需要的使用）
5、还有一些其他的，如摘要算法等之类的，这些就比较偏了（有人可能会说上面好像没有提到所谓的摘要算法的使用，其实不然，一些细节里面是用了的，比如权威机构使用私钥对你提供的证书签名的时候，其本身不是对你的证书内容签名，而是对你证书内容的摘要进行签名，两种行为其实差不多，只要保证摘要算法没有的碰撞即可）
### 对于第二种：以冰蝎为代表的安全工具及相关业务加密流量的检测
这里我们假设要使用解密的方法来实现这以类型加密流量的威胁检测
以冰蝎举例，其流量走的是http请求体，使用AES对称加密传输，密钥更具版本不同略有不同，v2是通过协商创建，v3是通过硬编码到webshell中服务端中；
那么对于这种流量的解密其实是比较难做的，因为我们需要获取到aes的密钥；对于v2版本来说我们先要更具其他特征辨别该条流量是冰v2的链接流量，然后动态的从连接流量里面获取到aes的key。对于v3来说，这里先要辨别出该条流量是冰v3的流量，然后通过和终端上的agent类型设备联动获取到webshell的内容，提取密钥解密（又或者尝试使用硬编码的默认密钥），通过里面的一些内容特征，从而实现对该条流量的检测。
你仔细看上面的条件，你会发现这是一个伪命题，那就是从威胁检测的角度来说，我们如果要对这类加密流量进行威胁检测，前提都是我们先要辨别这个流量是对应的威胁的流量；那这就扯了，我都能辨别了还要你干啥。
所以我们见到对此类威胁的其实不是通过解密来做的，而是结合一些辅助特征+加密本身的特征，从而进行的威胁检测的；
如冰蝎，请求头字段弱特征特征（ct字段，cl字段的大小）、请求url特征、请求体参数名称特征，然后再加请求体本身是加密的特征（这里我们可以理解为对称加密算法的加密特征，有人可能会说对称加密算法有什么固定特征吗？如果硬要算的话其实也还是有的；这个我在22年的时候发布在先知上的一篇对加密webshell流量分析的文章中提到过，[实战分析某红队魔改哥斯拉Webshell](https://xz.aliyun.com/t/11368)，如冰蝎使用的是AES对称加密算法，AES作为国际标准对称加密算法，其密文本身是具备非常优秀的随机性的，即我们不能通过密文观察出任何和明文有关的特征（严谨一点，填充不算算法的本身），表现到的字节上就是，如果当我们把密文转化成2进制，那么这里的01分布应该是趋向于对半开的，%50）。
\*\*分析到这，这不是挺好的吗，你说的两种类型的加密流量都能被检测\*\*
我们不妨想想ssl协议本身被发明出来是为了干什么的，是不是就是为了防止别人通过侧\\旁信道获取到的真正的通信内容，那你这么搞，肯定不行呀；
ssl协议肯定不干呀，这不就是说ssl协议有漏洞吗，至少从协议设计的角度的，你需要保证你的协议本身的安全性不依赖于环境（就和现代加密算法的安全性是基于密钥保密，而非算法细节保密的原则一样），也就是说即使我在一个非常危险，被各种人监控的环境里面的，只要我正常使用你的协议，你就应该能保证我的安全性。这个和kerberos协议的设计初衷一样的，其假设的就是域内环境不安全；
### DH密钥交换算法
于是ssl协议里面使用一种特殊的密钥交换算法，应运而生，上文我们提到的ssl里面交换密钥使用的RSA来传输的及加解密的；这种方法显然是不能对抗的通过私钥解密会话密钥，然后通过会话密钥解密对话内容的操作。SSl协议这里引入了新的密钥交换算法——DH密钥交换算法（全称是：Diffie-Hellman密钥交换算法）Diffie、Hellman是两个人名，这两位是公钥密码学之父，他们于1970发布了一篇叫《密码学新方向》的文章，从此拉开的公钥算法体系；
我们来简单的说下这个dh的密钥交换算法，尽量通俗易懂让大家理解；
Alice 和 Bob 两个人想要协商出一个密钥，用于后续的对称加密；
1、首先Alice 和Bob直接使用 明文商量，选择两个数，一个是p，一个是g，其中p是一个素数，g是模p的有限域上的原根；
这里我们简单解释下原根：
> 要判断一个数是否是原根，需要检查它是否可以生成群中的所有非零元素。如我们选p为7的时候，在模7下，群的元素是 {1,2,3,4,5,6}
>
> 我们选择的g需要满足，其g的k次 mod 7 能够挨个便利 上面的群元素集合
>
> 例如此时我们选择g为3
>
> (3^1) mod 7 = 3 mod7 = 3
>
> (3^2) mod 7 = 9 mod 7 = 2
>
> (3^3) mod 7 = 27 mod 7 = 6
>
> (3^4) mod 7 = 81 mod 7 = 4
>
> (3^5) mod 7 = =243 mod 7 = 5
>
> (3^6) mod 7 = 729 mod 7 = 1
那么我们就说3是mod7的有限域上的原根；
2、Alice 和Bob各自随机选择一个记a，b，然后各自计算 (g^a )mod p 、(g^b) mod p 分别记做A、B；然后分别将A、B发送给对方；
3、在收到对方发来的内容之后，Alice 计算B ^a mod p 、 Bob计算A^b mod p ；此时Alice 和Bob 就获取到的了一个相同的密钥；
Alice最后的内容是 B^a mod p ， B = （g^b） mod p ,所以Alice计算的结果是：（g^b）^a mod p = g^(ab) mod p；
Bob最后的内容是A^b mod p, A = (g^a) mod p ,所以Bob的计算结果就是：(g^a)^b mod p = g^(ab) mod p ;
所以这两个结果是一样的；
如下图：
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/10/attach-348d96549342febe23c3679d53ce44685a0b69a8.png)
我们来思考下，攻击者如何才能破解这个密钥交算法，从而获取到最终的协商的结果密钥；
攻击者知道 参数p和g，然后也知道A、B，求最终密钥；
最终密钥 的表现形式如下：
\\=B^a mod p
\\=A^b mod p
\\=g^(ab) mod p
所以攻击者无论如何都是要获取到a或者b，才能计算出最终密钥的；
那么这个问题就转化成已知：A=g^a mod p ，并且也知道具体的A 和 p 和g 是否能计算出来a；事实上这就是非常有名的\*\*模素域上的离散对数问题\*\*；当p是一个大素数的时候，这个对数式是非常难解的（难解的程度取决于有限域的大小，也就是p的大小，在常见的使用场景中p通过是2048位及以上位数的大小），正向算非常简单，但是逆向算是解不出来的，也就是上文说的单项陷门函数。
这里我们来聊聊 DH和RSA的关键区别：
> 1、SSL中使用DH算法交换密钥，DH的私钥，每次会话建立的时候都是由双方自己随机生成；但是使用RSA算法交换密钥，RSA的私钥一直都是不变的，就是对应的证书里面公钥对应的私钥，这个私钥在换证书的前提下是修改不了的。那么这里面就衍生出来了一个概念，叫前向安全性；就是说，如果有天你的私钥泄露了，那么会对你之前的会话造成影响吗？我们先不说私钥怎么会被泄露是以何种形式何种方法泄露，显而易见，DH不会，但是RSA是绝对会的，这也是为什么现在的一些探针旁路部署的设备能够解密对应的ssl流量的原因；
>
> 2、密钥的安全，DH中我们不难看出其实私钥就是在协商对称密钥的一瞬间有用，只要把密钥协商出来之后的，我们之后就在也用不上那个私钥了，甚至可以直接销毁，这样也大大的增加了密钥的安全性，销毁之后谁都不知道了，谁都获取不到了。但是RSA不一样，之后的每个会话都需要这个RSA私钥来用于这个协商过程中（服务端解密使用），所以需要在服务端找一个地方专门存储私钥的。
事实上SSL中的DH也是这么做的，即在生成共享密钥的一瞬间就销毁掉本地私钥。
接下来我们来看我们最关注的问题；
三、为什么旁路设备解密不了SSL3.0（TLS1.3）的流量
------------------------------
无论是哪家厂商的旁路解密流量检测设备，其对某加密站点支持的时候，都会需要询问客户对应加密站点ssl中能支持使用的加密套件是什么，然后有些套件不支持就解密不了；其实你仔细观察，你会发现一个现象就是所有在https 中ssl协议里面使用的了带DH作为密钥交换算法的组件的站点，没有一家产品是支持的；就是因为DH你没办法传私钥，私钥都是机器自己随机生成的，协商密钥阶段生成对称密钥的一瞬间，机器就销毁了对应的私钥；并且其还是一次一密即每个会话都是随机生成新的各自的私钥；
那这和ssl3.0有什么关系呢？
\*\*ssl3.0为了增强ssl协议的安全性，其强制要求在3.0版本只能使用dh密钥交换算法来协商对称加密使用的密钥；\*\*
ssl的1.0和2.0中没有强制要求，但是有些站点的ssl在配置加密套件的时候，如果使用了dh来作为密钥交换算法，那么目前旁路设备都是不支持解密的；
### 一个颠覆大家认知的观点
\*\*笔者这里要提出一个颠覆大家认知的观点：严格意义上来说从理论上看旁路也是可以解密使用了DH算法实现密钥交换的SSL协议加密流量（不管是哪个版本）；\*\*
我们就这个问题开展以下分析：
在了解了上面的SSL过程以及DH的原理之后我们不难看出，想要解密使用了DH算法实现密钥交换的SSL协议加密流量，核心就是\*\*怎么获取到DH里面的私钥\*\*，并且因为DH是每个会话都重新生成私钥，那么我们需要获取\*\*私钥和会话的对应关系\*\*。那么怎么才能做到上面两点呢？
做到这两点其实也不难，
1、在要被监测的服务端上我们上一个agent，hook其openssl组件里面的一些实现，比如我们可以通过hook生成dh私钥的方法，将生成的私钥发送到我们的解密设备上；这样以来我们可以获取到私钥了；
2、在要被监测的服务端上我们上一个agent，我们需要利用这个agent，记录会话的标志以及该次会话使用的私钥，将这个映射关系发送到我们的解密设备上，设备就可以把之前记录的会话一一解密了；
通俗点说，你不是一次一密（dh的每个会话都是生成新的随机密钥）嘛，那我就把你所有的密钥获取到，并且记录密钥和会话的映射关系。这不就解密了嘛！
但是为什么目前厂商做不出来呢，笔者认为这个根本原因就是第二点的，第二点想要获取会话和密钥的映射关系是非常难的，你怎么去标记一个会话是一个问题，因为你最后需...