---
title: 【Python】深入理解Python的列表推导式与生成器表达式：简洁与性能的权衡
url: https://blog.csdn.net/nokiaguy/article/details/143227427
source: 一个被知识诅咒的人
date: 2024-10-27
fetch_date: 2025-10-06T18:49:01.687341
---

# 【Python】深入理解Python的列表推导式与生成器表达式：简洁与性能的权衡

# 【Python】深入理解Python的列表推导式与生成器表达式：简洁与性能的权衡

原创
于 2024-10-26 09:30:00 发布
·
975 阅读

·
![](https://csdnimg.cn/release/blogv2/dist/pc/img/newHeart2023Active.png)
![](https://csdnimg.cn/release/blogv2/dist/pc/img/newHeart2023Black.png)

15

·
![](https://csdnimg.cn/release/blogv2/dist/pc/img/tobarCollect2.png)
![](https://csdnimg.cn/release/blogv2/dist/pc/img/tobarCollectionActive2.png)

10
·

CC 4.0 BY-SA版权

版权声明：本文为博主原创文章，遵循 [CC 4.0 BY-SA](http://creativecommons.org/licenses/by-sa/4.0/) 版权协议，转载请附上原文出处链接和本声明。

文章标签：

[#python](https://so.csdn.net/so/search/s.do?q=python&t=all&o=vip&s=&l=&f=&viparticle=&from_tracking_code=tag_word&from_code=app_blog_art)
[#开发语言](https://so.csdn.net/so/search/s.do?q=%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80&t=all&o=vip&s=&l=&f=&viparticle=&from_tracking_code=tag_word&from_code=app_blog_art)

[![](https://i-blog.csdnimg.cn/columns/default/20201014180756925.png?x-oss-process=image/resize,m_fixed,h_224,w_224)

Python杂谈
专栏收录该内容](https://blog.csdn.net/nokiaguy/category_12800257.html "Python杂谈")

390 篇文章

订阅专栏

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/dd138e8371054ae2a0e31bd414e9e2e4.png)

---

### 引言

Python因其简洁易懂的语法和强大的标准库，深受开发者的喜爱。为了提升代码的简洁性与可读性，Python引入了许多方便的语法特性，其中列表推导式和生成器表达式是非常重要的工具。这两者为我们提供了优雅的方式来生成序列数据，减少了不必要的循环结构，提高了代码的可读性。

在实际编程中，列表推导式和生成器表达式不仅在写法上有所不同，它们的内在机制和性能表现也有所差异。列表推导式直接创建列表对象，适用于需要一次性存储和处理所有元素的场景；而生成器表达式则是通过迭代器惰性求值，在需要时动态生成数据，节省内存并提高效率。

本文将深入探讨Python列表推导式与生成器表达式的用法、区别，以及它们在实际应用中的优劣势。

---

### 列表推导式：高效生成列表的简洁语法

#### 什么是列表推导式？

列表推导式（List Comprehension）是Python中一种用于创建列表的简洁语法。通过在单一表达式中嵌入循环和条件判断，列表推导式能够快速生成新的列表。

列表推导式的基本语法如下：

```
[expression for item in iterable if condition]
```

* **expression**：每个元素生成时应用的表达式。
* **item**：从迭代对象（`iterable`）中取出的元素。
* **iterable**：可以迭代的对象，如列表、元组、字符串等。
* **condition**：可选的条件，用于筛选满足条件的元素。

例如，生成一个包含1到10之间偶数的列表：

```
even_numbers = [x for x in range(1, 11) if x % 2 == 0]
print(even_numbers)  # 输出：[2, 4, 6, 8, 10]
```

#### 列表推导式的优势

1. **简洁性**：列表推导式让我们在一行代码中完成列表创建和筛选，避免了多行的`for`循环和`append`操作。
2. **提高可读性**：列表推导式用直观的语法表达生成逻辑，减少了代码的冗余部分，使得代码更易于理解。
3. **性能优化**：相比于传统的`for`循环，列表推导式通常更快。这是因为列表推导式在底层使用C语言实现，避免了Python解释器的许多额外操作。

例如，使用传统的`for`循环生成平方数列表：

```
squares = []
for x in range(1, 11):
    squares.append(x**2)
```

可以通过列表推导式将其简化为：

```
squares = [x**2 for x in range(1, 11)]
```

#### 列表推导式的常见应用

1. **过滤数据**

列表推导式可以轻松实现数据的过滤。比如从一个列表中选取出所有大于10的数字：

```
numbers = [1, 5, 12, 19, 3, 8]
filtered_numbers = [x for x in numbers if x > 10]
print(filtered_numbers)  # 输出：[12, 19]
```

2. **嵌套推导式**

列表推导式也支持嵌套，允许我们对多维数据进行处理。例如，生成一个二维数组的转置矩阵：

```
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
transpose = [[row[i] for row in matrix] for i in range(3)]
print(transpose)  # 输出：[[1, 4, 7], [2, 5, 8], [3, 6, 9]]
```

嵌套推导式的强大之处在于，它能让开发者在处理复杂结构时依然保持简洁和高效。

---

### 生成器表达式：节省内存的惰性求值

#### 什么是生成器表达式？

生成器表达式（Generator Expression）是与列表推导式类似的语法，但它并不会一次性生成整个列表，而是以迭代器的方式按需生成元素。生成器表达式使用圆括号`()`代替方括号`[]`来定义。

生成器表达式的基本语法与列表推导式几乎一致：

```
(expression for item in iterable if condition)
```

不同之处在于，生成器表达式是惰性求值的。也就是说，生成器表达式不会立刻生成所有元素，而是在需要时才逐个计算和返回元素。

例如，使用生成器表达式生成平方数：

```
squares_generator = (x**2 for x in range(1, 11))
```

此时，并不会生成完整的列表。你可以通过遍历生成器来逐步获取值：

```
for square in squares_generator:
    print(square)
```

#### 生成器表达式的优势

1. **节省内存**：列表推导式会在内存中一次性生成所有元素，而生成器表达式则按需生成元素，因此即使处理非常大的数据集，生成器表达式也能保持较低的内存占用。
2. **延迟计算（惰性求值）**：生成器表达式仅在迭代时生成元素。这对于处理大型文件或流式数据非常有用。

例如，处理非常大的数据集：

```
large_gen = (x**2 for x in range(100000000))
```

这种情况下，生成器表达式不会像列表推导式那样立即占用大量内存，而是仅在需要时生成值。

#### 生成器表达式的应用场景

1. **流式数据处理**

在处理日志文件或网络数据流时，生成器表达式是非常理想的选择。它允许我们以低内存的方式逐行处理文件内容：

```
with open('large_log_file.txt') as file:
    line_gen = (line for line in file if 'ERROR' in line)
    for error_line in line_gen:
        print(error_line)
```

在这个例子中，生成器表达式按需过滤文件中的错误行，而不需要将整个文件加载到内存中。

2. **无穷序列**

生成器表达式可以轻松用于生成无穷序列，因为它不会立即生成所有元素。例如，可以通过生成器表达式构建一个斐波那契数列生成器：

```
def fibonacci():
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

fib_gen = fibonacci()
for _ in range(10):
    print(next(fib_gen))
```

通过`yield`关键字和生成器表达式相结合，斐波那契数列能够以惰性方式生成，避免了无意义的内存消耗。

---

### 列表推导式与生成器表达式的性能比较

列表推导式和生成器表达式在性能上的区别主要体现在内存使用和计算效率上。

1. **内存占用**

列表推导式会立刻生成整个列表并将其存储在内存中，因此对于非常大的数据集，这可能会导致较大的内存占用。而生成器表达式采用了惰性求值的方式，只有在需要时才生成元素，极大地降低了内存的占用。

例如，生成一个大范围的数字并计算它们的平方：

```
# 列表推导式
squares_list = [x**2 for x in range(1000000)]

# 生成器表达式
squares_gen = (x**2 for x in range(1000000))
```

在这种情况下，列表推导式会占用大量内存，因为它立即生成了包含一百万个元素的列表；而生成器表达式只会在需要时生成每一个元素，因此几乎不占用额外内存。

2. **计算效率**

尽管生成器表达式在内存使用上占优，但在某些场景下，列表推导式的计算效率可能会更高。这是因为列表推导式一次性生成所有元素，而生成器表达式是惰性求值，每次调用生成一个元素。如果你的代码需要多次迭代或访问生成的元素，那么列表推导式可以避免重复的计算。

例如，在需要多次访问相同的结果时，列表推导式会表现得更高效，因为所有数据已经生成并存储在内存中：

```
# 使用列表推导式，生成的列表可以被多次访问
squares_list = [x**2 for x in range(1000000)]
print(sum(squares_list))
print(max(squares_list))

# 使用生成器表达式，每次访问时都会重新生成元素
squares_gen = (x**2 for x in range(1000000))
print(sum(squares_gen))  # 第一次迭代
# 由于生成器已被耗尽，无法再次迭代，需重新生成
squares_gen = (x**2 for x in range(1000000))
print(max(squares_gen))  # 第二次迭代
```

在这个例子中，生成器表达式需要在每次迭代时重新生成元素，而列表推导式只需生成一次即可反复访问。因此，列表推导式在需要频繁访问结果的场景下更加高效。

---

### 何时使用列表推导式，何时使用生成器表达式？

理解列表推导式和生成器表达式各自的特点有助于开发者根据具体需求选择合适的工具。以下是一些建议，帮助你在代码编写过程中做出最佳选择：

#### 1. 使用列表推导式的场景

* **数据集不大**：如果你处理的数据量较小，且无需担心内存使用，那么列表推导式是更好的选择，因为它在一次性生成和使用全部数据时效率更高。
* **需要多次访问**：如果你需要对生成的数据进行多次操作，例如迭代、查找最大值、计算总和等，列表推导式会表现得更高效，因为所有数据已经在内存中，无需重复生成。
* **需要列表的特性**：列表推导式生成的对象是列表，因此它支持所有的列表操作，如索引、切片、反转、排序等。如果你的程序需要这些特性，列表推导式是唯一的选择。

示例：

```
squares = [x**2 for x in range(10)]
print(squares[3])  # 输出：9，支持索引访问
print(squares[::-1])  # 输出：反转后的列表
```

#### 2. 使用生成器表达式的场景

* **处理大数据集或无限序列**：当处理非常大的数据集，或你不确定数据的大小时，生成器表达式能够显著减少内存使用。它只在需要时生成数据，这对于处理大型日志文件、数据流或无限序列非常有用。
* **一次性处理数据**：如果你只需要对生成的数据进行一次处理，比如在一个`for`循环中消费数据，生成器表达式是更好的选择，它能够避免在内存中保存整个数据集的开销。
* **流式处理数据**：生成器表达式非常适合流式处理数据，例如逐行读取文件、处理网络流或实时处理传感器数据。在这些场景中，生成器能够随着数据的到来逐步处理，避免占用过多的内存。

示例：

```
# 逐行处理大文件
with open('large_file.txt') as file:
    line_gen = (line.strip() for line in file if 'ERROR' in line)
    for error_line in line_gen:
        print(error_line)
```

在这个示例中，生成器表达式逐行读取文件并过滤内容，避免将整个文件加载到内存中。

---

### 生成器与迭代器：深入理解惰性求值

生成器表达式的背后依赖于Python的迭代器协议，这一机制使得它可以逐步生成元素，而不是一次性生成所有数据。迭代器是支持`__next__()`方法的对象，它们在每次调用`next()`时生成一个新的值，直到耗尽为止。

生成器函数与生成器表达式一样，都利用了惰性求值的机制。生成器函数通过`yield`关键字，每次调用都会返回一个值并暂停函数执行，直到下次调用。

例如，使用生成器函数生成斐波那契数列：

```
def fibonacci():
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

fib_gen = fibonacci()
for _ in range(10):
    print(next(fib_gen))
```

生成器函数与生成器表达式在语法和功能上有所不同，但它们共享相同的迭代器机制。这使得生成器可以处理大量数据而不会导致内存溢出，适用于各种需要逐步处理数据的场景。

---

### 内存和性能对比：列表推导式 vs 生成器表达式

为了直观展示两者的性能差异，我们可以使用`sys`库的`getsizeof`方法来对比列表推导式和生成器表达式的内存占用。

```
import sys

# 列表推导式
list_comp = [x**2 for x in range(1000)]
print("列表推导式内存占用：", sys.getsizeof(list_comp))

# 生成器表达式
gen_exp = (x**2 for x in range(1000))
print("生成器表达式内存占用：", sys.getsizeof(gen_exp))
```

输出：

```
列表推导式内存占用： 9024
生成器表达式内存占用： 104
```

从输出中可以看出，列表推导式的内存占用要比生成器表达式高得多。这是因为列表推导式会立刻生成整个列表，而生成器表达式只生成一个迭代器对象。

#### 性能权衡

对于需要频繁访问或需要完整列表的场景，列表推导式是首选；而对于大规模数据处理或一次性操作，生成器表达式的惰性求值机制则更为适用。开发者在选择时应根据具体需求，平衡内存占用与处理效率。

---

### 列表推导式与生成器表达式的高级应用

除了基本的使用场景，列表推导式和生成器表达式还可以用于更复杂的场景，如组合生成器、生成器管道和并行处理等。

#### 组合生成器

生成器可以彼此组合，通过将一个生成器的输出作为另一个生成器的输入，形成生成器管道。这在需要分步骤处理数据时非常有用。

```
# 一个生成器生成范围内的数字
gen1 = (x for x in range(10))

# 第二个生成器对前一个生成器的输出进行处理
gen2 = (x**2 for x in gen1)

for val in gen2:
    print(val)
```

#### 并行处理与生成器

通过与`concurrent.futures`模块结合，生成器表达式可以与并行处理框架结合，进一步提升处理大量数据的效率。

```
import concurrent.futures

def square(x):
    return x**2

with concurrent.futures.ProcessPoolExecutor() as executor:
    results = list(executor.map(square, range(1000)))
    print(results[:10])  # 输出前10个平方数
```

在这个例子中，使用并行处理来加速平方计算，这在处理大规模数据时可以显著提高性能。

---

### 结论

Python的列表推导式和生成器表达式为我们提供了简洁、高效的方式来生成和处理序列数据。列表推导式在需要一次性生成所有数据的场景中表现出色，而生成器表达式则通过惰性求值，显著降低内存开销，适用于处理大规模数据或无限序列。

在实际应用中，开发者应根据具体的需求选择合适的工具：如果数据量不大且需要多次访问，列表推导式是更好的选择；如果处理的是大数据集或流式数据，生成器表达式则能够大幅提升内存效率。通过合理使用这些工具，开发者可以编写出更简洁、灵活且高效的代码，从而提升代码的整体性能和可维护性。

关注博主即可阅读全文
![](https://csdnimg.cn/release/blogv2/dist/pc/img/arr...