---
title: Exploring ZIP Mark-of-the-Web Bypass Vulnerability (CVE-2022-41049)
url: https://breakdev.org/zip-motw-bug-analysis/
source: BREAKDEV
date: 2022-11-09
fetch_date: 2025-10-03T22:05:28.685624
---

# Exploring ZIP Mark-of-the-Web Bypass Vulnerability (CVE-2022-41049)

[![BREAKDEV](https://breakdev.org/content/images/2022/08/breakdev_logo_with_title.png)](https://breakdev.org)

* [Home](https://breakdev.org/)
* [Evilginx Pro](https://evilginx.com)
* [Evilginx Mastery](https://academy.breakdev.org/evilginx-mastery)
* [Tools](https://github.com/kgretzky)
* [Contact](https://breakdev.org/contact/)

[windows](/tag/windows/)

 Featured

# Exploring ZIP Mark-of-the-Web Bypass Vulnerability (CVE-2022-41049)

Windows ZIP extraction bug (CVE-2022-41049) lets attackers craft ZIP files, which evade warnings on attempts to execute packaged files, even if ZIP file was downloaded from the Internet.

* [![Kuba Gretzky](/content/images/size/w100/2022/08/avatar512.png)](/author/kuba/)

#### [Kuba Gretzky](/author/kuba/)

Nov 8, 2022
• 10 min read

![Exploring ZIP Mark-of-the-Web Bypass Vulnerability (CVE-2022-41049)](/content/images/size/w2000/2022/11/zip-motw.png)

In October 2022, I've come across a tweet from 5th July, from [@wdormann](https://twitter.com/wdormann), who reported a discovery of a new method for bypassing [MOTW](https://twitter.com/wdormann), using a flaw in how Windows handles file extraction from ZIP files.

> So if it were a ZIP instead of ISO, would MotW be fine?
> Not really. Even though Windows tries to apply MotW to extracted ZIP contents, it's really quite bad at it.
> Without trying too hard, here I've got a ZIP file where the contents retain NO protection from Mark of the Web. [pic.twitter.com/1SOuzfca5q](https://t.co/1SOuzfca5q)
>
> — Will Dormann (@wdormann) [July 5, 2022](https://twitter.com/wdormann/status/1544416883419619333?ref_src=twsrc%5Etfw)

This sounded to me like a nice challenge to freshen up my rusty RE skills. The bug was also a 0-day, at the time. It has already been reported to Microsoft, without a fix deployed for more than 90 days.

What I always find the most interesting about vulnerability research write-ups is the process on how one found the bug, what tools were used and what approach was taken. I wanted this post to be like this.

Now that the vulnerability has been fixed, I can freely publish the details.

# Background

What I found out, based on public information about the bug and demo videos, was that Windows, somehow, does not append MOTW to files extracted from ZIP files.

Mark-of-the-web is really another file attached as an Alternate Data Stream (ADS), named `Zone.Identifier`, and it is only available on NTFS filesystems. The ADS file always contains the same content:

```
[ZoneTransfer]
ZoneId=3
```

For example, when you download a ZIP file `file.zip`, from the Internet, the browser will automatically add `file.zip:Zone.Identifier` ADS to it, with the above contents, to indicate that the file has been downloaded from the Internet and that Windows needs to warn the user of any risks involving this file's execution.

This is what happens when you try to execute an executable like a JScript file, through double-clicking, stored in a ZIP file, with MOTW attached.

![](https://breakdev.org/content/images/2022/11/image.png)

Clearly the user would think twice before opening it when such popup shows up. This is not the case, though, for specially crafted ZIP files bypassing that feature.

Let's find the cause of the bug.

# Identifying the culprit

What I knew already from my observation is that the bug was triggered when `explorer.exe` process handles the extraction of ZIP files. I figured the process must be using some internal Windows library for handling ZIP files unpacking and I was not mistaken.

![](https://breakdev.org/content/images/2022/11/image-1.png)

ProcessHacker revealed `zipfldr.dll` module loaded within Explorer process and it looked like a good starting point. I booted up IDA with conveniently provided symbols from Microsoft, to look around.

`ExtractFromZipToFile` function immediately caught my attention. I created a sample ZIP file with a packaged JScript file, for testing, which had a single instruction:

```
WScript.Echo("YOU GOT HACKED!!1");
```

I then added a MOTW ADS file with Notepad and filled it with MOTW contents, mentioned above:

```
notepad file.zip:Zone.Identifier
```

I loaded up `x64dbg` debugger, attached it to `explorer.exe` and set up a breakpoint on `ExtractFromZipToFile`. When I double-clicked the JS file, the breakpoint triggered and I could confirm I'm on the right path.

# CheckUnZippedFile

One of the function calls I noticed nearby, revealed an interesting pattern in IDA. Right after the file is extracted and specific conditions are meet, `CheckUnZippedFile` function is called, followed by a call to `_OpenExplorerTempFile`, which opens the extracted file.

![](https://breakdev.org/content/images/2022/11/image-2.png)

Having a hunch that `CheckUnZippedFile` is the function responsible for adding MOTW to extracted file, I nopped its call and found that I stopped getting the MOTW warning popup, when I tried executing a JScript file from within the ZIP.

It was clear to me that if I managed to manipulate the execution flow in such a way that the branch, executing this function is skipped, I will be able to achieve the desired effect of bypassing the creation of MOTW on extracted files. I looked into the function to investigate further.

I noticed that `CheckUnZippedFile` tries to combine the TEMP folder path with the zipped file filename, extracted from the ZIP file, and when this function fails, the function quits, skipping the creation of MOTW file.

![](https://breakdev.org/content/images/2022/11/image-3.png)

Considering that I controlled the filename of the extracted ZIP file, I could possibly manipulate its content to trigger `PathCombineW` to fail and as a result achieve my goal.

`PathCombineW` turned out to be a wrapper around `PathCchCombineExW` function with output buffer size limit set to fixed value of `260` bytes. I thought that if I managed to create a really long filename or use some special characters, which would be ignored by the function handling the file extraction, but would trigger the length check in `CheckUnZippedFile` to fail, it could work.

I opened [010 Editor](https://www.sweetscape.com/010editor/), which I highly recommend for any kind of hex editing work, and opened my sample ZIP file with a built-in ZIP template.

![](https://breakdev.org/content/images/2022/11/image-4.png)

I spent few hours testing with different filename lengths, with different special characters, just to see if the extraction function would behave in erratic way. Unfortunately I found out that there was another path length check, called prior to the one I've been investigating. It triggered much earlier and prevented me from exploiting this one specific check. I had to start over and consider this path a dead end.

I looked if there are any controllable branching conditions, that would result in not triggering the call to `CheckUnZippedFile` at all, but none of them seemed to be dependent on any of the internal ZIP file parameters. I considered looking deeper into `CheckUnZippedFile` function and found out that when `PathCombineW` call succeeds, it creates a `CAttachmentServices` COM objects, which has its three methods called:

```
CAttachmentServices::SetReferrer(unsigned short const * __ptr64)
CAttachmentServices::SetSource(unsigned short const * __ptr64)
CAttachmentServices::SaveWithUI(struct HWND__ * __ptr64)
```

I realized I am about to go deep down a rabbit hole and I may spend there much longer than a hobby project like that should require. I had to get a public exploit sample to speed things up.

Huge thanks you [@bohops](https://twitter.com/bohops) & [@bufalloveflow](https://twitter.com/buffaloverflow) for all the help in getting the sample!

# Detonating the live sample

I managed to copy over all relevant ZIP file parameters from the obtained exploit sample into my test sample and I confirmed that MOTW was gone, when I extracted the sample JScript file.

I decided to dig deeper into `SaveWithUI` COM method to find the ...