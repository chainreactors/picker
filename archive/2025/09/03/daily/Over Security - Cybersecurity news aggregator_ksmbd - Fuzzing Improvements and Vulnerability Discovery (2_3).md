---
title: ksmbd - Fuzzing Improvements and Vulnerability Discovery (2/3)
url: https://blog.doyensec.com/2025/09/02/ksmbd-2.html
source: Over Security - Cybersecurity news aggregator
date: 2025-09-03
fetch_date: 2025-10-02T19:34:31.599893
---

# ksmbd - Fuzzing Improvements and Vulnerability Discovery (2/3)

[

](https://doyensec.com/img/home-video.mp4)

[![](/public/images/doyensec-logo.svg)](/index.html)

[![](/public/images/logo.svg)](/index.html)

#### ABOUT US

We are [**security engineers**](https://doyensec.com) who break bits and tell stories.

Visit us
[doyensec.com](https://doyensec.com)

Follow us
[@doyensec](https://twitter.com/doyensec)

Engage us
info@doyensec.com

#### Blog Archive

* 2025
* 2024
* 2023
* 2022
* 2021
* 2020
* 2019
* 2018
* 2017

© 2025 [Doyensec LLC](https://doyensec.com) [![](/public/images/rss.png)](/atom.xml "RSS")

# ksmbd - Fuzzing Improvements and Vulnerability Discovery (2/3)

02 Sep 2025 - Posted by Norbert Szetei

## Introduction

This is a follow-up to the article originally published [here](https://blog.doyensec.com/2025/01/07/ksmbd-1.html).

Our initial research uncovered several unauthenticated bugs, but we had only touched the attack surface lightly. Even after patching the code to bypass authentication, most interesting operations required interacting with handlers and state we initially omitted. In this part, we explain how we increased coverage and applied different fuzzing strategies to identify more bugs.

Some functionalities require additional configuration options. We tried to enable many available features to maximize the exposed attack surface. This helped us trigger code paths that are disabled in the minimalistic configuration [example](https://github.com/cifsd-team/ksmbd-tools/blob/master/ksmbd.conf.example#L61). However, to simplify our setup, we did not consider features like Kerberos support or RDMA. These could be targets for further improvement.

## Configuration-Dependent Attack Surface

The following functionalities helped expand the attack surface. Only oplocks are enabled by default.

**G** = Global scope only

* **durable handles (G)**
* **oplocks (S)**
* **server multi channel support (G)**
* **smb2 leases (G)**
* **vfs objects (S)**

From a code perspective, in addition to `smb2pdu.c`, these source files were involved:

* `ndr.c` â NDR encoding/decoding used in SMB structures
* `oplock.c` â Oplock request and break handling
* `smbacl.c` â Parsing and enforcement of SMB ACLs
* `vfs.c` â Interface to virtual file system operations
* `vfs_cache.c` â Cache layer for file and directory lookups

The remaining files in the `fs/smb/server` directory were either part of standard communication or exercising them required a more complex setup, as in the case of various authentication schemes.

## Fuzzer Improvements

SMB3 expects a valid session setup before most operations, and its authentication flow is multi-step, requiring correct ordering. Implementing valid Kerberos authentication was impractical for fuzzing.

As described in the first part, we patched the NTLMv2 authentication to be able to interact with resources. We also explicitly allowed guest accounts and specified `map to guest = bad user` to allow a fallback to âguestâ when credentials were invalid. After reporting [CVE-2024-50285: ksmbd: check outstanding simultaneous SMB operations](https://lore.kernel.org/linux-cve-announce/2024111946-CVE-2024-50285-6013%40gregkh/), credit limitations became more strict, so we patched that out as well to avoid rate limiting.

When we restarted syzkaller with a larger corpus, a few minutes later, all remaining candidates were rejected. After some investigation, we realized it was due to the default `max connections = 128`, which we had to increase to the maximum value 65536. No other limits were changed.

### State Management

SMB interactions are stateful, relying on sessions, TreeIDs, and FileIDs. Fuzzing required simulating valid transitions like `smb2_create` â¢ `smb2_ioctl` â¢ `smb2_close`. When we initiated operations such as `smb2_tree_connect`, `smb2_sess_setup`, or `smb2_create`, we manually parsed responses in the pseudo-syscall to extract resource identifiers and reused them in subsequent calls. Our harness was programmed to send multiple messages per pseudo-syscall.

Example code for resources parsing is displayed below:

```
// process response. does not contain +4B PDU length
void process_buffer(int msg_no, const char *buffer, size_t received) {
  // .. snip ..

    // Extract SMB2 command
  uint16_t cmd_rsp = u16((const uint8_t *)(buffer + CMD_OFFSET));
  debug("Response command: 0x%04x\n", cmd_rsp);

  switch (cmd_rsp) {
    case SMB2_TREE_CONNECT:
      if (received >= TREE_ID_OFFSET + sizeof(uint32_t)) {
        tree_id = u32((const uint8_t *)(buffer + TREE_ID_OFFSET));
        debug("Obtained tree_id: 0x%x\n", tree_id);
      }
      break;

    case SMB2_SESS_SETUP:
      // First session setup response carries session_id
      if (msg_no == 0x01 &&
          received >= SESSION_ID_OFFSET + sizeof(uint64_t)) {
        session_id = u64((const uint8_t *)(buffer + SESSION_ID_OFFSET));
        debug("Obtained session_id: 0x%llx\n", session_id);
      }
      break;

    case SMB2_CREATE:
      if (received >= CREATE_VFID_OFFSET + sizeof(uint64_t)) {
        persistent_file_id = u64((const uint8_t *)(buffer + CREATE_PFID_OFFSET));
        volatile_file_id   = u64((const uint8_t *)(buffer + CREATE_VFID_OFFSET));
        debug("Obtained p_fid: 0x%llx, v_fid: 0x%llx\n",
              persistent_file_id, volatile_file_id);
      }
      break;

    default:
      debug("Unknown command (0x%04x)\n", cmd_rsp);
      break;
  }
}
```

Another issue we had to solve was that ksmbd relies on global state-memory pools or session tables, which makes fuzzing less deterministic. We tried enabling the experimental [reset\_acc\_state](https://github.com/google/syzkaller/blob/bf27483f963359281b2d9b6d6efd36289f82e282/pkg/mgrconfig/config.go#L238) feature to reset accumulated state, but it slowed down fuzzing significantly. We decided to not care much about reproducibility, since each bug typically appeared in dozens or even hundreds of test cases. For the rest, we used focused fuzzing, as described below.

### Protocol Specification

We based our harness on the official SMB protocol specification by implementing a grammar for all supported SMB commands. Microsoft publishes detailed technical documents for SMB and other protocols as part of its [Open Specifications program](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-smb2/6eaf6e75-9c23-4eda-be99-c9223c60b181).

As an example, the wire format of the [SMB2 IOCTL Request](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-smb2/5c03c9d6-15de-48a2-9835-8fb37f8a79d8) is shown below:

![SMB2 IOCTL Request packet](../../../public/images/ksmbd_ioctl_request.png)

We then manually rewrote this specification into our grammar, which allowed our harness to automatically construct valid SMB2 IOCTL requests:

```
smb2_ioctl_req {
        Header_Prefix           SMB2Header_Prefix
        Command                 const[0xb, int16]
        Header_Suffix           SMB2Header_Suffix
        StructureSize           const[57, int16]
        Reserved                const[0, int16]
        CtlCode                 union_control_codes
        PersistentFileId        const[0x4, int64]
        VolatileFileId          const[0x0, int64]
        InputOffset             offsetof[Input, int32]
        InputCount              bytesize[Input, int32]
        MaxInputResponse        const[65536, int32]
        OutputOffset            offsetof[Output, int32]
        OutputCount             len[Output, int32]
        MaxOutputResponse       const[65536, int32]
        Flags                   int32[0:1]
        Reserved2               const[0, int32]
        Input                   array[int8]
        Output                  array[int8]
} [packed]
```

We did a final check against the source code to identify and verify possible mismatches during our translation.

## Fuzzing Strategies

Since we were curious about the bugs that might be missed when using only the default syzkaller configuration with a corpus generated from scratch, we expl...