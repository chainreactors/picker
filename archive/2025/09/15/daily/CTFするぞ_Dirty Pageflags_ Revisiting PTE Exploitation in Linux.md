---
title: Dirty Pageflags: Revisiting PTE Exploitation in Linux
url: https://ptr-yudai.hatenablog.com/entry/2025/09/14/180326
source: CTFするぞ
date: 2025-09-15
fetch_date: 2025-10-02T20:09:58.280011
---

# Dirty Pageflags: Revisiting PTE Exploitation in Linux

[![CTFするぞ](https://cdn.image.st-hatena.com/image/square/994ee0e012cf90178bff014bfd99123c02a89b36/backend=imagemagick;height=128;version=1;width=128/https%3A%2F%2Fcdn.user.blog.st-hatena.com%2Fblog_custom_icon%2F153103571%2F1535456424487441)](https://ptr-yudai.hatenablog.com/)

[CTFするぞ](https://ptr-yudai.hatenablog.com/)

[読者になる](https://blog.hatena.ne.jp/ptr-yudai/ptr-yudai.hatenablog.com/subscribe?utm_medium=button&utm_source=blogs_topright_button&utm_campaign=subscribe_blog)

# [CTFするぞ](https://ptr-yudai.hatenablog.com/)

## CTF以外のことも書くよ

[2025-09-14](https://ptr-yudai.hatenablog.com/archive/2025/09/14)

# [Dirty Pageflags: Revisiting PTE Exploitation in Linux](https://ptr-yudai.hatenablog.com/entry/2025/09/14/180326)

[Exploit](https://ptr-yudai.hatenablog.com/archive/category/Exploit)

**TL;DR**

By flipping the R/W bit in the page table entry of a mapped file (e.g., `/etc/passwd`), you can gain write [access](https://d.hatena.ne.jp/keyword/access) to the file.

* [What is Dirty Pagetable](#What-is-Dirty-Pagetable)
* [What is Dirty Pageflags](#What-is-Dirty-Pageflags)
* [Flipping R/W](#Flipping-RW)
* [PoC](#PoC)
* [Conclusion](#Conclusion)

# What is Dirty Pagetable

[Dirty Pagetable](https://yanglingxi1993.github.io/dirty_pagetable/dirty_pagetable.html) is a powerful exploitation technique that targets heap vulnerabilities in the [Linux](https://d.hatena.ne.jp/keyword/Linux) kernel.

The core idea is to overlap a freed object with a page table entry (PTE).
By writing to the freed object, an attacker can directly manipulate the page table.
Since each PTE maps to a physical memory address, this provides extremely strong control over physical memory.
As a result, Dirty Pagetable can bypass critical security mechanisms such as KASLR, [SMAP](https://d.hatena.ne.jp/keyword/SMAP), and SMEP.

If you are unfamiliar with this technique, the [original article](https://yanglingxi1993.github.io/dirty_pagetable/dirty_pagetable.html) offers a detailed explanation of how the attack works.

# What is Dirty Pageflags

Although Dirty Pagetable is already a powerful technique, I wanted to explore a simpler and more versatile approach. My focus shifted to the flags within a page-table entry (PTE). In [x86-64](https://d.hatena.ne.jp/keyword/x86-64), the structure of a PTE looks like the following:

![](https://cdn-ak.f.st-hatena.com/images/fotolife/p/ptr-yudai/20250912/20250912124501.png)

Fig 1. Structure of PTE in [x86-64](https://d.hatena.ne.jp/keyword/x86-64)

As you can see, it contains several flags such as XD, U/S, and R/W. Instead of overwriting the address field in the PTE, I decided to target these flags.

The following explains some important flags.

**P (Present)**

Indicates whether the page is currently present in physical memory.
If cleared (0), accessing the page triggers a page fault, and the OS may bring the page in from disk (demand paging).

**R/W (Read/Write)**

Controls whether the page is writable.
If set (1), both read and write operations are allowed.
If cleared (0), the page is read-only, and attempts to write to it will cause a protection fault.

**U/S (User/Supervisor)**

Defines the privilege level required to [access](https://d.hatena.ne.jp/keyword/access) the page.
If set (1), user-mode code (ring 3) can [access](https://d.hatena.ne.jp/keyword/access) the page.
If cleared (0), only supervisor mode (ring 0–2) can [access](https://d.hatena.ne.jp/keyword/access) it.

**D (Dirty)**

Set by the CPU when the page is written to.
This allows the OS to know whether the page needs to be written back to disk before being evicted.

**XD (Execute Disable)**

Also called NX (No-Execute).
If set (1), instruction fetches from the page are not allowed, preventing code execution.

Next, let’s examine which of these flags can make the exploit easier.

# Flipping R/W

Although some flags, such as U/S or XD, are related to security, modifying them is not as impactful as it might seem at first.
Because we can only control PTEs belonging to user space, flipping U/S simply removes [access](https://d.hatena.ne.jp/keyword/access) privileges and doesn't actually help exploitation.

While discussing which flags could be useful for privilege escalation with my colleague Dronex, he suggested targeting the **R/W** flag instead.

Consider a region of memory mapped as read-only.
If we flip the R/W flag in its PTE, the memory becomes writable.

On its own, this is not particularly useful. It's effectively the same as calling `mprotect` to change memory permissions.
However, the situation changes if the mapping is backed by a read-only file.

For example, suppose we open a file in read-only mode (e.g., `/etc/passwd`) and map it into memory at a certain address, as shown in Figure 2.

![](https://cdn-ak.f.st-hatena.com/images/fotolife/p/ptr-yudai/20250914/20250914175603.png)

Fig 2. Before flipping R/W

If we then flip the R/W bit, the mapped page becomes writable, allowing us to overwrite its contents (Figure 3).
At this stage, the change is still local to memory and it hasn't been written back to the file yet.
However, the CPU automatically sets the **D (Dirty)** bit in the PTE to indicate that the page has been modified.

![](https://cdn-ak.f.st-hatena.com/images/fotolife/p/ptr-yudai/20250914/20250914175615.png)

Fig 3. After flipping R/W and writing to the memory

Finally, when the memory is unmapped, the [Linux](https://d.hatena.ne.jp/keyword/Linux) kernel sees the D bit set and assumes the page must be written back to its backing file.
As a result, the supposedly read-only file is overwritten!

In some cases like use-after-free, however, we don't know which entry is modified.
Writing to an unmodified entry will result in SIGSEGV because it does not have R/W flag set.
To resolve this issue, we can use `read` syscall to write to the memory because `read` simply return -1 when it tried to write a read-only mapping, instead of crashing.

# PoC

I created a challenge based on Dirty Pageflags for BlackHat MEA 2025 Quals.

The goal of the challenge is to exploit a vulnerable [Linux](https://d.hatena.ne.jp/keyword/Linux) kernel module in order to gain root privileges.
The [vulnerability](https://d.hatena.ne.jp/keyword/vulnerability) is a straightforward use-after-free: you can increment a freed memory object twice.
(In fact, due to an unintended bug, it can actually be incremented infinitely.)

```
#define MAX_OBJ_NUM 0x100
#define PAD_SIZE    0x7f8

struct obj {
  char buf[PAD_SIZE];
  size_t cnt;
};

static struct kmem_cache *obj_cachep;
static DEFINE_MUTEX(module_lock);

unsigned char inc_used = 0;
struct obj *selected = 0;
struct obj *obj_array[MAX_OBJ_NUM] = { NULL };

static long module_ioctl(struct file *file, unsigned int cmd, unsigned long arg) {
  long ret = -EINVAL;
  mutex_lock(&module_lock);

  if (arg >= MAX_OBJ_NUM)
    goto out;

  switch (cmd) {
    case CMD_ALLOC:
      obj_array[arg] = kmem_cache_zalloc(obj_cachep, GFP_KERNEL);
      ret = 0;
      break;

    case CMD_SEL:
      if (!obj_array[arg])
        goto out;
      selected = obj_array[arg];
      ret = 0;
      break;

    case CMD_INC:
      if (inc_used++ > 1)
        goto out;
      selected->cnt++;
      ret = 0;
      break;

    case CMD_DELETE:
      if (!obj_array[arg])
        goto out;
      kmem_cache_free(obj_cachep, obj_array[arg]);
      obj_array[arg] = NULL;
      ret = 0;
      break;
  }

 out:
  mutex_unlock(&module_lock);
  return ret;
}
```

Bugs that allow incrementing a freed memory region like this are not uncommon.
For instance, CVE-2022-28350 is an example where a use-after-free enables manipulation of a reference counter.

In Dirty Pagetable, the attacker increments the counter 0x1000 times to point to an adjacent physical page, effectively achieving a physical page-level use-after-free.
However, this method is both complex and not applicable under the constraints of this challenge.

With Dirty Pageflags, the situation changes significantly.
The attacker first sprays...