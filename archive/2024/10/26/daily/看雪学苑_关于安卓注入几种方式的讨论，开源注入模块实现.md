---
title: 关于安卓注入几种方式的讨论，开源注入模块实现
url: https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458579138&idx=1&sn=fef09513ae9f594e68a503f69a312f4f&chksm=b18dc04886fa495e440990cd2dbddb24693452562e53bd8cb565063ddee921b7e288477f4eea&scene=58&subscene=0#rd
source: 看雪学苑
date: 2024-10-26
fetch_date: 2025-10-06T18:53:26.187259
---

# 关于安卓注入几种方式的讨论，开源注入模块实现

![cover_image](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8Ewib3icbyIPTfKJqGHsyhAVdX2tovarvA9D0e5MjMRiapTlFVN9IrpWRpArmnnuRAajJv3GCicez9WicA/0?wx_fmt=jpeg)

# 关于安卓注入几种方式的讨论，开源注入模块实现

mb\_qzwrkwda

看雪学苑

##

```
一

概念
```

在android系统中，进程之间是**相互隔离**的，两个进程之间是没办法直接跨进程访问其他进程的空间信息的。那么在android平台中要对某个app进程进行内存操作，并获取目标进程的地址空间内信息或者修改目标进程的地址空间内的私有信息，就需要涉及到注入技术。

通过**注入技术可以将指定so模块或代码注入到目标进程**中，只要注入成功后，就可以进行访问和篡改目标进程空间内的信息，包括数据和代码。

# 写这篇文章的初衷：

在我们进行算法还原再或者进行APP的RPC算法调用的时候，**都有对APP注入的需求**。

只不过目前的工具比较成熟，大家都**忽略了**注入的这个过程。

随着厂商对常见注入工具Frida、Xposed的**特征检测**，注入后APP会发生崩溃不可运行的问题。

众所周知：游戏安全对抗领域往往要比常见的应用安全领先多个领域，当然很**多大厂也开始上了策略检测注入**，但更多的只是风控策略，不会发生闪退（因为不同的厂商对于系统多少有些修改，万一有些系统会注入辅助so，那么会造成很大的误伤）

##

```
二

应用场景
```

例如BB企业版、爱加密企业版、360企业版都对frida、xposed等工具进行检测，那么我们就可以手动注入dobby hook 以及支持Java的一些sandhook 来辅助分析，当然分析效率没有frida高，但是不会触发闪退检测策略。（当然本工具后期有打算进一步开发隐藏注入，这对游戏安全是小儿科，但是应用安全隐藏的话效果还是很可观的）

所以本文章首先讨论多种注入方式，并给出开源的面具模块供大家编译使用，注入自己开发的so，或者是调用成品库，进行hook以及高性能的RPC。

本文会罗列出几个常见的注入技术，以及列出使用该原理的工具，并重点讲一下zygote注入的模块开发。

我会详细讲解我比较熟悉的两种注入方式（修改aosp、zygisk），以及简单带过一些可能的注入方式，并后续补充注入材料。

##

```
三

常见注入方式
```

### **静态注入（重打包，需要过签名检测）**

静态注入，静态解析ELF文件，增加一个依赖SO，或新增一个section节（注入代码在section字段），代码节是自己的注入代码，然后修复ELF文件结构。

修改dex，增加静态dex段，system.load 加载自己的so

实现案例：平头哥，一些虚拟xposed框架。

```
static {
        try {
            String soName;
            if (Process.is64Bit()) {
                soName = path/to/lib64;
            } else {
                soName = path/to/lib32;
            }
            System.loadLibrary(soName);
        } catch (Throwable e) {
            CLog.e("static loadLibrary error", e);
        }
}
```

这种方式的优点：

免root、便于分发、打包速度一般

缺点：

对于签名检测的pass难度比较高

## **动态注入（基于系统提供的调试API注入）**

### ptrace注入

\*\*由于Android是基于linux内核的操作系统，所以Android下的注入也是基于Linux下的系统调用函数`ptrace()`实现的。\*\*即在获得root权限后，通过ptrace()系统调用将stub（桩代码）注入到指定pid的进程中。

常见使用工具：IDA、GDB、LLDB、Frida等常见工具

我们也可以自己写一个ptrace简单的注入so，下面我给出一个项目，感兴趣的大佬可以自己编译进行尝试。

这里进行**预告**：后面我会自己写一个调试器（基于ptrace），会写出文章进行分享，目前已经在做了。

这里简单附上几篇ptrace的文章，感兴趣的大佬可以尝试。

因为我研究的实在是不多。

https://blog.csdn.net/hp910315/article/details/77335058

https://blog.csdn.net/jinzhuojun/article/details/9900105

这种方式的优点：

注入速度快，注入不容易检测到（ptrace注入完成以后直接取消ptrace，在后面检测不到）

缺点：

需要root、有一定的ptrace检测（像ida这样的注入，会在maps扫描到当前正在被调试）

attach方式被ptrace占坑方式搞得不好绕过（ida表示非常难受）。

### zygote注入

常见使用工具：xposed 实现工具：Riru(早期)、Zygisk（常用）

zygote注入是属于全局注入的方式，它主要是依赖于fork()子进程方式进行注入的。

目前市面上比较成熟的注入工具xposed就是基于zygote的全局注入。

它有两大优点:主要在于zygote是系统进程，通过系统进程fork出来后它就具备隐蔽性，强大性。

常见的一些工具都是使用Zygisk注入，比如知名的开源项目**Zygisk-Il2CppDumper**

以及寒冰大佬开发的FrdiaManager 还有Xposed框架都支持Zygsik注入

下面我来讲一下我开发的模块是如何注入自己的so的（本模块是基于Zygisk-Il2CppDumper项目进行修改，因为作者写的Gradle实在是太好用啦）

## 系统注入（修改AOSP源码，进行插桩）

通过修改aosp系统的源码，在app加载之前插桩语句，加载自定义库。

后面会有一个小模块进行讨论。

##

```
四

Zygisk自定义注入so(dex)插件的实现
```

#

## 模块开发前置知识

```
class ModuleBase {
public:

    // 这个方法在模块被加载到目标进程时立即被调用。
    // 会传递一个 Zygisk API 句柄作为参数。
    virtual void onLoad([[maybe_unused]] Api *api, [[maybe_unused]] JNIEnv *env) {}

    // 这个方法在应用进程被专门化之前被调用。
    // 在这个时候，进程刚刚从 zygote 进程中分叉出来，但尚未应用任何特定于应用的专门化。
    // 这意味着进程没有任何沙箱限制，并且仍然以 zygote 的相同权限运行。
    //
    // 所有将要传递并用于应用程序专门化的参数都被封装在一个 AppSpecializeArgs 对象中。
    // 您可以读取和覆盖这些参数，以改变应用程序进程的专门化方式。
    //
    // 如果您需要以超级用户权限运行一些操作，可以调用 Api::connectCompanion() 来
    // 获取一个套接字，用于与根陪伴进程进行 IPC 调用。
    // 请参阅 Api::connectCompanion() 以获取更多信息。
    virtual void preAppSpecialize([[maybe_unused]] AppSpecializeArgs *args) {}

    // 这个方法在应用进程专门化之后被调用。
    // 在这个时候，进程已经应用了所有沙箱限制，并以应用自身代码的权限运行。
    virtual void postAppSpecialize([[maybe_unused]] const AppSpecializeArgs *args) {}

    // 这个方法在系统服务器进程被专门化之前被调用。
    // 请参阅 preAppSpecialize(args) 以获取更多信息。
    virtual void preServerSpecialize([[maybe_unused]] ServerSpecializeArgs *args) {}

    // 这个方法在系统服务器进程专门化之后被调用。
    // 在这个时候，进程以 system_server 的权限运行。
    virtual void postServerSpecialize([[maybe_unused]] const ServerSpecializeArgs *args) {}
};
```

重点就是这几个api, 看注释理解。

用最通俗粗略的理解来表示的话：
pre是刚从zygote fork出来没有沙箱限制的时候。

postAppSpecialize 相当于app进程启动, 这里可以做自定义dex加载的一些动作。

postServerSpecialize 相当于系统服务也就是system server 运行。

官方提供了一个https://github.com/topjohnwu/zygisk-module-sample案例，也可以读一读。

## 模块实现细节：

实现原理非常简单：从app可以访问的路径copy要注入的so到自己的私有目录(因为有selinux的限制）。

之后使用dl\_open加载目标so：

```
#include <cstring>
#include <thread>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <cinttypes>
#include "hack.h"
#include "zygisk.hpp"
#include "game.h"
#include "log.h"
#include "dlfcn.h"
using zygisk::Api;
using zygisk::AppSpecializeArgs;
using zygisk::ServerSpecializeArgs;

class MyModule : public zygisk::ModuleBase {
public:
    void onLoad(Api *api, JNIEnv *env) override {
        this->api = api;
        this->env = env;
    }

    void preAppSpecialize(AppSpecializeArgs *args) override {
        auto package_name = env->GetStringUTFChars(args->nice_name, nullptr);
        auto app_data_dir = env->GetStringUTFChars(args->app_data_dir, nullptr);
        LOGI("preAppSpecialize %s %s", package_name, app_data_dir);
        preSpecialize(package_name, app_data_dir);
        env->ReleaseStringUTFChars(args->nice_name, package_name);
        env->ReleaseStringUTFChars(args->app_data_dir, app_data_dir);
    }

    void postAppSpecialize(const AppSpecializeArgs *) override {
        if (enable_hack) {
            std::thread hack_thread(hack_prepare, _data_dir, data, length);
            hack_thread.detach();
        }
    }

private:
    Api *api;
    JNIEnv *env;
    bool enable_hack;
    char *_data_dir;
    void *data;
    size_t length;

    void preSpecialize(const char *package_name, const char *app_data_dir) {
        if (strcmp(package_name, AimPackageName) == 0) {
            LOGI("成功注入目标进程: %s", package_name);
            enable_hack = true;
            _data_dir = new char[strlen(app_data_dir) + 1];
            strcpy(_data_dir, app_data_dir);

#if defined(__i386__)
            auto path = "zygisk/armeabi-v7a.so";
#endif
#if defined(__x86_64__)
            auto path = "zygisk/arm64-v8a.so";
#endif
#if defined(__i386__) || defined(__x86_64__)
            int dirfd = api->getModuleDir();
            int fd = openat(dirfd, path, O_RDONLY);
            if (fd != -1) {
                struct stat sb{};
                fstat(fd, &sb);
                length = sb.st_size;
                data = mmap(nullptr, length, PROT_READ, MAP_PRIVATE, fd, 0);
                close(fd);
            } else {
                LOGW("Unable to open arm file");
            }
#endif
        } else {
            api->setOption(zygisk::Option::DLCLOSE_MODULE_LIBRARY);
        }
    }
};

REGISTER_ZYGISK_MODULE(MyModule)
```

这里主要实现了面具模块主要提供的api：

```
 void preAppSpecialize(AppSpecializeArgs *args) override {
        auto package_name = env->GetStringUTFChars(args->nice_name, nullptr);
        auto app_data_dir = env->GetStringUTFChars(args->app_data_dir, nullptr);
        LOGI("preAppSpecialize %s %s", package_name, app_data_dir);
        preSpecialize(package_name, app_data_dir);
        env->ReleaseStringUTFChars(args->nice_name, package_name);
        env->ReleaseStringUTFChars(args->app_data_dir, app_data_dir);
    }
```

我们的实现主要是这个实现的函数，此时app已经处于沙盒中了，只有app自身的权限。

```
 if (strcmp(package_name, AimPackageName) == 0) {
            LOGI("成功注入目标进程: %s", package_name);
            enable_hack = true;
            _data_dir = new char[strlen(app_data_dir) + 1];
            strcpy(_data_dir, app_data_dir);
```

在这里我们需要修改要注入的包名，不然模块不会进一步注入。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Ewib3icbyIPTfKJqGHsyhAVdtNtHCjQRRPW1GhRsmVicv7z4g1W78cPfXe9vWCdHiav84HI6x32T0Mww/640?wx_fmt=png&from=appmsg)

主要功能实现：

```
void hack_start(const char *game_data_dir,JavaVM *vm) {
    bool load = false;
    LOGI("hack_start %s", game_data_dir);
    // 构建新文件路径
    char new_so_path[256];
    snprintf(new_so_path, sizeof(new_so_path), "%s/files/%s.so", game_data_dir, "test");

    // 复制 /sdcard/test.so 到 game_data_dir 并重命名
    const char *src_path = "/data/local/tmp/test.so";
    int src_fd = open(sr...