---
title: Chrome Browser Exploitation, Part 1: Introduction to V8 and JavaScript Internals
url: https://jhalon.github.io/chrome-browser-exploitation-1/
source: Jack Hacks
date: 2022-10-23
fetch_date: 2025-10-03T20:42:34.005315
---

# Chrome Browser Exploitation, Part 1: Introduction to V8 and JavaScript Internals

* [Jack Hacks](https://jhalon.github.io/)
* [Posts](https://jhalon.github.io/posts.html)
* [Categories](https://jhalon.github.io/categories.html)
* [About](https://jhalon.github.io/about.html)

# Chrome Browser Exploitation, Part 1: Introduction to V8 and JavaScript Internals

![Jack Halon](https://jhalon.github.io/images/bio_chibi.png)

### Jack Halon

I like to break into things; both physically and virtually.

Follow

* United States
* Email
* [Twitter](https://twitter.com/jack_halon)
* [LinkedIn](https://www.linkedin.com/in/jacek-halon-683912b0)
* [Github](https://github.com/jhalon/)
* [YouTube](https://www.youtube.com/user/../JackHacks)

Web browsers, our extensive gateway to the internet. Browsers today play a vital role in modern organizations as more and more software applications are delivered to users via a web browser in the form of web applications. Pretty much everything you might have done on the internet involves the use of a web browser, and as a result, browsers are among the most utilized consumer facing software products on the planet.

As the gateway to the internet, browsers also introduce significant risks to the integrity of personal computing devices. We hear it almost on a daily basis now, “[Google Chrome Bug Actively Exploited as Zero-Day](https://threatpost.com/google-chrome-bug-actively-exploited-zero-day/179161/)”, or “[Google Confirms Chrome’s Fourth Zero-Day Exploit In 2022](https://www.forbes.com/sites/gordonkelly/2022/07/06/google-chrome-browser-zero-day-hack-new-threat-exploit-upda-chrome/?sh=12daf8a5185f)”. In fact, browser exploits are nothing new, they’ve been occurring for years now with the first known documented remote-code-execution exploit being [CVE-1999-0280](https://www.cvedetails.com/cve/CVE-1999-0280/). The first potentially public disclosure of a browser exploit being used in the wild was the “[Aurora](https://www.youtube.com/watch?v=przDcQe6n5o)” Internet Explorer exploit which affected Google back in December of 2010.

My interest in web browsers first sparked back in 2018 when my buddy [Michael Weber](https://twitter.com/BouncyHat) introduced me to [Offensive Browser Extension Development](http://www.irongeek.com/i.php?page=videos/derbycon8/track-4-02-offensive-browser-extension-development-michael-weber) which really opened my eyes to the potential attack surface. Afterwards, I started to dig deeper into Chrome’s internals and started to become very interested in web browser exploitation. Because let’s be honest here, what kind of Red Team wouldn’t want a “one-click” or even a “no-click” web browser exploit?

When it comes to browsers in the world of security research, they are considered some of the most impressive targets to find vulnerabilities in. They’re also unfortunately some of the most complicated to look at, as the amount of prerequisite knowledge required to even begin researching browser internals makes it seem like an unattainable goal for many researchers.

In spite of that, I took the steps to dive in by taking [maxpl0it’s](https://twitter.com/maxpl0it) amazing “[Introduction to Hard Target Internals](https://www.blackhat.com/us-22/training/schedule/#introduction-to-hard-target-internals-25711)” training course. Which I highly recommend you take! This course provided me with a lot of background information on the inner workings and internals of browsers such as Chrome and Firefox. Afterwards, I was off to the races reading everything I could from Chromium blogs to v8 dev posts.

Since my learning method is more of a “learn it, teach it, know it” style, I am releasing this “Chrome Browser Exploitation” blog post series to give you an introduction to browser internals and to explore Chrome browser exploitation on Windows in more depth, all while learning it myself.

Now you might be asking me, why Chrome and why Windows? Well, two reasons:

1. Chrome has a market share of ~73%, making it the most widely used browser in the world.
2. Windows has a market share of ~90%, making it also the most widely used OS in the world.

By learning to target the most widely used software in the world, as a Red Team, this makes our chances of finding bugs, writing exploits, and successfully using them in engagements much more likely.

> **WARNING** Due to the massive complexity of browsers, JavaScript engines, and JIT compilers, these blog posts will be very, very heavy reads.
>
> Currently, this will be a three (3) post blog series. But, depending on the complexity and amount of information covered, I might split up the material to multiple additional posts.
>
> Do note - I am writing these blog posts as I learn along the way. So please bare with me as it might take some time for me to release follow up posts to this series.
>
> With that being said, if you notice that I made a mistake in my posts, or am misleading the reader, then please reach out to me! Also, any recommendations, constructive criticism, critical feedback, etc. is very much appreciated!

Overall, by the end of this blog post series we will cover everything we need to know to start researching and exploiting potential Chrome bugs. In the final post of this series, we will attempt to exploit [CVE-2018-17463](https://chromereleases.googleblog.com/2018/10/stable-channel-update-for-desktop.html) which was a JIT Compiler Vulnerability in Chrome v8’s Optimizer (TurboFan) discovered by [Samuel Gross](https://twitter.com/5aelo).

So, without further ado - let’s jump into the deep end and into the complex world of browser exploitation!

In today’s blog post, we will cover the basic prerequisite concepts that we need to fully understand before we dig any deeper. The following topics will be discussed:

* The Flow of JavaScript Engines
  + JavaScript Engine Compiler Pipeline
  + Stack & Register Machines
* JavaScript and V8 Internals
  + Object Representation
  + HiddenClasses (Map)
  + Shape (Map) Transitions
  + Properties
  + Elements and Arrays
* Viewing Chrome Objects In-Memory
  + Pointer Tagging
  + Pointer Compression

But, before we begin, make sure to compile `v8` and `d8` on Windows to follow along. You can read my “[Building Chrome V8 on Windows](https://gist.github.com/jhalon/5cbaab99dccadbf8e783921358020159)” gist for detailed instructions on how to do so.

## The Flow of JavaScript Engines

We start our journey of browser internals by first understanding what JavaScript engines are and how they work. JavaScript engines are an integral part to the execution of JavaScript code on systems. Previously, they were mere interpreters, but today, modern JavaScript engines are complex programs that include a multitude of performance improving components such as optimizing-compilers and Just-In-Time (JIT) compilation.

There’s actually a multitude of different JS engines in use today, such as:

* [V8](https://v8.dev/) - Google’s open source high-performance JavaScript and WebAssembly engine, used in Chrome.
* [SpiderMonkey](https://spidermonkey.dev/) - Mozilla’s JavaScript and WebAssembly Engine, used in Firefox.
* [Charka](https://github.com/chakra-core/ChakraCore) - A proprietary JScript engine developed by Microsoft for use in IE and Edge.
* [JavaScriptCore](https://developer.apple.com/documentation/javascriptcore) - Apple’s built-in JavaScript engine for WebKit use in Safari.

So why do we need these JavaScript engines, and all it’s complexities?

Well as we know, JavaScript is a lightweight, **interpreted**, object-oriented scripting language. In interpreted languages, the code is ran line-by-line and the result of running the code is immediately returned, so we don’t have to compile the code into a different form before the browser runs it. This usually doesn’t make such languages any good due to performance reasons. In that case, this is where compilation such as Just-In-Time compilation is involved; where JavaScript code is parsed into bytecode (which is an abstraction of machine code) and is then further optimized by JIT to make th...