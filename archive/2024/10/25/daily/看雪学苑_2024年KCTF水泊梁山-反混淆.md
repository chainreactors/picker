---
title: 2024年KCTF水泊梁山-反混淆
url: https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458579017&idx=2&sn=a97dacde8a6c913108999da8a96a667f&chksm=b18dc0c386fa49d57ce9f0ce6923690d6eb8efb3ccb8032e8c6b923184af3dd29b1b4471f9a2&scene=58&subscene=0#rd
source: 看雪学苑
date: 2024-10-25
fetch_date: 2025-10-06T18:51:55.948505
---

# 2024年KCTF水泊梁山-反混淆

![cover_image](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8GwibzZr1MfxQ2NHDbgchp4gKIP3Mpl3Gzrvib6F9DxQSfDJn0Uibx8X6OBUk2W0Ogyja0W3IbQib0Xzw/0?wx_fmt=jpeg)

# 2024年KCTF水泊梁山-反混淆

zZhouQing

看雪学苑

首先，这道题内容一般，所以我会结合《加密与解密（第四版）》的内容讲一些基础的东西，帮助没有基础的朋友过渡一下。幸运得是，我也正好忘记掉这道题是如何编写的了。

```
一

程序内存布局
```

可以看到，程序是添加混淆了的，有着俩个区段，分别为`obf`和`obf`。（其中一个用于存储数据，一个用于执行代码）

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GwibzZr1MfxQ2NHDbgchp4gk8ptz8fGJGHPcf4QkaNMoTZsjn92QjcyAoOVMX79GwgxZZOPWRiahoA/640?wx_fmt=png&from=appmsg)

```
二

混淆
```

可以看到，程序的混淆与栈相勾连。但是，我们的经验可以告诉我们，这个混淆似乎仅仅只是做了指令变形，而无代码乱序的功能。这对于反混淆来说，是一个非常重要的消息。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GwibzZr1MfxQ2NHDbgchp4gKtcSz6nuuuJUu727m3JK0s4eqnKfhJTxJWbYezoEbkKfY7TZLy0ssg/640?wx_fmt=png&from=appmsg)

```
三

反混淆
```

我们已经知道了混淆并无代码乱序的功能（代码乱序会使线性扫描算法出现错误），于是，我们对应的反汇编算法既可以是`线性扫描算法`，也可以是`递归行进算法`。出于方便，这里使用线性扫描算法。

### 机器码层的特征码匹配

这一技术，应该常见于早期的`花指令`对抗，混淆通过添加基于固定模式生成的花指令达到抵御静态分析的效果，而反混淆（机器码层的特征码匹配）则将混淆中的固定模式转化为字节形式的模板，通过特征匹配，将对应的代码删除，达到反混淆的目的。

```
;           pushf
;           jb      loc_3
;loc_1:     jmp     loc_2
;                   _ONE_BYTE_JUNKCODE_
;loc_2:     call    loc_4
;                   _TWO_BYTE_JUNKCODE_
;loc_3:     jb      loc_1
;                   _ONE_BYTE_JUNKCODE_
;loc_4:     add     esp,4
;           popf
;           jmp     loc_5
;                   _ONE_BYTE_JUNKCODE_
;loc_5:     ....

S = 9C720AEB01??E805000000????72F4??83C4049DEB01??
R = 9090909090909090909090909090909090909090909090
```

在这里，由于技术过于古老，反混淆效果不太好，我仅作一个示例。发现程序具有如下特征，提取特征码，编写脚本进行反混淆。

```
// asm
pushfd
push dword ptr ds:[433098]
pop dword ptr ds:[433038]
popfd
// machine
9C FF 35 98 30 43 00 8F 05 38 30 43 00 9D
// sig
9C FF 35 ?? ?? ?? ?? 8F 05 ?? ?? ?? ?? 9D
// patch
90 90 90 90 90 90 90 90 90 90 90 90 90 90
// script MAX_REF_COUNT 为 5000 所以需要多次运行脚本
findall 00A41000, "9C FF 35 ?? ?? ?? ?? 8F 05 ?? ?? ?? ?? 9D"
i = 0
loop:
  memset  ref.addr(i),90,E
  i++
  cmp i, ref.count()
  jne loop
```

由于使用的是`memset`命令来去除花指令，而该命令作用后，并不会将修改结果保存到`补丁`当中。所以，这里使用`scylla`（x64dbg 配套插件）来保存修改后的程序。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GwibzZr1MfxQ2NHDbgchp4gNdMoZicXWkeqQZ0ymvEZq7VNoicicKNsE7pibg7b4h3GDMzShibYIzm4vzg/640?wx_fmt=png&from=appmsg)

Dbg 将程序停在`EP`（EntryPoint）的位置，scylla 依次点击`Dump`->`PE Rebuild`。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GwibzZr1MfxQ2NHDbgchp4gxOIlD56ChBCHiaoo4yzjvM7PpdgspWPa6mic7dZ0sv2De8UqTqmCN2DQ/640?wx_fmt=png&from=appmsg)

可以看到，经过修改后的程序能够正常运行，同时程序的硬盘占用大大减小。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GwibzZr1MfxQ2NHDbgchp4gqW3rtGcspKHpnz9r2mFWPXnGu1VOriaLLQ6ibyWRkDg5KqpGXtic05iaDw/640?wx_fmt=png&from=appmsg)

由于这里仅出于演示目的，我并未考虑将那样特征的汇编删去有何后果，很有可能是不会正常运行的。但，反混淆，就应该多尝试，甚至不需要程序能够正常运行，毕竟时间有限，能将关键代码显现出来即可。

### 汇编层的特征码匹配

这一技术，常见于早期 VM 对抗的 handle 匹配或是常见密码学的特征匹配。我看到坛友`tacesrever`就是通过这一方式来反混淆的，但是效果不佳。

这里举个例子，我们将这样的特征匹配为 VADD\_Q。

```
mov     rax, [rbp+0]
add     [rbp+8], rax
pushfq
pop     qword ptr [rbp+0]

可以发现，这段程序做了个 add 指令，然后保存了 rflags。

总的来说，它是一个 add 类型的 handle。
```

当然，这一技术不仅仅是化简程序的流程，还可以用来还原本题的`CF`（控制流：control flow）。IDA 打开经过第一次修改的程序`kctf_crackme_sbls_dump.exe`。

可以看到，有个立即数`sub_A41F0D`，IDA 转过去发现，正是下一个基本块。而`dword_4AA610`与`0Ah`进行异或，值是`0042A9E0`，IDA 转过去发现，是`_alloca_probe`函数。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GwibzZr1MfxQ2NHDbgchp4gEvzSRkHAv5DPITV0khtqLKvNlbTeG4P152OqT0KFy6gHzS5M0dbGrw/640?wx_fmt=png&from=appmsg)

看样子我们可以知道了，混淆对`Call Imm`的指令做了变形，导致 IDA 的控制流分析失败了。利用`python`编写个简单的脚本还原即可。还记得上文提到的`线性扫描算法`吗？就是从一个`base`开始死循环反汇编，脚本自己会异常打印日志的。

```
from capstone import *

CODE = open(r"f:\新建文件夹\样本\dmp\kctf_crackme_sbls_00A41000.bin", mode='rb').read()
md = Cs(CS_ARCH_X86, CS_MODE_32)
md.detail = True

def MdDisasmLiteOne(md:Cs,eipCode,obfBase):
    for v in md.disasm(eipCode, obfBase,1):
        return v

def PrintIns(ins:CsInsn):
    print("0x%x:\t%s\t%s" %(ins.address, ins.mnemonic, ins.op_str))
    return

base = 0x00400000
obfBase = 0x000A41000

eipBlockAddress = obfBase-base
eipCode = CODE[eipBlockAddress:eipBlockAddress+16]

currentBlockList = []
ins = MdDisasmLiteOne(md=md,eipCode=eipCode,obfBase=obfBase)

scriptInsList = []

def ReadDword(addr):
    fov = addr - base
    v = CODE[fov:fov +4]
    v = int.from_bytes(v,"little")
    return v

def PrintScriptInsList(scriptInsList:list):
    for i in scriptInsList:
        print(i + ";")

def PrintScriptInsListOne(scriptInsList:list):
    v = ""
    for i in scriptInsList:
        v += i + ";"
    print(v)

def WriteScriptInsList(scriptInsList:list):
    fo = open("reverseCFG.txt", "w")
    fo.write("")
    fo = open("reverseCFG.txt", "a")

    for i in scriptInsList:
        fo.write(i + "\r\n")

def WriteScriptInsListOne(scriptInsList:list):
    fo = open("reverseCFG.txt", "w")
    v = ""
    for i in scriptInsList:
        v += i + ";"
    fo.write(v)

try:
    while 1:
        # PrintIns(ins=ins)
        currentBlockList.append(ins)
        if ins.mnemonic == "ret":
            nextBlockIpIns:CsInsn = currentBlockList[len(currentBlockList) - 4]
            if nextBlockIpIns.mnemonic == "push":
                nextBlockIp = nextBlockIpIns.operands[0].imm

                callImmIns:CsInsn = currentBlockList[len(currentBlockList) - 3]
                callImmEnPoint = 0
                callImmEn = 0
                callImmKey = 0
                callImm = 0
                if callImmIns.mnemonic == "push":
                    callImmEnPoint = callImmIns.operands[0].mem.disp
                    callImmEn = ReadDword(callImmEnPoint)
                callImmKeyIns:CsInsn = currentBlockList[len(currentBlockList) - 2]
                if callImmKeyIns.mnemonic == "xor":
                    callImmKey = callImmKeyIns.operands[1].imm

                callImm = callImmEn ^ callImmKey
                # print(hex(callImm))
                # print(hex(nextBlockIp))

                # scriptInsList.append("asm {},nop,1".format(hex(callImmIns.address)))
                scriptInsList.append("asm {},nop,1".format(hex(callImmKeyIns.address)))
                scriptInsList.append("asm {},nop,1".format(hex(ins.address)))
                scriptInsList.append("asm {},\"call {}\",1".format(hex(nextBlockIpIns.address),hex(callImm)))

                scriptInsList.append("asm {},\"jmp {}\",1".format(hex(callImmIns.address),hex(nextBlockIp)))

                nextfov = nextBlockIp-base
                eipCode = CODE[nextfov:nextfov+16]
                ins = MdDisasmLiteOne(md=md,eipCode=eipCode,obfBase=nextBlockIp)

                # PrintIns(ins=ins)
                continue

        nextip = ins.address+ins.size
        nextfov = nextip-base
        eipCode = CODE[nextfov:nextfov+16]
        ins = MdDisasmLiteOne(md=md,eipCode=eipCode,obfBase=nextip)
except:
        WriteScriptInsList(scriptInsList)

print("over")
```

由于生成的去混淆脚本内容较长，这里不贴出了。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GwibzZr1MfxQ2NHDbgchp4gJNXBKnicZHPjcHkYgzHBhQ42SyTFsAt7wkC9kDh7cwyXpIYIvwiblblA/640?wx_fmt=png&from=appmsg)

这一个脚本还不足以还原完整的`CF`，因为`Call`指令分为四种类型。（这里并未使用 intel 指令语法）

◆call imm

◆call [mem]

◆call reg

◆call [reg+offset]

提取三次汇编特征，编写三个脚本就能还原，有了第一次的经验，复制粘贴一下就行了。经过三次修复，IDA 已经能够正常显示 CFG 了。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GwibzZr1MfxQ2NHDbgchp4gNLYn4Lu2l6wpC6eP9OEEc89oXE9BwXoXmoLrgVUZNugHx44ky775NA/640?wx_fmt=png&from=appmsg)

本想写到这里便停下的，不过，看到`tacesrever`通过汇编匹配来还原原始的汇编指令，我也写个脚本来做个简单的化简好了。IDA 将程序`main`函数反编译后，可以发现这样形式的全局变量。这个全局变量有俩次读，一次写的操作。

```
r sub_xxx+offset push ds:dword_43CC68
r sub_xxx+offset push ds:dword_43CC68
w sub_xxx+offset mov ds:dword_43CC68,4BFD4h
```

而读操作却是这样的，这样的汇编指令可以直接化简为`push eax`。看样子。这样的全局变量可以直接删除了。

```
push    ds:dword_4AA100
mov     [esp], eax
```

又浏览了几个全局变量，发现还有这样形式的，这样的全局变量似乎是参与运算了，保留即可。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GwibzZr1MfxQ2NHDbgchp4g8Tuk5WuN6xXOsyX200hJ8Ynt7cezyKDhQROeV4rg4rvTsuYlMbJYxg/640?wx_fmt=png&from=appmsg)

编写脚本，做第六次反混淆操作，依旧是套用第二次的模板。（第一次为机器码匹配）

```
from capstone import *

CODE = open(r"f:\新建文件夹\样本\dmp\kctf_crackme_sbls_00A41000.bin", mode='rb').read()
md = Cs(CS_ARCH_X86, CS_MODE_32...