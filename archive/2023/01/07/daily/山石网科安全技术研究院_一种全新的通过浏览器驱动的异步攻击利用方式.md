---
title: 一种全新的通过浏览器驱动的异步攻击利用方式
url: https://mp.weixin.qq.com/s?__biz=MzUzMDUxNTE1Mw==&mid=2247499412&idx=1&sn=dfa5b34a4bf739f45a27151569112232&chksm=fa522b2acd25a23c71ff1fa0f012ae615727c32d24accd01ecedbc3b3cc0b331a439d99f01ed&scene=58&subscene=0#rd
source: 山石网科安全技术研究院
date: 2023-01-07
fetch_date: 2025-10-04T03:16:00.441758
---

# 一种全新的通过浏览器驱动的异步攻击利用方式

![cover_image](https://mmbiz.qpic.cn/mmbiz_jpg/Gw8FuwXLJnQfVdHZeNTwrfQrBS5C2YDibdicL2GI5skkJVoAsAgR26bnjcXZ6kMcFmwt6SU7cMkep3KdHJUbqh8A/0?wx_fmt=jpeg)

# 一种全新的通过浏览器驱动的异步攻击利用方式

原创

HhhM

山石网科安全技术研究院

**0****1**

**TL;DR**

HTTP请求走私作为一种新兴漏洞，利用面相对来说还是比较单一，仅仅是针对具有反向代理的站点，因此作者选择将请求走私的战场转移到用户的Web浏览器中，将请求走私转移到了单服务网站和内部网络中。

利用跨域请求和服务器存在的缺陷搭配，其效果包括：危害到浏览器连接池、安装后门、蠕虫，与此同时也发掘出了包括客户端，服务器端甚至MITM攻击，同时作者也给出了挖掘到的几个相关漏洞。

本篇多数内容建立在：

- https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn

- https://portswigger.net/research/http2

若有觉得本篇部分内容有过于简陋之处，也许在上述两篇中有详细讲到。

本文大致从以下几点讲述：

- 因HTTP处理异常导致的一系列漏洞，其中还有一处 amazon.com 和 AWS 应用程序负载均衡器中的严重缺陷。

- 客户端异步，即摘要中提到的危害浏览器连接池，主要受害者是CDN、Web VPN。

- 基于延时的异步，可用于服务器端和客户端。

- 结论

**02****‍**

**HTTP handling anomalies**‍‍‍‍‍

本节讲述通过4个单独的漏洞导致浏览器驱动的异步攻击，其中部分内容在作者以往的议题中有提到过。

### Connection state attacks

围绕一个关键点那就是HTTP连接并不是单一的、独立的实体，而是可以被复用的。在抓包软件没有出现之前几乎都是通过浏览器访问服务器，因此服务器假设每个发送给TLS连接HTTP/1.1请求必须有相同的目标和host头，此时毫无意外都会正常工作。

作者发现了两种类型的缺陷。

* 首次请求验证

顾名思义，服务器仅针对首次接受到的请求做验证，假设如下两次单独分开的请求：

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnSMSBtGFJh6WyIiaQxJLXialvAlwCsvMHbOjkXCGCSNQ4UphG3K9mOSzxqZwsWtKrQmy6iaro5D40OOg/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnSMSBtGFJh6WyIiaQxJLXialvrItAy3gticxY1fgb4Q7ObE56X6cSCBH1hO7qWZsVevicEqkA4dMaBCAA/640?wx_fmt=png)

理所当然第二个host不在白名单中，而利用burp使HTTP连接复用发送两个请求时会发现成功绕过了白名单，如下：

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnSMSBtGFJh6WyIiaQxJLXialvzg5TrHpPOMfiaXvDOXrkbQIGxNSN9XBCkUFV2vWkUsEEWAo9oOK7n4g/640?wx_fmt=png)

也就是说所谓的白名单只不过是针对连接中发送的第一个请求，而随后的请求中可以无视名单限制，当然这一缺陷并不存在于大部分机器中，属于是比较少见的存在。

* 首次请求路由

当服务器决定将第一个请求的host当做标识，随后所有来自同一客户端连接的请求路由都自动转发到同一host，那么这时候就会造成一些例如缓存投毒，密码重置投毒等的攻击。

例如：

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnSMSBtGFJh6WyIiaQxJLXialvmeESdf2mrJIibEgvXUpicfrhOx9sk9mQ3boCQBfbqh5R8SDDZeS8GveQ/640?wx_fmt=png)

正常请求下期望服务器解析我们的evil host并拼接到重置密码连接中一并发送给用户，但显然服务器不会接受。

通过首次请求路由走私的方式来让我们的请求成功达到后端服务器中：

这时候重置连接将发送给受害者，如：

```
Click here to reset your password: https://psres.net/reset?k=secret
```

### The surprise factor

大多数请求走私都是通过修改请求长度，使得前后端服务器对于请求处理的歧义所导致的。

在偶然中作者发现了一处漏洞，其由HTTP/2请求触发，这是由于HTTP/2在帧层中有一个内置的长度字段：

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnSMSBtGFJh6WyIiaQxJLXialv3heichtrSKibchGoI3xKq4Uo00OpL6541icEw8ToUIY6NGLDLUeZk0asg/640?wx_fmt=png)

AWS有一个负载均衡器名为ALB，作者发现使用其作为前端的各种网站都会间歇性的400错误，进一步测试发现其添加了Transfer-Encoding: chunked请求头，并且会将HTTP请求降级为HTTP/1.1后转发到后端，但请求内容并没有被修改，即：

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnSMSBtGFJh6WyIiaQxJLXialvFo9Rlxtzqcbn8zw8EU1JLWQ4CcL87xLYYxErwbD8Y2ic8l2BqqibvOfA/640?wx_fmt=png)

要利用也简单，只需要提供一个分块给其传输，如：

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnSMSBtGFJh6WyIiaQxJLXialvslZKOicj9kpmNENf5CDkaSI83DlGCuAkPRsbWbicibFrFlzSgctbmZmCQ/640?wx_fmt=png)

经过处理后其请求应该转换为如下：

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnSMSBtGFJh6WyIiaQxJLXialvB1bZkOMBTUWJKS76F6TQ8LgWPCPBbwbTNVrlcRH9KicTwKCRueuRPhg/640?wx_fmt=png)

这是一个发现请求走私漏洞的完美示例，但只有一点不寻常那就是该请求由于HTTP/2导致不存在CL头。然而，大部分情况下浏览器都会主动发送CL头。

### Detecting connection-locked CL.TE

作者通过前面的问题及其解决办法想到了解决一个比较棘手的问题，作者在研究HTTP/2时产生的一个问题——请求走私在connection-locked的HTTP/1.1中的通用检测方式。

什么是connection-locked？

指前端为与客户端建立的每个连接创建到后端的新连接的常见行为，这使得直接的跨用户攻击几乎是不可能的，但仍然留下了其他攻击途径。

要识别这一走私漏洞，需要在单次连接中同时发送”攻击者“和”受害者“两次请求，但这很容易产生误报，不利于检测，因为服务器无法将其与HTTP pipelining区分开来。

举个例子，给定一个CL.TE估计的请求包和响应包，如何判断目标是否遭到走私攻击?

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnSMSBtGFJh6WyIiaQxJLXialvkwN7NEpCurnge8XUAamM887Er1eWIPPbArjAibJ9BAhjboznskG5UDg/640?wx_fmt=png)

同样的在Burp Repeater中也能够见到HTTP pipelining，并且很容易被误会成是请求走私：

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnSMSBtGFJh6WyIiaQxJLXialv4NBRGlKnkicFFZZo6sTia2eLpTtDj7pJsvc2uZ59osicgfOqTQu6Gia6Nw/640?wx_fmt=png)

作者在试图解决这一问题上花费了大量的时间，最后决定明确解释为何上面的现象无法证实存在漏洞，在最后也找到了相应的解决方案：

在上面的响应包中，通过夹带的404请求带来的响应，可以判断出后端服务器正在使用TE头来解析请求，但是无法判断代理服务器是否使用CL来解析，因此也就无法判断出到底是否存在漏洞。

要证明漏洞的存在首先需要将HTTP pipelining这一特性排除，只需要在请求包中带有`0\r\n\r\n`如下：

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnSMSBtGFJh6WyIiaQxJLXialv9ia4xHCPLfT5C7p9U1iavts8LTzODoibrocK45fzz4uZiaicXOXXNoZBOgQ/640?wx_fmt=png)

因为前面提到了后端服务器使用TE头来解析，那么此时会分为两种情况：

第一种是服务器给到响应，这说明代理服务器认为本次请求已经完成，则其解析的是TE头：

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnSMSBtGFJh6WyIiaQxJLXialvvRWyyPalyJpicjtZlLOYLP29ucjxeBkCGzIpQXC1Sib5vYQkn9wYM83g/640?wx_fmt=png)

第二种是持续等待响应直到超时，这说明代理服务器一直在等待请求，则其解析的是CL头：

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnSMSBtGFJh6WyIiaQxJLXialvsFkvkxic23aouTcGtLdd9OsYaomIwCVKkm8icjrWwLhVdtcSGfXJbXFA/640?wx_fmt=png)

后端TE头，代理CL头，请求走私就有了。

作者利用这种技术也发现了运行在Barracuda WAF后的ISS服务存在走私，尽管针对漏洞的修复已经更新，但目标并没有安装这一更新。

### CL.0 browser-compatible desync

一开始作者觉得某个站点上存在TE.CL走私，但当他将TE头去除后发现这对于前后端的服务器而已没有任何影响，这样就是意味着TE头在当前请求中可以完全去除，但走私攻击依旧生效，其效果类似于：

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnSMSBtGFJh6WyIiaQxJLXialvV80HMa5qyDDIsDCpH0W5ic5wcp83JDwGuhA2Id2NXGPMJkibNgB0oePQ/640?wx_fmt=png)

显然代理服务器接受并解析CL，而后端服务器完全忽视CL，因此，绿色字体的请求完全被忽略掉，后端是将请求正文（从xyz开始）当做第二个请求的开始。忽略CL等效与将其值视为0，因此这是一个CL.0的异步，一个已知但较少被研究到的攻击面。

```
TE.CL and CL.TE // 传统的请求走私
H2.CL and H2.TE// HTTP/2 降级走私
CL.0           // 上文提到的
H2.0           // 类似CL.0
0.CL and 0.TE   // 无法脱离pipelining利用
```

关于CL.0这一利用方式，它是一种完全符合HTTP规范的请求，这也意味着代理服务器无法防御它，进一步来说甚至可以被服务器触发。

下面作者开始探索有多少站点存在这一漏洞点。

### H2.0 on amazon.com

在对CL.0/H2.0的异步进行粗略的扫描后，发现受影响的站点不少，其中包括amazon，在向其发送/b/时会忽略掉CL：

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnSMSBtGFJh6WyIiaQxJLXialvQq1mcgHzS6eBlvsGBlWPT7FqT40j8BuI9fN24qzh1qic2cmliaO6TOXg/640?wx_fmt=png)

作者利用一个简单的poc来确认这一漏洞，随机的将在线用户的完整请求存储在购物清单中（包括auth token）：

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnSMSBtGFJh6WyIiaQxJLXialvPM0IWWicDpiavJtwnadFSMZ8IpCub1K9SjPibLQGOHnrLMH5JrShQQPeQ/640?wx_fmt=png)

随后作者便报告了这一漏洞，但却意识到这一漏洞还可以进一步拓展。可以用amazon上的HEAD技术创建XSS页面，当受害者浏览该页面时执行javascript，同时让受害者重启攻击，将攻击进一步传播。即一种请求异步类型的蠕虫。

**03****‍**

**Client-side desync**‍‍‍‍‍‍

传统的异步攻击只是在前端和后端服务器之间，因此若网站脱离了前后端服务器架构的话是无法实现此类攻击的，作者将这类攻击称为服务器端异步。而大多数的服务器端异步只能通过HTTP客户端发出的畸形请求触发，但正如刚刚的awazon，有时候也可以创建一个由浏览器驱动的服务器端走私。

浏览器端造成的走私作者成为客户端异步（CSD），由于异步攻击发生在浏览器和前端服务器之间。这使得单服务器网站也可以被利用，因为它们在HTTP解析方面通常较差。

CSD攻击从受害者访问攻击者的网站开始，然后让他们的浏览器向易受攻击的网站发送两个跨域请求。第一个请求是为了让浏览器的连接产生异步，并使第二个请求触发有害响应，通常使攻击者能够控制受害者的帐户：

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnSMSBtGFJh6WyIiaQxJLXialvMtFkkIAO7C6qG5qD38PVM7xN47VLkSIMWwxDkT57HdobsHfScVj3WA/640?wx_fmt=png)

### Methodology

在尝试检测和利用客户端异步漏洞时，可以重用服务器异步攻击中的许多概念。主要区别在于整个漏洞利用过程发生在受害者的Web浏览器中，该环境比专用的黑客工具更复杂且不受控制。这带来了一些新的挑战，在研究这种技术时给作者带来了很多痛苦。为了节省您的时间，作者吸取了经验教训并开发了以下方法：

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnSMSBtGFJh6WyIiaQxJLXialv7gY2K6e0YibAZGNMDicfRYjfb6FYtK9Z6bzXZJTV2ibUUSfLFUnicP5wyQ/640?wx_fmt=png)

#### Detect

首先是确认CSD的载体，这是漏洞的核心。在HTTP Request Smuggler和Burp Scanner中依旧实现了自动检测，但了解如何手动检测仍然很有意义。

首先，服务器必须忽略CL，通常是由于错误的请求触发服务器异常或者是服务器根本不期望接受POST类型的请求。选取的目标通常是静态文件或者服务器重定向，然后利用超长URL或者特殊格式的URL(如`/%2e%2e`)触发错误。

其次，请求必须在Web浏览器跨域中触发。浏览器对于跨域请求的控制十分严格，因此只能控制headers，然后如果需要发送请求体还需要使用POST请求。最终只能控制URL、Referer头、请求体以及部分 Content-Type。

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnSMSBtGFJh6WyIiaQxJLXialvrKKKotuel2cQHLYAb8qL2Swaib4eqwLsbNxWgrwDpNlhVsIhKfeX3oQ/640?wx_fmt=png)

现在完成了攻击请求，需要检查服务器是否忽略CL，第一步，使用超过请求体长度的CL，查看服务器是否回复：

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnSMSBtGFJh6WyIiaQxJLXialvMYXEDZ9cWj82ApUsicnw49UracujxJEOzlvCV70PficOictoQaHzcnm7A/640?wx_fmt=png)

这看起来可行，但一些较为安全的服务器会在没有等待请求体的情况下做出响应而导致误报的产生，而另外一些服务器尽管不会处理CL，但会在响应后即刻关闭连接，因此需要用某些方式筛出这类请求。通过在同一个连接上发现两个请求，并查看第一个请求的请求体对第二个响应造成的影响：

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnSMSBtGFJh6WyIiaQxJLXialviboOaUWJODSWKdEaGosfo0icMib765ibAUxrb6MlleFzOibtezUGnxOpttQ/640?wx_fmt=png)

作者在Citrix Web VPN上浪费了大量的时间，后来意识到它只是为每个请求都分出两个http响应。

然后还需要注意一点的是，目标服务器是否支持HTTP/2，CSD是利用HTTP/1.1连接复用，并且浏览器通常在站点有HTTP/2时选择HTTP/2，当然会有例外，即某些代理服务器不支持HTTP/2。

#### Confirm

现在将操作移步到浏览器中执行（推荐选择chrome）。

首先，选择要从中发起攻击的站点。此站点必须通过 HTTPS 访问，并且位于与目标不同的域上。

接下来，确保未配置代理，然后浏览到攻击站点。打开开发人员工具并切换到“network”选项卡。为了方便以后调试潜在问题，我建议进行以下调整：

* 勾选“Preserve log”。
* 右键单击列标题并启用“Connection ID”列。

切换到开发人员控制台并执行 JavaScript 使用 fetch()。像这样：

```
fetch('https://example.com/', {
  method: 'POST',
     body: "GET /hopefully404 HTTP/1.1\r\nX: Y", // malicious prefix
     mo...