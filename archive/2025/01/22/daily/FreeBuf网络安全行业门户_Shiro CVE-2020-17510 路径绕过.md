---
title: Shiro CVE-2020-17510 路径绕过
url: https://www.freebuf.com/vuls/420408.html
source: FreeBuf网络安全行业门户
date: 2025-01-22
fetch_date: 2025-10-06T20:09:23.341083
---

# Shiro CVE-2020-17510 路径绕过

[![freeBuf](/images/logoMax.png)](/)

主站

分类

云安全

AI安全

开发安全

终端安全

数据安全

Web安全

基础安全

企业安全

关基安全

移动安全

系统安全

其他安全

特色

热点

工具

漏洞

人物志

活动

安全招聘

攻防演练

政策法规

[报告](https://www.freebuf.com/report)[专辑](/column)

* ···
* [公开课](https://live.freebuf.com)
* ···
* [商城](https://shop.freebuf.com)
* ···
* 用户服务
* ···

行业服务

政 府

CNCERT
CNNVD

会员体系（甲方）
会员体系（厂商）
产品名录
企业空间

[知识大陆](https://wiki.freebuf.com/page)

搜索

![](/freebuf/img/7aa3bf7.svg) ![](/freebuf/img/181d733.svg)

创作中心

[登录](https://www.freebuf.com/oauth)[注册](https://www.freebuf.com/oauth)

官方公众号企业安全新浪微博

![](/images/gzh_code.jpg)

FreeBuf.COM网络安全行业门户，每日发布专业的安全资讯、技术剖析。

![FreeBuf+小程序](/images/xcx-code.jpg)

FreeBuf+小程序把安全装进口袋

[![](https://image.3001.net/images/20231020/1697804527_653270ef7570cc7356ba8.png)](https://wiki.freebuf.com)

Shiro CVE-2020-17510 规范化不一致导致的路径匹配绕过

* ![]()
* 关注

* [漏洞](https://www.freebuf.com/articles/vuls)

Shiro CVE-2020-17510 规范化不一致导致的路径匹配绕过

2025-01-31 21:15:26

所属地 广东省

# 漏洞描述

Apache Shiro before 1.7.0, when using Apache Shiro with Spring, a specially crafted HTTP request may cause an authentication bypass.

If you are NOT using Shiro’s Spring Boot Starter (`shiro-spring-boot-web-starter`), you must configure add the [`ShiroRequestMappingConfig`autoconfiguration to your application](https://shiro.apache.org/spring-framework.html#web_applications)or configure the [equivalent manually](https://github.com/apache/shiro/blob/shiro-root-1.7.0/support/spring/src/main/java/org/apache/shiro/spring/web/config/ShiroRequestMappingConfig.java#L28-L30). [1]

# 漏洞条件

* shiro < 1.7.0
* springboot > 2.3.x（>= 2.4.0)
* 要使用resful风格的路径

补充背景知识

| springboot版本 | 对应springweb版本 |
| --- | --- |
| 2.3.x | 5.2.x |
| 2.4.x | 5.3.x |

# 漏洞复现

由于shiro，spring规范化不一致导致的漏洞

## 环境

基础配置

```
shiro: 1.6.0
spring-boot: 2.7.4
```

shiro配置：

```
@Bean
    ShiroFilterFactoryBean getShiroFilterFactoryBean(DefaultWebSecurityManager securityManager) {
        ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean();
        bean.setSecurityManager(securityManager);
        bean.setLoginUrl("/login");
        bean.setSuccessUrl("/loginSuccess");
        bean.setUnauthorizedUrl("/unauthorized");
        LinkedHashMap<String, String> map = new LinkedHashMap<String, String>();
        //url --> filter1,filter2....
        map.put("/print", "authc, perms[printer:print]");
        map.put("/query", "authc, perms[printer:query]");
        map.put("/admin/*", "authc, roles[admin]");  //不可以是"/admin/**"
        map.put("/login","authc");
        bean.setFilterChainDefinitionMap(map);
        return bean;
    }
```

controller:

```
@GetMapping("/admin/{param}")
    public String adminInfo(@PathVariable String param) {
        if(param == null){
            return "you are admin";
        }
        //param如果用来查询文件，就可能造成路径穿越
        return "Admin Info: " + param;
    }
```

## 测试

payload

```
GET /admin/. HTTP/1.1
Host: localhost:9090
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:134.0) Gecko/20100101 Firefox/134.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
Accept-Encoding: gzip, deflate, br
DNT: 1
Sec-GPC: 1
Connection: keep-alive
Upgrade-Insecure-Requests: 1
Priority: u=0, i
```

结果：
![image](https://image.3001.net/images/20250206/1738839467_67a495ab0cd443d35c1a3.png!small)

> payload为”/admin/..“，一样可以绕过
>
> 漏洞利用：路径变量param如果作为查询文件的参数，就可能造成路径穿越

# 漏洞分析

漏洞入口：`PathMatchingFilterChainResolver.getChain()`

![image](https://image.3001.net/images/20250206/1738839485_67a495bd11e121fa1c9d5.png!small)

源码：

```
public FilterChain getChain(ServletRequest request, ServletResponse response, FilterChain originalChain) {
        FilterChainManager filterChainManager = getFilterChainManager();
        if (!filterChainManager.hasChains()) {
            return null;
        }

		//漏洞点
        String requestURI = getPathWithinApplication(request);

     	//去除末尾的 “/”
        if(requestURI != null && !DEFAULT_PATH_SEPARATOR.equals(requestURI)
                && requestURI.endsWith(DEFAULT_PATH_SEPARATOR)) {
            requestURI = requestURI.substring(0, requestURI.length() - 1);
        }

        for (String pathPattern : filterChainManager.getChainNames()) {
            //去除末尾的 “/”
            if (pathPattern != null && !DEFAULT_PATH_SEPARATOR.equals(pathPattern)
                    && pathPattern.endsWith(DEFAULT_PATH_SEPARATOR)) {
                pathPattern = pathPattern.substring(0, pathPattern.length() - 1);
            }

            // If the path does match, then pass on to the subclass implementation for specific checks:
            if (pathMatches(pathPattern, requestURI)) {
                if (log.isTraceEnabled()) {
                    log.trace("省略");
                }
                return filterChainManager.proxy(originalChain, pathPattern);
            }
        }

        return null;
    }
```

进入漏洞点

![image](https://image.3001.net/images/20250206/1738839503_67a495cfb276b270c9a24.png!small)

![image](https://image.3001.net/images/20250206/1738839518_67a495de4bcda6c7e5ee8.png!small)

> 末尾多出来的路径不明白的可以看同专辑中的CVE-2020-13933

结果毫无疑问，`/amdin`匹配到`/**`

但是"/admin"这个路径对InvalidRequestFilter的核心算法而言是合法的，所以会被shiro放行：

```
//InvalidRequestFilter::
protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception {
        String uri = WebUtils.toHttp(request).getRequestURI();
        return !containsSemicolon(uri)
            && !containsBackslash(uri)
            && !containsNonAsciiCharacters(uri);
    }
```

于是来到spring的路径匹配入口：`AbstractHandlerMethodMapping.getHandlerInternal(...)`

```
protected HandlerMethod getHandlerInternal(HttpServletRequest request) throws Exception {
		String lookupPath = initLookupPath(request);
		this.mappingRegistry.acquireReadLock();
		try {
			HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request);
			return (handlerMethod != null ? handlerMethod.createWithResolvedBean() : null);
		}
		finally {
			this.mappingRegistry.releaseReadLock();
		}
	}
```

进入initLookupPath(request):
![image](https://image.3001.net/images/20250206/1738839534_67a495ee57a5dbb028a6a.png!small)

> spring-boot>= 2.6.0 userPathPatterns() 默认为true;

返回：/admin/.

![image](https://image.3001.net/images/20250206/1738839550_67a495fecdf408e0c02cd.png!small)

由于spring没有像shiro那样对像 带有`/.`和`/..`的路径进行规范化，导致最终匹配到了controller方法:

![image](https://image.3001.net/images/20250206/1738839567_67a4960fe70128c9d0f46.png!small)

【注意】:点号是必须的：

![image](https://image.3001.net/images/20250206/1738839582_67a4961ed3e78c373de45.png!small)

结果测试 spring”/admin/“是匹配 “/admin”的但是不匹配“/admin/{param}”

## 补充

### 为什么要 springboot > 2.3.x :

[2]

主要是因为springboot <= 2.3.0 RELEASE 路径匹配机制与后面版本有所不同。

以下源码全是`springboot 2.3.0 RELEASE`

函数入口：`AbstractHandlerMethodMapping#getHandlerInternal`

**调试**：

```
uri: /admin/.
```

![image](https://image.3001.net/images/20250206/1738839600_67a496306e4fdcf22dce3.png!small)

```
public String getLookupPathForRequest(HttpServletRequest request) {
		// Always use full path within current servlet context?
    	//分支1
		if (this.alwaysUseFullPath) {
			return getPathWithinApplication(request);
		}
		// Else, use path within current servlet mapping if applicable
    	//分支2
		//一般进入这个分支,这就是该漏洞要spring-boot > 2.3.x 的原因
		String rest = getPathWithinServletMapping(request);
		if (!"".equals(rest)) {
			return rest;
		}
		else {
			return getPathWithinApplication(request);
		}
	}
```

* 第一个分支是正常的：getPathWithinApplication

  ```
  public String getPathWithinApplication(HttpServletRequest request) {
  		String contextPath = getContextPath(request);
  		String requestUri = getRequestUri(request);
      	//去除匹配到的部分，返回剩余部分，忽略大小写，从而返回相对路径
  		String path = getRemainingPath(requestUri, contextPath, true);
  		if (path != null) {
  			// Normal case: URI contains context path.
  			return (StringUtils.hasText(path) ? path : "/");
  		}
  		else {
  			return requestUri;
...