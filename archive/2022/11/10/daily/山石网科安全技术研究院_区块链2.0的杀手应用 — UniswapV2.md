---
title: 区块链2.0的杀手应用 — UniswapV2
url: https://mp.weixin.qq.com/s?__biz=MzUzMDUxNTE1Mw==&mid=2247497405&idx=1&sn=bb2c6eb9da3de513a458a7b22f4579eb&chksm=fa522303cd25aa15b558b1a06e747120350b02922293bee938cbb92f784430dd94e1b4d5c64e&scene=58&subscene=0#rd
source: 山石网科安全技术研究院
date: 2022-11-10
fetch_date: 2025-10-03T22:17:43.443383
---

# 区块链2.0的杀手应用 — UniswapV2

![cover_image](https://mmbiz.qpic.cn/mmbiz_jpg/Gw8FuwXLJnQXUjBEMd42Yu7kw2WArCaO9Hsv8kyPQVT74xicDfQhU2NVxhlaY3W1aIHZhey4pibh6M35Iejsk0cA/0?wx_fmt=jpeg)

# 区块链2.0的杀手应用 — UniswapV2

原创

核心基础实验室

山石网科安全技术研究院

‍

‍

**一、简介**

UniswapV2是一个建立在以太坊上的主流去中心化加密交易平台(DEX)，实现了自动化做市商(AMM)。

AMM要实现s自动完成与买卖方的交易，需要满足以下几个特性：

1.AMM要持有资产，由于要双向报价，所以需要同时持有两种资产。

2.AMM资产池应该能实现充值与提现。

3.AMM应该根据市场情况自动调整价格。

4.AMM要能通过交易赚取利润。

**二、 原理**

UniswapV2部署在以太坊上，其本身是一个支持ERC-20标准的token合约，其定义在合约文件UniswapV2ERC20.sol中。

UniswapV2可以完成任意两种ERC-20token的交换，其实现在uniswapV2Pair合约中，该合约主要提供以下3种功能：

1.流动性追踪，追踪交易池中的代币余额，并提供流动性代币。

2.自动做市，通过算法计算出市场价格。

3.去中心化预言机，供外部使用。

**2.1流动性**

什么是流动性？在uniswap中可以被认为是在一个交易对合约中的两种代币的总和，如果用户同时向合约质押两种代币，则被称为增加流动性。由所有流动性汇成的池子为流动性池。而向流动性池中添加流动性的的人被称为流动性提供者(LP)。而流动性池会根据流动性提供者(LP)对池子的贡献，会给LP一些凭证，这个凭证使用uniswap中的ERC-20token合约实现，LP提供流动性时，token合约给LP铸相应的币，减少流动性的时候会销毁相应的token，这个凭证被称为LPs。而每个LP对池子的贡献对于池子的比重被称为流动性池份额。

**2.2功能**

**2.2.1 质押**

首先工厂合约会初始化创建一个交易对(pair)合约，在这个合约的池子中，两种代币的初始值都是0，需要LP质押一定数量的两种代币来启动池子。 在池子中的两种代币的相对价值是由两种代币的数量比例决定的

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnQXUjBEMd42Yu7kw2WArCaO8xFB1kM8TVP9DQOVhH0fsgibBg4MicXyS5Bes7ial9uSUpmYpuTRTKGdA/640?wx_fmt=png)

意思是两种代币的总价值应该一直保持相同，而交易会改变两种代币的数量，所以价格也在一直变化，其公式为： 其中两种代币的数量分别为x, y, 而k是一个常数。 第一个LP在质押的两个代币的数量分别为x0，y0，， 那么获得的LPSs\_0，满足公式：

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnQXUjBEMd42Yu7kw2WArCaOUu1g29icCVAmzHCoNRRaSIcwbgicPGicZibsybpgJpE0fF1ib8bc1PJDuNg/640?wx_fmt=png)

而在交易过程中，合约会收取一定比例的手续费，而手续费也会放回到流动性池中，相当于流动性的总价值变多，而LPs的总量没有变化，所以相当于单个LPs的价值升高。升高的价值就是LP获取的收益。 而如果LPs的单价过高，高到1wei(以太坊中的最小单位)个LPs的价值也非常高，这时候再往池子总添加流动性的成本就会非常高，不利于维持交易的流动性。为了防止这种情况，uniswap设置了一个最小流动性，该值为1000wei，创建流动性池的时候，都要向0地址锁定这个值的LPS，如果认为要把LPs价格提的很高，那么他就需要再0地址锁定的时候付出更多的成本。

接下来在有LP继续添加流动性的时候，新铸造的LPs为：

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnQXUjBEMd42Yu7kw2WArCaO0QdqfH665xxvyasTztZzECK9o4YeV8IdR6xsvmk0u5Yw3AUUgxrGvg/640?wx_fmt=png)

x\_n，y\_n为原先池子中两种代币的数量，x\_a，y\_a为新添加的两种代币的数量， 合约会按照两种代币新添加值与原值比例小的那个，再与原LPs的数量相乘，作为新铸造的LPs。为了利益最大化，LP通常会按照现有池子的比例提供两种代币，即：

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnQXUjBEMd42Yu7kw2WArCaOz4mrKibUp2N9z0AHf7o5OKl6oXJV9ictmXJg9LnRRIAsZicCumyfnG08A/640?wx_fmt=png)

LPs由LP持有，并且其他性质与ERC-20一样，可以进行自由交易。

**2.2.2自动做市**

首先我们已经知道流动池中的两种代币满足恒定乘积公式：

x × y=k

那么如果想用x换y，则满足:

(x+Δx)×(y-Δy)=k

换出来的y为：

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnQXUjBEMd42Yu7kw2WArCaOxbutfwN514PZw1Ia1jU7dOUN8mPxjbqx1ic4ACyriaH3khml9PKLJCqA/640?wx_fmt=png)

如果交易量较小的话，交易价格就近似于两种代币在池子中的比值。

**交易过程：**

1. 交易之前，Pair合约中两种token的数量 x1，y1满足:

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnQXUjBEMd42Yu7kw2WArCaOQ8KUofsLCssnBuy8KjFJWygzGWFuvticbubIhMEFj1iaX4e5icla2KmKQ/640?wx_fmt=png)

2. 用户发送token x到pair合约。

3. 调用合约中的swap接口，计算获取到的y token， 并发送这些token给用户。

4. 完成交易之后，pair合约中两种代币的数量x2，y2应满足：

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnQXUjBEMd42Yu7kw2WArCaOxL3YJeT3rpVybtKp75slicg8xxWQMxibP2cEAKLzBHhoo9MfvUmIEgPA/640?wx_fmt=png)

**2.2.3  价格预言**

UniswapV2中通过测量和记录每一个块的第一次交易之前的价格来进行，从而避免操纵价格预言机所产生的攻击，计算出的叫个为上一个区块中的相对价格的平均累计值：

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnQXUjBEMd42Yu7kw2WArCaOhSbtVxdNIYA9PemjuicXIGEwsQJXKEV64V382EDoicT3GjvGibeRbpRGw/640?wx_fmt=png)

**2.2.4   闪电贷**

UniswapV2允许用户在同一原子交易中完成借贷于还款。用户可以不用向pair合约做任何抵押就可以借走池子中的所有a代币，只要在交易结束后还上足够数量的b代币即可，则回退整个交易。

交易过程：

1. 交易之前pair合约中两种token的数量应满足：

x × y=k

2. 用户调用合约中的swap函数，指定要借贷的数量与回调函数的相关参数。

3. pair合约向用户发送相应的x代币。

4. 合约调用用户指定的回调函数。

5. 检查回调函数函数完成之后，池子中的两种代币数量应满足：

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnQXUjBEMd42Yu7kw2WArCaOAXa29iczvxKgPmy1unUemiaPictdR5N2bdfQNeGVhsCich46YuHxS0Q5jQ/640?wx_fmt=png)

若不满足则回退整个交易。

**三、源码解析**

## **3.1   UniswapV2ERC20.sol**

该合约为一个ERC-20合约，定义了LPtoken代币。

```
pragma solidity =0.5.16;

import './interfaces/IUniswapV2ERC20.sol';
import './libraries/SafeMath.sol';

contract UniswapV2ERC20 is IUniswapV2ERC20 {
    using SafeMath for uint;

  // token名称
    string public constant name = 'Uniswap V2';
    // token的标志
    string public constant symbol = 'UNI-V2';
    // 精度
    uint8 public constant decimals = 18;
    // token的总供应量
    uint  public totalSupply;

    // 每个地址的余额
    mapping(address => uint) public balanceOf;

    // 每个地址对每个地址的授权数量
    mapping(address => mapping(address => uint)) public allowance;

  // EIP-712中规定的DOMAIN_SEPARATOR
    bytes32 public DOMAIN_SEPARATOR;
    // keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");
    // EIP-712中规定的TYPEHASH
    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;
    // 地址与其nonce值，用于避免重放
    mapping(address => uint) public nonces;

    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);

    constructor() public {
      // 当前链的id
        uint chainId;
        assembly {
          // 通过内联汇编获取chainid
            chainId := chainid
        }
        // 获取DOMAIN_SEPARATOR
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),
                keccak256(bytes(name)),
                keccak256(bytes('1')),
                chainId,
                address(this)
            )
        );
    }

  // 铸币 向指定地址铸造一定数量的代币
    function _mint(address to, uint value) internal {
      // 增加相应的总供应量
        totalSupply = totalSupply.add(value);
        // 对应地址增加余额
        balanceOf[to] = balanceOf[to].add(value);
        // 触发事件，0地址向目标地址发送相应的代币
        emit Transfer(address(0), to, value);
    }

  // 销毁 销毁某个地址的一定数量的代币
    function _burn(address from, uint value) internal {
      // 减小余额
        balanceOf[from] = balanceOf[from].sub(value);
        // 减小相应的总供应量
        totalSupply = totalSupply.sub(value);
        // 触发事件 目标地址向0地址发送相应数量的代币
        emit Transfer(from, address(0), value);
    }

  // 授权
    function _approve(address owner, address spender, uint value) private {
      // 修改相应的allowance
        allowance[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

  // 转账
    function _transfer(address from, address to, uint value) private {
        balanceOf[from] = balanceOf[from].sub(value);
        balanceOf[to] = balanceOf[to].add(value);
        emit Transfer(from, to, value);
    }

    function approve(address spender, uint value) external returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

  // 调用者向某地址转账
    function transfer(address to, uint value) external returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

  // 授权转账
    function transferFrom(address from, address to, uint value) external returns (bool) {
        // 如果授权为最大值，则表示可以转持有者的所有代币
        if (allowance[from][msg.sender] != uint(-1)) {
            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);
        }
        _transfer(from, to, value);
        return true;
    }

  // 授权
    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {
      // 检查时间是否超时
        require(deadline >= block.timestamp, 'UniswapV2: EXPIRED');
        // 计算签名
        bytes32 digest = keccak256(
            abi.encodePacked(
                '\x19\x01',
                DOMAIN_SEPARATOR,
                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))
            )
        );
        // 验证签名并获取签名信息的地址
        address recoveredAddress = ecrecover(digest, v, r, s);
        // 确保地址不是0地址且地址是owner地址
        require(recoveredAddress != address(0) && recoveredAddress == owner, 'UniswapV2: INVALID_SIGNATURE');
        // 授权
        _approve(owner, spender, value);
    }
}
```

## **3.2   UniswapV2Pair.sol**

该合约时unswap的核心合约，该合约定义了两种代币组成的交易对，代币存在这个合约中并组成交易池。

```
pragma solidity =0.5.16;

import './interfaces/IUniswapV2Pair.sol';
import './UniswapV2ERC20.sol';
import './libraries/Math.sol';
import './libraries/UQ112x112.sol';
import './inte...