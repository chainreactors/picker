---
title: Windows Installer, exploiting Common Actions
url: https://blog.doyensec.com/2024/07/18/custom-actions.html
source: Over Security - Cybersecurity news aggregator
date: 2024-07-19
fetch_date: 2025-10-06T17:43:34.142740
---

# Windows Installer, exploiting Common Actions

[

](https://doyensec.com/img/home-video.mp4)

[![](/public/images/doyensec-logo.svg)](/index.html)

[![](/public/images/logo.svg)](/index.html)

#### ABOUT US

We are [**security engineers**](https://doyensec.com) who break bits and tell stories.

Visit us
[doyensec.com](https://doyensec.com)

Follow us
[@doyensec](https://twitter.com/doyensec)

Engage us
info@doyensec.com

#### Blog Archive

* 2025
* 2024
* 2023
* 2022
* 2021
* 2020
* 2019
* 2018
* 2017

© 2025 [Doyensec LLC](https://doyensec.com) [![](/public/images/rss.png)](/atom.xml "RSS")

# Windows Installer, Exploiting Custom Actions

18 Jul 2024 - Posted by Adrian Denkiewicz

Over a year ago, I published my [research around the Windows Installer Service](https://blog.doyensec.com/2023/03/21/windows-installer.html). The article explained in detail how the MSI repair process executes in an elevated context, but the lack of impersonation could lead to Arbitrary File Delete and similar issues. The issue was acknowledged by Microsoft (as [CVE-2023-21800](https://nvd.nist.gov/vuln/detail/CVE-2023-21800)), but it was never directly fixed. Instead, the introduction of a Redirection Guard mitigated all symlink attacks in the context of the `msiexec` process. Back then, I wasnât particularly happy with the solution, but I couldnât find any bypass.

The Redirection Guard turned out to work exactly as intended, so I spent some time attacking the Windows Installer Service from other angles. Some bugs were found ([CVE-2023-32016](https://msrc.microsoft.com/update-guide/en-US/advisory/CVE-2023-32016)), but I always felt that the way Microsoft handled the impersonation issue wasnât exactly right. That unfixed behavior became very useful during another round of research.

This article describes the **unpatched vulnerability** affecting the latest Windows 11 versions. It illustrates how the issue can be leveraged to elevate a local userâs privileges. The bug submission was closed after half-a-year of processing, as non-reproducible. I will demonstrate how the issue can be reproduced by anyone else.

### Custom Actions

[Custom Actions](https://learn.microsoft.com/en-us/windows/win32/msi/custom-actions) in the Windows Installer world are user-defined actions that extend the functionality of the installation process. Custom Actions are necessary in scenarios where the built-in capabilities of Windows Installer are insufficient. For example, if an application requires specific registry keys to be set dynamically based on the userâs environment, a Custom Action can be used to achieve this. Another common use case is when an installer needs to perform complex tasks like custom validations or interactions with other software components that cannot be handled by standard MSI actions alone.

Overall, Custom Actions can be implemented in different ways, such as:

* Compiled to custom DLLs using the exposed C/C++ API
* Inline VBScript or JScript snippets within the WSX file
* Explicitly calling system commands within the WSX file

All of the above methods are affected, but for simplicity, we will focus on the last type.

Letâs take a look at an example WSX file (`poc.wsx`) containing some Custom Actions:

```
<?xml version="1.0" encoding="utf-8"?>
<Wix xmlns="http://schemas.microsoft.com/wix/2006/wi">
    <Product Id="{12345678-9259-4E29-91EA-8F8646930000}" Language="1033" Manufacturer="YourCompany" Name="HelloInstaller" UpgradeCode="{12345678-9259-4E29-91EA-8F8646930001}" Version="1.0.0.0">
        <Package Comments="This installer database contains the logic and data required to install HelloInstaller." Compressed="yes" Description="HelloInstaller" InstallerVersion="200" Languages="1033" Manufacturer="YourCompany" Platform="x86" ReadOnly="no" />

        <CustomAction Id="SetRunCommand" Property="RunCommand" Value="&quot;[%USERPROFILE]\test.exe&quot;" Execute="immediate" />
        <CustomAction Id="RunCommand" BinaryKey="WixCA" DllEntry="WixQuietExec64" Execute="commit" Return="ignore" Impersonate="no" />
        <Directory Id="TARGETDIR" Name="SourceDir">
            <Directory Id="ProgramFilesFolder">
                <Directory Id="INSTALLFOLDER" Name="HelloInstaller" ShortName="krp6fjyg">
                    <Component Id="ApplicationShortcut" Guid="{12345678-9259-4E29-91EA-8F8646930002}" KeyPath="yes">
                        <CreateFolder Directory="INSTALLFOLDER" />
                    </Component>
                </Directory>
            </Directory>
        </Directory>
        <Property Id="ALLUSERS" Value="1" />
        <Feature Id="ProductFeature" Level="1" Title="Main Feature">
            <ComponentRef Id="ApplicationShortcut" />
        </Feature>
        <MajorUpgrade DowngradeErrorMessage="A newer version of [ProductName] is already installed." Schedule="afterInstallValidate" />

        <InstallExecuteSequence>
            <Custom Action="SetRunCommand" After="InstallInitialize">1</Custom>
            <Custom Action="RunCommand" After="SetRunCommand">1</Custom>
        </InstallExecuteSequence>
    </Product>
</Wix>
```

This looks like a perfectly fine WSX file. It defines the `InstallExecuteSequence`, which consists of two custom actions. The `SetRunCommand` is queued to run right after the `InstallInitialize` event. Then, the `RunCommand` should start right after `SetRunCommand` finishes.

The `SetRunCommand` action simply sets the value of the `RunCommand` property. The `[%USERPROFILE]` string will be expanded to the path of the current userâs profile directory. This is achieved by the installer using the value of the `USERPROFILE` environment variable. The expansion process involves retrieving the environment variableâs value at **runtime** and substituting `[%USERPROFILE]` with this value.

The second action, also called `RunCommand`, uses the `RunCommand` property and executes it by calling the `WixQuietExec64` method, which is a great way to execute the command quietly and securely (without spawning any visible windows). The `Impersonate="no"` option enables the command to execute with LocalSystemâs full permissions.

On a healthy system, the administratorâs `USERPROFILE` directory cannot be accessed by any less privileged users. Whatever file is executed by the `RunCommand` shouldnât be directly controllable by unprivileged users.

We covered a rather simple example. Implementing the intended Custom Action is actually quite complicated. There are many mistakes that can be made. The actions may rely on untrusted resources, they can spawn hijackable console instances, or run with more privileges than necessary. These dangerous mistakes may be covered in future blogposts.

### Testing the Installer

Having the [WiX Toolset](https://wixtoolset.org/) at hand, we can turn our XML into an MSI file. Note that we need to enable the additional `WixUtilExtension` to use the `WixCA`:

```
candle .\poc.wxs
light .\poc.wixobj -ext WixUtilExtension.dll
```

The `poc.msi` file should be created in the current directory.

According to our WSX file above, once the installation is initialized, our Custom Action should run the `"[%USERPROFILE]\test.exe"` file. We can set up a ProcMon filter to look for that event. Remember to also enable the âIntegrityâ column.

![Procmon filters settings](../../../public/images/custom-actions-procmon-filters.png)

We can install the application using any Admin account (the `Almighty` user here)

```
msiexec /i C:\path\to\poc.msi
```

ProcMon should record the `CreateFile` event. The file was not there, so additional file extensions were tried.

![NAME NOT FOUND event for the almighty user](../../../public/images/custom-actions-procmon-almighty.png)

The same sequence of actions can be reproduced by running an installation repair process. The command can point at the specific `C:/Windows/Installer/*.msi` file or use a GUID that we defined in a WSX file:

`msiexec /fa {12345678-9259-4E29-91EA-8F8646930000}`

The result should be exactly the same if ...