---
title: 转载|保姆级教程---前端加密的对抗（附带靶场）
url: https://forum.butian.net/share/3728
source: 奇安信攻防社区
date: 2024-09-06
fetch_date: 2025-10-06T18:20:41.793271
---

# 转载|保姆级教程---前端加密的对抗（附带靶场）

#

[问答](https://forum.butian.net/questions)

*发起*

* [提问](https://forum.butian.net/question/create)
* [文章](https://forum.butian.net/share/create)

[攻防](https://forum.butian.net/community)
[活动](https://forum.butian.net/movable)

Toggle navigation

* [首页 (current)](https://forum.butian.net)
* [问答](https://forum.butian.net/questions)
* [商城](https://forum.butian.net/shop)
* [实战攻防技术](https://forum.butian.net/community)
* [漏洞分析与复现](https://forum.butian.net/articles)
  NEW
* [活动](https://forum.butian.net/movable)
* [摸鱼办](https://forum.butian.net/questions/Play)

搜索

* [登录](https://forum.butian.net/login)
* [注册](https://user.skyeye.qianxin.com/user/register?next=http://forum.butian.net/btlogin)

### 转载|保姆级教程---前端加密的对抗（附带靶场）

* [渗透测试](https://forum.butian.net/topic/47)

​ JS加解密是目前黑盒渗透测试中非常大的痛点, 为了满足等保需求, 越来越多行业的内部系统使用了加密技术对HTTP的请求体加密, 增加签名, 时间戳, RequestId等防止进行数据包的抓包改包. 这篇文章就把网络上一些流行的JS逆向后进行数据包的抓包改包方式来个大汇总, 希望能够帮助到大家入门， 提高黑盒渗透的水平。
​

环境
--
##### 环境靶场：
<http://39.98.108.20:8085/>
各位高抬贵手， 写了几个逻辑漏洞，可以自己试试，但别把服务器搞崩了
##### 项目地址：
[0ctDay/encrypt-decrypt-vuls: 加解密逻辑漏洞靶场 (github.com)](https://github.com/0ctDay/encrypt-decrypt-vuls/)
可以根据需求自行修改
说到环境本人也是下了很大的心血，毕竟项目上遇到的存在前端加解密的系统都是保密性质的， 不太好当作公开文章复现学习所使用。 在网上找了很久也没现成的，索性自己搞了一套加解密网关和一个比较基础的图书管理系统，这里的前端使用VUE进行开发， 没有网上许多简单通过Jquery实现的一套加解密逻辑漏洞的靶场那么简单。 但也没那么难， 仅仅使用了固定密钥进行AES加密的形式对请求体进行加密。
关于加解密也引出许多思考，第一是实现HTTP加解密是一对一实现的吗？第二是如果把数据包加密了，那安全设备是不是也失效了，这里带着几个疑问简单了解一下加解密的实现流程。
这里以请求为例
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/08/attach-4190a50bed262763e81b9024a0431c9d1638098e.png)
用户输入明文消息在被JS提取后， 通过JS中定义的加密方法进行加密并制作请求包进行请求。 发送到后端后，一般来说由加解密网关进行解密后， 发送到真正提供服务的服务器上。
加解密网关本质其实就是一种反向代理，除了本身转发数据包的功能以外，还对数据包进行解密。
按照这种部署模式，有两个优势：
1. 如果新增分布式系统， 无需重复实现加解密功能， 直接使用作为该网关的下游服务即可。
2. 在springcloud gateway和 分布式系统之间部署安全设备， 可以检测明文流量识别攻击行为。
改包的防范
-----
先汇总一下目前流行的防止改包方式
主要是这么几个方面
##### 1. 请求参数和路径的加密（靶场未实现）
- 如果原始请求是GET请求，或防止访问者获取请求路径，通常会将用户实际的请求路径和GET请求参数封装都封装为POST请求的请求体，通过加解密网关再还原为原始GET请求传入后端分布式服务上。 在APP中比较常见。
表现的形式通常为： 抓包后发现访问任何功能都是同一路径，并且请求全为密文
##### 2. 请求体的加密
- 这类在纯web中最常见， 通常仅仅加密接口请求的请求体内容，但有以下几类加密问题。
- 使用固定密钥 --- 顾名思义， 这种情况一般JS中会存储密钥， 属于最简单的一种
- 使用动态密钥 --- JS中不存储，一般用户第一次请求后将密钥加密写入COOKIE或本地存储中， 这类加密追踪难度较大。
- 对称加密 --- 加解密数据包内容同一套密钥
- 非对称加密 --- 加密一套解密一套
- 算法 --- 算法就不是特别固定了， 常见的诸如AES RSA等， 也遇到过使用国密算法或一些冷门算法。
##### 3. 签名
- 签名的应用也十分广泛，app，小程序和现在许多web中均存在，签名的构成主要是以下几点
- RequestId --- 为了防止重放攻击, 客户端生成随机RequestId 服务端接收后保存至Redis中, 如果再次接收到此RequestID, 则视为非法请求
- 时间戳 --- 添加时间戳的超时时间, 一旦超时, 原始数据包失效
- 签名本身 --- 通过 requestId + 原始请求体或请求参数 + 时间戳 + 盐值合并生成哈希值 从而保证以上参数的有效性和唯一性
JS逆向
----
JS逆向老生常谈的问题了， 需要懂得基础的JS知识，和调试方法， 这里主要就不讲解如何详细的逆向了，我们直接切入正题： 如何\*\*解决数据包的修改\*\*问题。
关于如何找到JS中的加解密的方法，很多新手会认为一定得找到\*\*加解密函数\*\*。其实不然, 老手都会告诉你无论是APP还是JS中可以先找到\*\*明文点\*\*。
什么是明文点？
在前端进行复杂的请求操作时，肯定会经过一系列从A函数--&gt;B函数--&gt;C函数--&gt;D函数--&gt;E函数之类的流程， 那么在这个流程中，假设D函数是加密函数，那么\*\*ABC函数中原始请求参数\*\*均是明文的，这就是明文点，找到明文点后再一步步调试， 其实就能顺腾摸瓜找到加密函数了。
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/08/attach-f410d5ca2fb5598492dd3571a9e9278b1e3da024.png)
#### v\\_jstools
[cilame/v\\_jstools: 模仿着写一个 chrome 插件，用来快速调试前端 js 代码。 (github.com)](https://github.com/cilame/v\_jstools)
一款比较好用的工具，能够一键监测JS中指定函数的调用
这里我们就以靶场举例看看实际的操作
#### 1. 首先安装好v\\_jstools
进行配置， 选择需要挂钩的函数即可，然后点击挂钩总开关。
具体挂钩什么函数，需要根据具体需求， 千万不要全部都勾上，那样信息流就太多了不利于我们的筛选
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/08/attach-241fd6c529217aac4a69aede39915c5f2ba493ba.png)
#### 2. 打开挂钩功能， 打开浏览器控制台， 刷新
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/08/attach-d93ef2325368402556825c1519a56bee22487a5f.png)
#### 3. 发送数据包，查看提示
这里就可以看到， 针对请求包， 我们找到了请求的明文点
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/08/attach-e0b988c1a42a638e3442ae015293ae395d3f98d6.png)
#### 4. 跟进对应的JS文件
在该代码处打上断点， 跟踪后续的处理
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/08/attach-9062743fb94488fb4d933904768c555e1a532a70.png)
重新发送数据包， 并点击步过， 我们就可以看到 名字为 n 的变量就是我们的提交内容
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/08/attach-6000978475924897f77f9b6c21db77a86e032f1c.png)
此时n还是明文， 那么我们继续步过， 经过 `t.data = l(n)`后，data内容为密文，
经过实际请求包的比较， 发现t.data 即为 加密后的内容， 那么l() 函数即为加密函数
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/08/attach-73b4b91e1f870aeffcb99ab50c2fe279d9c3ed3b.png)
所以我们跟进l() 函数中看看，发现l函数即为加密函数，也顺便发现了解密函数就在下面，其中t参数为原始的内容，f参数为密钥，h为密码。
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/08/attach-492a8cf7e898609ca51acc29cabfe281149faa43.png)
再回到刚刚的起始点， 也可以发现requestID算法，时间戳算法 和 签名算法
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/08/attach-b4606be9f4209864a41afe6159b2e8ad8c7119e3.png)
#### 5. 问题
当然这算是个比较简单的例子，算法和对象的跟踪的都比较直接
##### 1. 为什么不用搜索的方式
如果能搜索到当然好，比如这个环境可以直接通过搜索AES的方式找到上下文。
但现在大部分webpack项目都自带混淆，在生产环境中许多变量和字符无法直接搜索，即使搜索到了阅读上下文也看不懂代码到底是个什么意思。
##### 2. 明文点
上文提到明文点，在这个过程中我们跟踪的两个函数都是明文点，一个是v\\_jstools 提示的函数位置 u.interceptors.request.use((function(t){} ，还有一个是l()函数。生产情况下，我们可能无法直接分析出该函数的作用，即便看不懂，也是大有用处，这点我们后面娓娓道来。
修改数据包
-----
找到明文点后，我们开始着手数据包的修改了，那么我们来了解一下主流的修改方式。
### 分类
1. 修改当前的数据包
浏览器发包后，代理到burp上或通过其他的形式修改这个数据包的内容，主要针对当前数据包的修改
场景： 分析请求参数、添加额外参数、绕过前端校验等等
2. 主动发包的加密与解密
脱离浏览器， 主动发包并加密， 对响应的数据包解密
场景： 自动化工具插入漏洞payload、暴力破解、重放测试等
### 第一大类: 修改当前数据包
#### 青铜 -- 直接在明文点处修改
这里有个账号: test 密码:123
首先我们在表单处输入 test 密码 1234，很明显我们是无法登录的。
这时我们进入到调试中，走到加密前的一步，直接在作用域中修改
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/08/attach-b55166447521e7970d3c65d838061df91e246451.png)
然后继续运行，即可登录成功了
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/08/attach-c02199406c7e353d7399c9bd5c021635c7c1c041.png)
这个方式需要在加密方式和一些签名的步骤之前，否则可能修改无效
#### 白银 -- JS-forward
个人认为仅仅改包的话，是一个比较万金油的办法
首先我们了解一下JS-forward运行原理，简单来说就是在明文点处插入一段JS代码，这段代码先通过AJAX请求将现有的请求内容发送给burpsuite，burpsuite拦截并修改内容后，返回到原始变量中，优点是操作比较统一，如果明文点正确，后续所有的改包操作都可以在burpsuite中进行
大概就是这样一个流程
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/08/attach-e6ffa6bb370f48302bf16092c0e201e77bc8819f.png)
所以我们来实现， 步骤有一丢丢麻烦，请耐心看完
##### a. 找到明文点
确认明文变量名，然后启动JS-forward
这里我们需要将变量名向前看一点，确认明文变量就是t.data
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/08/attach-e72f60913687976504edb26c9165547a2f251b24.png)
启动JS-forward
输入变量名: t.data
输入数据类型： json (JS原始对象也可设置为JSON)
输入请求标识： REQUEST
> 这里的请求标识仅仅作为标识使用， 没有任何意义， 主要是为了在burpsuite中区分请求包和响应包
输入$end 结束后， 会监听2个端口 分别是38080， 28080， 还会生成一段JS代码我们留作后续使用。
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/08/attach-6a6ca0c36f0dfcbe6d84a267a764ad2b3b6b4a2b.png)
##### b. 插入JS代码
JS-forward 的使用尽量在明文点的函数第一行插入相关代码，因为不知道后续代码会做什么样的操作。
具体的插入方式
b1： 找到F12--源代码--替换（覆盖）--点击选择文件夹--选择我们硬盘中一个空文件夹
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/08/attach-1b14924ee8360c457a876ce73b13b7e31a7010f3.png)
如果浏览器有提示点击允许
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/08/attach-49f95e8c65a676889f378d6eab33da9a7660054e.png)
b2: 在 网页--明文点JS文件处--右键--替换内容
（因为只有这样才能修改JS中的代码）
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/08/attach-f4e6f5d7080c9e005d954e8a83a3bab0ea2679f4.png)
b3: 将JS-forward中生成的代码，复制到函数第一行，Ctrl+S保存
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/08/attach-42e35e35f3c9557cf1512b5113693ac10c781b61.png)
##### c. 打开burpsuite
关闭调试功能或关闭F12，刷新页面，再次发包时即可接收到明文信息
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/08/attach-4fe561fd633d4e474e7f65d16bf540502f43983b.png)
##### d. 注意
1. 能够理解原理的话， 尽量自己思考思考。此功能与浏览器--burpsuite代理无关，浏览器的代理可不设置为burpsuite。
2. 另外在实际测试过程中\*\*谷歌浏览器\*\*会报CORS错误，\*\*edge\*\*正常，具体原因不明，以后有机会再分析
### 第二大类: 主动发包的加密与解密
以上方法只适合修改浏览器的提交操作后的数据包修改
- 优点：是简单易上手，就算是复杂的加密环境，只要找到明文点，后续工作不太复杂。
- 缺点：是无法应对主动发包的情况，比如要使用被动扫描工具，暴力破解，重放测试等需求的时候，无法自动化完成。
所以我们介绍第二类的解决方案，为什么不直接介绍这个方式呢？主要还是因为主动发包的加密和解密更加复杂，需要读懂\*\*目标JS代码环境中防范改包\*\*的一些\*\*业务逻辑\*\*，如果目标的JS代码混淆和加密并不是特别厉害，还是可以一试的。
在这之前再来了解一款工具
#### JS-RPC
[jxhczhl/JsRpc: 远程调用(rpc)浏览器方法，免去抠代码补环境 (github.com)](https://github.com/jxhczhl/JsRpc)
所谓RPC，翻译过来是远程调用的意思，简单来说就是搭建一个桥梁让两个不同的应用系统之间一方能主动调用另外一方的api或函数。
我们知道浏览器中的加解密都是通过JS实现的，但如果想脱离浏览器在本地运行JS代码最大一个问题就是\*\*如何调用浏览器的api\*\*。举个例子: 比如我们想在python中执行JS中的解密函数，我...