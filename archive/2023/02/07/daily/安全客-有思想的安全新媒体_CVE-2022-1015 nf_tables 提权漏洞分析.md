---
title: CVE-2022-1015 nf_tables 提权漏洞分析
url: https://www.anquanke.com/post/id/286079
source: 安全客-有思想的安全新媒体
date: 2023-02-07
fetch_date: 2025-10-04T05:50:28.221529
---

# CVE-2022-1015 nf_tables 提权漏洞分析

首页

阅读

* [安全资讯](https://www.anquanke.com/news)
* [安全知识](https://www.anquanke.com/knowledge)
* [安全工具](https://www.anquanke.com/tool)

活动

社区

学院

安全导航

内容精选

* [专栏](/column/index.html)
* [精选专题](https://www.anquanke.com/subject-list)
* [安全KER季刊](https://www.anquanke.com/discovery)
* [360网络安全周报](https://www.anquanke.com/week-list)

# CVE-2022-1015 nf\_tables 提权漏洞分析

阅读量**423498**

发布时间 : 2023-02-06 16:45:35

**x**

##### 译文声明

本文是翻译文章

译文仅供参考，具体内容表达以及含义原文为准。

![]()

author: 莫兴远 of [IceSword Lab](https://www.iceswordlab.com/about/)

## 一、简介

CVE-2022-1015 是 Linux 内核 nf\_tables 模块的一个漏洞，其成因为没有合理限制整数范围导致栈越界读写。

受该漏洞影响的内核版本范围为 5.12 ~ 5.16 。

该漏洞为此 [commit](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=6e1acfa387b9ff82cfc7db8cc3b6959221a95851) 所修复。

## 二、漏洞相关知识

Netfilter 是 Linux 内核一个非常庞大的子系统，它在内核的网络栈中置入多个钩子，并允许其他模块在这些钩子处注册回调函数，当内核执行到钩子处时，所有被注册的回调函数都会被执行。

nf\_tables 则是隶属于 Netfilter 子系统的一个模块，它在 Netfitler 的某些钩子处注册了回调函数，以提供网络数据包过滤功能，通常被用于实现防火墙等功能。本文所分析的漏洞就位于 nf\_tables 模块中。

在用户态与 nf\_tables 交互则是通过 netlink。netlink 是常见的用户态与内核态进行交互的手段，它通过向 AF\_NETLINK 类型的 socket 发送数据向内核传递信息，类似地，还可通过从该类型 socket 接收数据以获取内核传递回来的信息。

### 2.1 nf\_tables实现

nf\_tables 允许用户向其注册处理网络数据包的 rule，以决定针对不同类型的数据包该采取哪种行动。多条 rule 被组织在一条 chain 中，多条 chain 则被组织在一个 table 中。不同类型的 chain 会与不同的 Netfilter hook 绑定在一起。当网络数据包到达后，经过内核不同的 hook 时，所有绑定在该 hook 处的 chain 都会被执行，以完成对数据包的处理。在这里，chain 的执行是指其中所有的 rule 被依次执行，rule 的执行则又是指数据包会根据其中拟定的规则确定被采取什么行动，是丢弃、拒绝还是接受。

向 nf\_tables 注册 rule 的方式是通过 netlink。由于通过 netlink 向内核发送的数据包过于底层，用户使用起来不方便，开发者提供了用户态工具 nft，方便用户通过更高级的语法拟定规则。

**2.1.1 rule**

rule 包含如何处理数据包的逻辑，比如检查数据包的协议、源地址、目标地址、端口等，以分别采取不同的行动。每条 rule 都和一个 verdict 绑定，即每条 rule 都有一个默认的裁定，决定对数据包采取何种行为，是丢弃、拒绝还是接受。举个例子：

```
udp dport 50001 drop
```

drop 就是该 rule 的 verdict，表示所有目标端口为 50001 的 udp 数据包都会被丢弃。

**2.1.2 chain**

chain 是将 rule 组织起来的结构，一条 chain 可包含多条 rule。chain 分为 base chain 和 non-base chain，base chain 是直接绑定到 Netfilter hook 上面的，执行流只会从 base chain 开始。chain 中的 rule 一般都是依次执行完，有时候某条 rule 的 verdict 会让执行流跳转到其他的 chain，从而越过该 chain 中剩下的 rule，但只能跳转到 non-base chain。跳转分两种，一种是跳转后到某条 chain 后就不可以返回了，另一种则是跳转后还可以返回继续执行原来的 chain 剩下的 rule。

**2.1.3 table**

table 是 nf\_tables 最顶层的结构，它包含多条 chain。chain 只能跳转到同一 table 中的其他 chain。

每个 table 都会从属于某个族，族决定了该 table 会处理哪些种类的数据包。族包括 ip、 ip6、 inet、 arp、 bridge 和 netdev。

属于 ip 族的 table 只负责处理 IPv4 数据包，属于 ip6 族的 table 只负责处理 IPv6 数据包，属于 inet 族的 table 则既可处理 IPv4 又可处理 IPv6 数据包。

**2.1.4 expression**

事实上，rule 在层次结构上还可以细分为多个 expression，expression 相当于一条条应用在数据包上的具体指令。用户态工具一般不会涉及到 expression 这个抽象表示，只有内核代码会涉及到。

对于 udp dport 50001 drop 这个规则，需要先通过一个 expression 检查协议是不是 udp，再通过一个 expression 检查端口是不是 50001，如果前面的 expression 都通过了，最后再通过一个 expression 将 verdict 设置为 drop，以将数据包丢弃。

每种 expression 会和一个 struct nft\_expr\_ops 实例绑定，比如 immediate 这个 expression：

```
static const struct nft_expr_ops nft_imm_ops = {
    .type        = &nft_imm_type, // expression 类型
    .size        = NFT_EXPR_SIZE(sizeof(struct nft_immediate_expr)),
    .eval        = nft_immediate_eval, // 当 expression 被执行时调用
    .init        = nft_immediate_init, // 当 expression 被初始化时调用
    .activate    = nft_immediate_activate,
    .deactivate    = nft_immediate_deactivate,
    .destroy    = nft_immediate_destroy,
    .dump        = nft_immediate_dump,
    .validate    = nft_immediate_validate,
    .reduce        = nft_immediate_reduce,
    .offload    = nft_immediate_offload,
    .offload_action    = nft_immediate_offload_action,
};
```

每次当一条 rule 被添加进来，其所有 expression 的 init 函数都会被调用。

当某个 expression 被执行时，其 eval 函数会被调用。

**2.1.5 register**

expression 在操作数据包时，需要内存来记录一些数据，这部分内存就是 register。在内核的实现中，所有 register 都在栈上，且在内存地址上是连续的。

expression 可以读取或修改 register 的数据，单次访问的对象既可以是单个 register，也可以是连续的多个 register，因此 register 可以看做是一块连续的缓冲区。

register 可通过 index 索引，以下是内核中定义的 register 的 index：

```
enum nft_registers {
    NFT_REG_VERDICT,
    NFT_REG_1,
    NFT_REG_2,
    NFT_REG_3,
    NFT_REG_4,
    __NFT_REG_MAX,

    NFT_REG32_00    = 8,
    NFT_REG32_01,
    NFT_REG32_02,
    ...
    NFT_REG32_13,
    NFT_REG32_14,
    NFT_REG32_15,
};
```

register 有两种索引方式。NFT\_REG\_1 到 NFT\_REG\_4 是一种，共 4 个 register，每个 16 字节；NFT\_REG32\_00 到 NFT\_REG32\_15 是另一种，共 16 个 reigster，每个 4 字节。在两种索引方式中，NFT\_REG\_VERDICT 都指向 verdict register，大小为 16 字节。两种索引方式针对的都是同一片内存，因此内存总数都是 16 + 4  *16 = 16 + 16*  4 = 80 字节。

![]()![]()

verdict register 在内存上位于最前，每条 rule 执行完后都会设置好 verdict register，以决定下一步该怎么执行。verdict register 可以设置成以下值：

| verdict | 作用 |
| --- | --- |
| NFT\_CONTINUE | 默认 verdict，继续执行下一个 expression。 |
| NFT\_BREAK | 跳过该 rule 剩下的 expression，继续执行下一条 rule。 |
| NF\_DROP | 丢弃数据包，停止执行。 |
| NF\_ACCEPT | 接受数据包，停止执行。 |
| NFT\_GOTO | 跳转到另一条 chain，且不再返回。 |
| NFT\_JUMP | 跳转到另一条 chain，执行完该 chain 后，若 verdict 为 NFT\_CONTINUE，则返回原本的 chain 继续执行。 |

**2.1.6 nft\_do\_chain**

nft\_do\_chain 实现了依次执行所有 base chain 中所有 rule 的所有 expression 的逻辑，以下是添加了许多说明性注释的该函数的代码：

```
unsigned int
nft_do_chain(struct nft_pktinfo *pkt, void *priv)
{
    const struct nft_chain *chain = priv, *basechain = chain;
    const struct nft_rule_dp *rule, *last_rule;
    const struct net *net = nft_net(pkt);
    const struct nft_expr *expr, *last;
    struct nft_regs regs;
    unsigned int stackptr = 0;
    struct nft_jumpstack jumpstack[NFT_JUMP_STACK_SIZE];
    bool genbit = READ_ONCE(net->nft.gencursor);
    struct nft_rule_blob *blob;
    struct nft_traceinfo info;

    info.trace = false;
    if (static_branch_unlikely(&nft_trace_enabled))
        nft_trace_init(&info, pkt, &regs.verdict, basechain);
do_chain:
    if (genbit)
        blob = rcu_dereference(chain->blob_gen_1);
    else
        blob = rcu_dereference(chain->blob_gen_0);

    rule = (struct nft_rule_dp *)blob->data;
    /* 获取最后一条 rule 的位置，以确定循环的停止条件 */
    last_rule = (void *)blob->data + blob->size;
next_rule: // 执行到一条新的 chain，或返回到原来的 chain，都从这里开始
    regs.verdict.code = NFT_CONTINUE; // the default verdict code = NFT_CONTINUE
    for (; rule < last_rule; rule = nft_rule_next(rule)) { // iterate through the rules
        /* iterate through the expressions */
        nft_rule_dp_for_each_expr(expr, last, rule) {
            // execute the expression
            if (expr->ops == &nft_cmp_fast_ops)
                nft_cmp_fast_eval(expr, &regs);
            else if (expr->ops == &nft_cmp16_fast_ops)
                nft_cmp16_fast_eval(expr, &regs);
            else if (expr->ops == &nft_bitwise_fast_ops)
                nft_bitwise_fast_eval(expr, &regs);
            else if (expr->ops != &nft_payload_fast_ops ||
                 !nft_payload_fast_eval(expr, &regs, pkt))
                expr_call_ops_eval(expr, &regs, pkt);
            /* 如果 verdict 不是 NFT_CONTINUE， 停止执行该 rule 接下来的 expression */
            if (regs.verdict.code != NFT_CONTINUE)
                break;
        }

        // 已执行完一条 rule，检查 verdict，
    // 如果不是 NFT_BREAK 或 NFT_CONTINUE，停止执行该 chain 剩下的 rule
        switch (regs.verdict.code) {
        case NFT_BREAK:
            // 若为 NFT_BREAK，则将 verdict 设置回 NFT_CONTINUE。
            // NFT_BREAK 和 NFT_CONTINUE 类似，都会执行下一条 rule，
      // 只是 NFT_BREAK 会跳过当前 rule 剩下的 expression。
            regs.verdict.code = NFT_CONTINUE;
            nft_trace_copy_nftrace(pkt, &info);
            continue;
        case NFT_CONTINUE:
            // 执行到这里代表执行完了当前 rule 的所有 expression，
      // 继续执行下一条 rule 即可。
            nft_trace_packet(pkt, &info, chain, rule,
                     NFT_TRACETYPE_RULE);
            continue;
        }
        // 若 verdict 不是 NFT_BREAK 或 NFT_CONTINUE，
    // 代表即将跳过该 chain 剩下的 rule，停止该 chain 的执行。
        break;
    }

    nft_trace_verdict(&info, chain, rule, &regs);

    // 执行到这里代表执行完了某条 chain，
  // 将根据 verdict 决定采取的行动
    switch (regs.verdict.code & NF_VERDICT_MASK) {
    case NF_ACCEPT:
    case NF_DROP:
    case NF_QUEUE:
    case NF_STOLEN:
        // 已经决定好对当前数据包的处理，退出函数即可。
        return regs.verdict.code;
    }

    // 尚未决定好对数据包的处理，继续执行。
    switch (regs.verdict.code) {
    case NFT_JUMP:
        // 跳转到另一条 chain，将返回时需要的信息保存到 jumpstack 上
    // 返回后，执行的是当前 rule 的下一条 rule
        if (WARN_ON_ONCE(stackptr >= N...