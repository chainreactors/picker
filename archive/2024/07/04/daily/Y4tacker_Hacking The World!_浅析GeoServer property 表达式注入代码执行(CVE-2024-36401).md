---
title: 浅析GeoServer property 表达式注入代码执行(CVE-2024-36401)
url: https://y4tacker.github.io/2024/07/03/year/2024/7/%E6%B5%85%E6%9E%90GeoServer-property-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C-CVE-2024-36401/
source: Y4tacker:Hacking The World!
date: 2024-07-04
fetch_date: 2025-10-06T17:40:59.226734
---

# 浅析GeoServer property 表达式注入代码执行(CVE-2024-36401)

* [Home](/)
* [Writing](/archives/)
* [Topics](/tags/)
* [Search](/search/)
* [About](/about/)
* [Friends](/link/)

Previous post Next post Back to top Share post

1. [1. 漏洞复现分析](#%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90)
2. [2. 路由分析](#%E8%B7%AF%E7%94%B1%E5%88%86%E6%9E%90)
3. [3. 后话](#%E5%90%8E%E8%AF%9D)
4. [4. 参考链接](#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5)

# 浅析GeoServer property 表达式注入代码执行(CVE-2024-36401)

Y4tacker

2024-07-03 (Updated: 2024-07-04)

[Java](/categories/Java/)

[GeoServer](/tags/GeoServer/), [Java](/tags/Java/)

## 漏洞复现分析

从公告来看，漏洞来源于geotools这个库使用apache xpath解析xpath导致的问题

<https://github.com/geoserver/geoserver/security/advisories/GHSA-6jj6-gm7p-fcvv>

<https://github.com/geotools/geotools/pull/4797>

<https://github.com/geotools/geotools/security/advisories/GHSA-w3pj-wh35-fq8w>

之后简单看看geotools的commit可以发现有很多

<https://github.com/geotools/geotools/pull/4797/commits/e53e5170ba71521728875a436c80616cfb03c1e8>

比如，从上到下依次看有很多能触发的方式，这里我们简单有个印象即可

|  |  |
| --- | --- |
| ``` 1 2 3 4 5 6 7 ``` | ``` rg.geotools.appschema.util.XmlXpathUtilites.getXPathValues(NamespaceSupport, String, Document) org.geotools.appschema.util.XmlXpathUtilites.countXPathNodes(NamespaceSupport, String, Document) org.geotools.appschema.util.XmlXpathUtilites.getSingleXPathValue(NamespaceSupport, String, Document) org.geotools.data.complex.expression.FeaturePropertyAccessorFactory.FeaturePropertyAccessor.get(Object, String, Class<T>) org.geotools.data.complex.expression.FeaturePropertyAccessorFactory.FeaturePropertyAccessor.set(Object, String, Object, Class) org.geotools.data.complex.expression.MapPropertyAccessorFactory.new PropertyAccessor() {...}.get(Object, String, Class<T>) org.geotools.xsd.StreamingParser.StreamingParser(Configuration, InputStream, String) ``` |

再看geoserver的公告，以下这些都能被利用

![image-20240703162342214](/2024/07/03/year/2024/7/%E6%B5%85%E6%9E%90GeoServer-property-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C-CVE-2024-36401/image-20240703162342214.png)

首先以最简单的GetPropertyValue为例，从官方文档可以看到具体的使用方法，<https://docs.geoserver.org/latest/en/user/services/wfs/reference.html#getpropertyvalue>

![image-20240703224128239](/2024/07/03/year/2024/7/%E6%B5%85%E6%9E%90GeoServer-property-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C-CVE-2024-36401/image-20240703224128239.png)

我比较懒找了个之前的老环境代码方便我本地调试

<https://versaweb.dl.sourceforge.net/project/geoserver/GeoServer/2.21.3/geoserver-2.21.3-war.zip?viasf=1>

可以看到在`org.geoserver.wfs.GetPropertyValue#run`，红框中的代码从请求中获取了`valuereference`参数，之后调用工厂类的property方法获取`PropertyName`对象

![image-20240703224938791](/2024/07/03/year/2024/7/%E6%B5%85%E6%9E%90GeoServer-property-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C-CVE-2024-36401/image-20240703224938791.png)

我们来看看这个工厂类的调用，直接返回一个被`AttributeExpressionImpl`包装的对象

![image-20240703230134192](/2024/07/03/year/2024/7/%E6%B5%85%E6%9E%90GeoServer-property-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C-CVE-2024-36401/image-20240703230134192.png)

同时实例化时将参数赋给attPath

![image-20240703230505213](/2024/07/03/year/2024/7/%E6%B5%85%E6%9E%90GeoServer-property-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C-CVE-2024-36401/image-20240703230505213.png)

接下来再来看看evaluate的调用，在这里会通过`PropertyAccessors.findPropertyAccessors`获取合适的属性访问器，之后遍历调用其`get`方法，其中就包括了`org.geotools.data.complex.expression.FeaturePropertyAccessorFactory.FeaturePropertyAccessor#get`，官方公告列出来的就有这个

![image-20240703232348317](/2024/07/03/year/2024/7/%E6%B5%85%E6%9E%90GeoServer-property-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C-CVE-2024-36401/image-20240703232348317.png)

在下面的代码中可以解析xpath表达式，因此从上面分析下来这个xpath就是valuereference中的值，整个流程也就走通了

![image-20240703233055237](/2024/07/03/year/2024/7/%E6%B5%85%E6%9E%90GeoServer-property-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C-CVE-2024-36401/image-20240703233055237.png)

## 路由分析

同时像我这种好奇宝宝一般是比较好奇一些路由方法的调用，就比如为什么通过参数中的`request`能调用对应方法，这个项目主体框架是spring

以我下载的war为例，先看web.xml，通常而言这就是我们项目的主入口，但是点进去一看，在配置文件中大多只有Servlet的过滤器链的配置，而没有具体接口的配置，当然唯一的可以看到将请求都通过spring的DispatcherServlet派发

|  |  |
| --- | --- |
| ``` 1 2 3 4 5 6 7 8 9 10 11 12 ``` | ``` <!-- spring dispatcher servlet, dispatches all incoming requests --> <servlet>   <servlet-name>dispatcher</servlet-name>   <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class> </servlet>   <!-- single mapping to spring, this only works properly if the advanced dispatch filter is       active --> <servlet-mapping>     <servlet-name>dispatcher</servlet-name>     <url-pattern>/*</url-pattern> </servlet-mapping> ``` |

因此接下来我们就得看看，spring项目的一些其他配置文件，比如`\geoserver\WEB-INF\lib\gs-wfs-2.21.3.jar!\applicationContext.xml`，看着这个配置文件就会更为亲切，当然又扯远了，回到正文

在这个项目中，`org.geoserver.ows.Dispatcher`继承了`AbstractController`并实现了`handleRequestInternal`方法

|  |  |
| --- | --- |
| ``` 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 ``` | ``` protected ModelAndView handleRequestInternal(HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws Exception {     this.preprocessRequest(httpRequest);     Request request = new Request();     request.setHttpRequest(httpRequest);     request.setHttpResponse(httpResponse);     Service service = null;      try {         try {             request = this.init(request);             REQUEST.set(request);              Object result;             try {                 service = this.service(request);             } catch (Throwable var11) {                 this.exception(var11, (Service)null, request);                 result = null;                 return (ModelAndView)result;             }              if (request.getError() != null) {                 throw request.getError();             }              Operation operation = this.dispatch(request, service);             request.setOperation(operation);             if (request.isSOAP()) {                 this.flagAsSOAP(operation);             }              result = this.execute(request, operation);             if (result != null) {                 this.response(result, request, operation);                 return null;             }         } catch (Throwable var12) {             if (isSecurityException(var12)) {                 throw (Exception)var12;             }              this.exception(var12, service, request);         }          return null;     } finally {         this.fireFinishedCallback(request);         REQUEST.remove();     } }  Object execute(Request req, Operation opDescriptor) throws Throwable {     Service serviceDescriptor = opDescriptor.getService();     Object serviceBean = serviceDescriptor.getService();     Object[] parameters = opDescriptor.getParameters();     Object result = null;      try {         if (serviceBean instanceof DirectInvocationService) {             String operationName = opDescriptor.getId();             result = ((DirectInvocationService)serviceBean).invokeDirect(operationName, parameters);         } else {             Method operation = opDescriptor.getMethod();             result = operation.invoke(serviceBean, parameters);         }     } catch (Exception var8) {         if (var8.getCause() != null) {             throw var8.getCause(); ...