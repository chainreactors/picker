---
title: 公开的隐秘：CVE-2024-30051在野提权漏洞研究
url: https://mp.weixin.qq.com/s?__biz=MzU5NDgxODU1MQ==&mid=2247502008&idx=1&sn=32eb5b732b23cab67d8003b1974eb88c&chksm=fe79ec20c90e653629a844feee3fdd101acbd5cb2b5f841aa7aefb53bdc20748d4f36dd6addf&scene=58&subscene=0#rd
source: 奇安信 CERT
date: 2024-09-06
fetch_date: 2025-10-06T18:27:01.270220
---

# 公开的隐秘：CVE-2024-30051在野提权漏洞研究

![cover_image](https://mmbiz.qpic.cn/sz_mmbiz_jpg/2AqAgxkehicibc7GF01uTiaj9du8XibMdNmOhTePTq4hbIekmwNR20qYCh0ScUwEqemQHibJ1sJubP7bk6zibYiaib6fIA/0?wx_fmt=jpeg)

# 公开的隐秘：CVE-2024-30051在野提权漏洞研究

奇安信 CERT

以下文章来源于奇安信威胁情报中心
，作者威胁情报中心

![](http://wx.qlogo.cn/mmhead/Q3auHgzwzM7I8QeMG3CujdN79zxbczFS3XAMP0KcY9YcqkRIHEy7CQ/0)

**奇安信威胁情报中心**
.

威胁情报信息共享，事件预警通报，攻击事件分析报告，恶意软件分析报告

综述

CVE-2024-30051 该漏洞最早由卡巴斯基发现，但是最初卡巴发现的并不是在野样本，而是该漏洞的简单分析报告被传到 vt 上去了，之后我们通过相关报告中漏洞的特征，找到了 QakBot 利用的实际样本(c4dd780560091c8d2da429c7c689f84b)，其运行效果如下所示，有意思的是泄露的分析报告和该漏洞样本在 vt 的出现时间分别是 2024/04/01 和 2024/04/18，考虑到样本的实际攻击流程和文档中描述几乎一致，且 18 天时间过于短暂，我们认为该样本不是第三方攻击者在获取该文档后开发，应该就是文档中描述的原版漏洞利用样本。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2AqAgxkehicibc7GF01uTiaj9du8XibMdNmOaTl68cxziacP28IbPh7Hg1vmAoGAG9fY53J9OU4jibDqeogAChOplIfg/640?wx_fmt=png&from=appmsg)

漏洞的核心问题出在 dwmcore.dll 这个 dwm 进程的核心 dll 中，具体问题在函数 CCommandBuffer::Initialize 中，可以看到这里 mempy 操作中的长度由攻击者控制 len\_control，目标地址的内存空间分配时 size=(len\_control/0x90)\*0x90，套用以上公式，如当 len\_control=0x95，则实际分配的内存只有 0x90，之后 memory 时将导致 0x5 长度的越界写入。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2AqAgxkehicibc7GF01uTiaj9du8XibMdNmOkGEJmDXDfNnA9cwkRMESa6MMwEqYInrZYH5iaQURzKjEZYEomcibnuibQ/640?wx_fmt=png&from=appmsg)

DWM

要理解该漏洞，首先我们需要对 Windows 中的 dwm 进程有一个简单了了解，dwm 是 Desktop Window Manager 的缩写，中文译为桌面窗口管理器。它是一个 Windows 系统中的核心进程，负责管理桌面上的窗口，并提供各种视觉效果，用户可以通过 dcomp.dll 中的相关 com 接口调用控制 dwm 的相关行为，但是 dcomp.dll 对 dwm 的调用并不是直接，而是跨内核的，其流程简单来说是用户-> dcomp.dll -> win32kbase(内核)-> dwm.exe(用户层)。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2AqAgxkehicibc7GF01uTiaj9du8XibMdNmOdwAEvkC6mjkAMdyOLfMkaicrVYw344Gym7mgz1oQPn5xiaA7zKPU2CKg/640?wx_fmt=png&from=appmsg)

而该漏洞主要涉及DirectComposition对象，要触发使用DirectComposition对象需要使用到以下三个核心函数：

* NtDCompositionCreateChannel
* NtDCompositionProcessChannelBatchBuffer
* NtDCompositionCommitChannel

创建 DirectComposition 对象，需要通过 NtDCompositionCreateChannel 系统调用创建一个通道。

```
typedef NTSTATUS(*pNtDCompositionCreateChannel)(OUT PHANDLE hChannel,IN OUT PSIZE_T pSectionSize,OUT PVOID* pMappedAddress);
```

通道创建完毕后，通过 NtDCompositionProcessChannelBatchBuffer 系统调用发送具体的调用命令，每个命令都有各自的格式，命令保存在 NtDCompositionCreateChannel 返回的 pMappedAddress 中。

```
typedef NTSTATUS(*pNtDCompositionProcessChannelBatchBuffer)(IN PHANDLE hChannel,IN DWORD dwArgStart,OUT PDWORD pOutArg1,OUT PDWORD pOutArg2);
```

涉及的命令如下所示：

```
enum DCOMPOSITION_COMMAND_ID {   ProcessCommandBufferIterator,   CreateResource,   OpenSharedResource,   ReleaseResource,   GetAnimationTime,   CapturePointer,   OpenSharedResourceHandle,   SetResourceCallbackId,   SetResourceIntegerProperty,   SetResourceFloatProperty,   SetResourceHandleProperty,   SetResourceHandleArrayProperty,   SetResourceBufferProperty,   SetResourceReferenceProperty,   SetResourceReferenceArrayProperty,   SetResourceAnimationProperty,   SetResourceDeletedNotificationTag,   AddVisualChild,   RedirectMouseToHwnd,   SetVisualInputSink,   RemoveVisualChild };
```

NtDCompositionCommitChannel 生成批处理命令 bufer 并发送到 DWM 进程，总结来说：

NtDCompositionCreateChannel 函数创建一个和 dwm 的通信通道，并获取一个用于发送命令的 pMappedAddress，NtDCompositionProcessChannelBatchBuffer 函数通过通信通道，在pMappedAddress 中设置需要使用的命令，NtDCompositionCommitChannel 触发具体的命令执行并通过 dwm 进程渲染结果。

```
typedef NTSTATUS(*pNtDCompositionCommitChannel)(IN HANDLE hChannel,OUT PDWORD out1,OUT PDWORD out2,IN DWORD flag,IN HANDLE Object);
```

漏洞样本分析

样本运行之后首先调用 RtlGetVersion 函数获取当前系统版本，并以此初始化后续利用中的几个核心常量。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2AqAgxkehicibc7GF01uTiaj9du8XibMdNmO9Vo8Dstfn4tA6jqgY2yHkUjtLI6E0K7jnFVT5cYHKC5bgz7Hf4ZeTg/640?wx_fmt=png&from=appmsg)

动态获取以下函数的 api 地址。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2AqAgxkehicibc7GF01uTiaj9du8XibMdNmO4SibWHkF5MnKOIZyzvCmBCPXtMSBwC7DWcdTxOiaknRBxB7iaticYMEia0g/640?wx_fmt=png&from=appmsg)

之后通过函数 fun\_hookInit/fun\_hookSpecialfunInstall 完成对以下四个函数的 hook：

* NtDCompositionCommitChannel
* NtDCompositionCreateChannel
* RtlCreateHeap
* RtlAllocateHeap

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2AqAgxkehicibc7GF01uTiaj9du8XibMdNmO1XxxRgrLfibOCrRsRwQj1rmC82YPDU7xyYksDKnDYu1ZzqOWt9zyItA/640?wx_fmt=png&from=appmsg)

这里的 hook，总结来说就是 fun\_hookInit 函数完成 hook 是中间跳转代码的生成，如下所示：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2AqAgxkehicibc7GF01uTiaj9du8XibMdNmOGe5Rqk7hjTapCHBFftErgTqewes2NCxmZ5Y1CE8kkiaCnSdmKico4ib9Q/640?wx_fmt=png&from=appmsg)

fun\_hookSpecialfunInstall 完成目标函数 hook。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2AqAgxkehicibc7GF01uTiaj9du8XibMdNmOf9VpGibow05o1qCH5ZlKn8BD0Yicx70TIOdVuZ51OY6nOHaAPqwiaYBYA/640?wx_fmt=png&from=appmsg)

详细来看这四个函数 hook 后进行了哪些操作，其中 RtlCreateHeap/RtlAllocateHeap 是对堆创建和分配的操作，当 RtlCreateHeap 的参数 a2 传入堆对象分配时的基址时，hookpro 保存返回的堆对像为 pointer\_specialHeapobject，针对 RtlAllocateHeap 函数，当 RtlAllocateHeap 分配堆时，如果对应的堆对象为前面 RtlCreateHeap hook 时保存的 pointer\_specialHeapobject 时，返回此时分配的堆地址，总结一下，这里会监控传入堆基址的堆对象的创建过程，并保存该分配的堆地址。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2AqAgxkehicibc7GF01uTiaj9du8XibMdNmO6R0ySgKSiapASydsrcIN1skGicCIH0J0kxNXCyH6s2QZIaiawhXmftN7g/640?wx_fmt=png&from=appmsg)

针对函数 fun\_hookProNtDCompositionCreateChannel 的 hook，其会监控第一次 NtDCompositionCreateChannel 的创建，并获取该 Channel 对应的 pMappedAddress，保存为 pointer\_pMappedAddress。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2AqAgxkehicibc7GF01uTiaj9du8XibMdNmODWFTjCSpcGegVtUfxrGFnmUOhfYRonvu11rVWp1FsgZdBPuYKianqOw/640?wx_fmt=png&from=appmsg)

针对函数 NtDCompositionCommitChannel 的 hook 就比较复杂了，通过前文我们知道 NtDCompositionCommitChannel 用于生成批处理命令 bufer 并发送到 DWM 进程，这里同样hook的时候会确保是第一次 NtDCompositionCommitChannel 的调用，并在 pointer\_specialHeapalloc 这段前面堆分配中获取的内存中搜索 0x120 这个字段，找到将该字段修改为 var\_contrulLen，不同环境下的利用有所区别，这里是 0x23f(var\_contrulLen(0x1B0)+0x8f)，之后 0x23f/0x90 = 4，看到这里我们基本可以猜测，这个位置的 0x23f 就是漏洞中攻击者控制的 len\_control。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2AqAgxkehicibc7GF01uTiaj9du8XibMdNmOxdQDyAoR1ttmDCeKyq1NlKibqyfR1UcpkYlTd75x9BXHcypCwXlia89Q/640?wx_fmt=png&from=appmsg)

根据 0x23f/0x90 = 4 进行 4 次拷贝，拷贝的内容为 len\_control+0x2c 处开始长度为 0x90 的内存，向后依次保存，此外拷贝的内容中会有两处地址的值被设置为 0。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2AqAgxkehicibc7GF01uTiaj9du8XibMdNmOMq3r3Z0v4b1KEbMhECvmTMs3P9qh8HdoeLMhUibBcdiag5MozILk7Fng/640?wx_fmt=png&from=appmsg)

之后调用四次 NtDCompositionProcessChannelBatchBuffer，这里使用的命令是 SetResourceIntegerProperty，资源号从 1-4，资源对应的 Propertyid 4 被设置为值 1000。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2AqAgxkehicibc7GF01uTiaj9du8XibMdNmOBNGSicbEKOfXA9YhZibCvt1XJFf3OqyicXtK0DSK9sYDLp2sE019fpm4w/640?wx_fmt=png&from=appmsg)

hook 完成后，通过 fun\_trigger 函数触发漏洞完成提权操作。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2AqAgxkehicibc7GF01uTiaj9du8XibMdNmOvhl3w6rMib1ceynUazia4CBDZWQQyXBVLmjyohuYAt1faxqHjF68kysQ/640?wx_fmt=png&from=appmsg)

fun\_trigger 中首先注册了一个窗口类，调用函数 fun\_windowsInit 完成相关窗口的后续定义工作，然后调用函数 DirectComposition::CDevice::Commit。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2AqAgxkehicibc7GF01uTiaj9du8XibMdNmOicKJFUWLJUVT6kNxBsSLsWG5tlUicHISibs5WQmAJGaxr8NBydZeqHJQg/640?wx_fmt=png&from=appmsg)

首先来看 fun\_windowsInit，根据前面注册的窗口类，创建了一个名为 test 的窗口。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2AqAgxkehicibc7GF01uTiaj9du8XibMdNmOjNuSNWAIhh3qvxQIcRCPJhzc31Sa9icYliaMbGiaIkiakQA2icHLcdAMt6w/640?wx_fmt=png&from=appmsg)

之后的代码比较复杂，总结起来就是通过 D2D1CreateFactory 创建了一个 2d 绘图的工厂接口，使用工厂接口创建了一个 surface，一个 visual，这里 surface 可以简单理解为一张画布，visual 则可以理解为一个画框，在画布上完成绘制后，放入该 visual 画框，并和前面的 test 窗口关联起来，并在 fun\_windowsInit 返回后通过函数 DirectComposition::CDevice::Commit 将当前的 DirectComposition 场景提交给图形硬件进行渲染。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2AqAgxkehicibc7GF01uTiaj9du8XibMdNmOLXqVYHgAT2gH3YPPAqXVhXWVGhLsXzg0Roj3VEEDf4an7N6fXWmIrw/640?wx_fmt=png&from=appmsg)

完成 test 窗口图形硬件绘制后，释放出后续的 s1.dll。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2AqAgxkehicibc7GF01uTiaj9du8XibMdNmOSxcbd9ZvUqviaYV1kTibuhxOMcNdpDWvZp3eY4LicqyGGxGMibUAwibTgwg/640?wx_fmt=png&from=appmsg)

根据前面探测的版本进入指定版本的利用流程，这里我们进入 var\_osVersiontype=2 的利用类型，函数 NtDCompositionCreateChannel 开启一个 Channel，通过该 Channel 调用 NtDCompositionProcessChannelBatchBuffer，该函数调用 0x10000 次，每次调用传入的指令是 CreateResource，对应创建的资源 id从0x14 到 0x10014，资源类型为 CHolographicInteropTextureMarshaler。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/2AqAgxkehicibc7GF01uTiaj9du8XibMdNmOEXD47bHw9GHO9...