---
title: [s|l]trace - Linux Malware Analysis
url: https://dfir.ch/posts/strace/
source: Over Security - Cybersecurity news aggregator
date: 2024-08-31
fetch_date: 2025-10-06T18:07:58.422518
---

# [s|l]trace - Linux Malware Analysis

[Home](https://dfir.ch/)
[ ]

Menu

* [Home](/)
* [Posts](/posts/)
* [Talks](/talks/)
* [Tweets](/tweets/)
* |

LIGHT

DARK

# [s|l]trace - Linux Malware Analysis

1 Feb 2024

**Table of Contents**

* [Introduction](#introduction)
* [strace all the things](#strace-all-the-things)
* [Conclusion](#conclusion)
* [ltrace FTW?](#ltrace-ftw)
* [Backdoor in Action](#backdoor-in-action)
  + [Sending back a ping](#sending-back-a-ping)

## Introduction

[Craig Rowland](https://www.linkedin.com/in/craighrowland/), Founder and CEO of [Sandfly Security](https://sandflysecurity.com/), delivered a presentation titled *Evasive Linux Malware* at the Oslo Cold Incident Response Conference last year (Slides [here](https://sandflysecurity.com/sharing/evasive-linux-backdoors-cold-incident-response-conference-2023.pdf), Presentation [here](https://sandflysecurity.com/blog/evasive-linux-malware-detection-video-presentation-bpfdoor/)), dissecting the notorious [BPFDoor](https://malpedia.caad.fkie.fraunhofer.de/details/elf.bpfdoor) malware. In this post, we will analyze the BPFDoor backdoor only with the Linux utility *strace*, trying to get as much information as possible about the malware by tracing the executed syscalls from the binary. Swift assessments of malware samples like these can prove particularly beneficial for Incident Response teams in identifying Indicators of Compromise (IOC) for creating detection mechanisms or hunting purposes.

![foo](/images/BPFDoor/malpedia.png "foo")

Figure 1: malpedia - elf.bpfdoor

I have assembled [an archive](/files/BPFDoor/strace.zip) containing the source code, the compiled binary, and the strace logs for your reference (password: infected). To begin, I will download the source code of BPFDoor from Pastebin, update the repositories, install gcc, compile the binary, and then set the executable flag on the compiled binary.

```
wget https://pastebin.com/raw/kmmJuuQP
apt update
apt install gcc
mv kmmJuuQP kmmJuuQP.c
gcc -o BPFDoor kmmJuuQP.c
chmod +x BPFDoor
```

## strace all the things

In the subsequent sections, we will utilize the output generated by *strace*. Following an excerpt from the strace [man page](https://man7.org/linux/man-pages/man1/strace.1.html):

*In the simplest case strace runs the specified command until it exits. It intercepts and records the system calls which are called by a process and the signals which are received by a process. The name of each system call, its arguments and its return value are printed on standard error or to the file specified with the -o option.*

We track the execution flow of BPFDoor with strace, using the -o option to record the output into distinct log files (a new log file will be created for each process, identifiable by the ProcessID or PID for short). The -ff option instructs strace to trace the child processes spawned by the binary, which will be useful in later stages, given that the binary undergoes multiple forks. The initial command for the analysis is as follows:

```
# strace -o log -ff ./BPFDoor
```

PID 6014 represents the initial process on my server (started with the command above). In the first line of the strace output, we observe the malware’s execution through the [execve](https://man7.org/linux/man-pages/man2/execve.2.html) system call (the output is significantly condensed - please download the archive linked above to view the complete trace). Subsequently, the sample verifies the existence of the file */var/run/haldrund.pid*. If the file exists, the sample terminates, indicating that the host is already infected, a fact corroborated by various other companies and researchers (see the link above to Malpedia, listing different articles about BPFDoor).

```
$ cat log.6014
execve("./BPFDoor", ["./BPFDoor"], 0x7ffde853bbb8 /* 12 vars */) = 0
access("/var/run/haldrund.pid", R_OK)   = -1 ENOENT (No such file or directory)
clone(child_stack=0x7f98927beff0, flags=CLONE_VM|CLONE_VFORK|SIGCHLD) = 6015
access("/var/run/haldrund.pid", R_OK)   = 0
```

In the listing above, we see the [clone](https://man7.org/linux/man-pages/man2/clone.2.html) system call with a return value of 6015, representing the new process ID. Additionally, strace has generated a new log file for this specific process. In PID 6015, another execve syscall was invoked, passing the arguments */bin/rm -f /dev/shm/kdmtmpflush* to */bin/sh*.

```
$ cat log.6015
execve("/bin/sh", ["sh", "-c", "/bin/rm -f /dev/shm/kdmtmpflush;"...], 0x7ffc19e51608 /* 12 vars */) = 0
```

In PID 6016, the file */dev/shm/kdmtmpflush* is deleted (see above).

```
$ cat log.6016
execve("/bin/rm", ["/bin/rm", "-f", "/dev/shm/kdmtmpflush"], 0x558e3e816888 /* 12 vars */) = 0
```

Following the cleanup, the sample copies itself to the location */dev/shm/kdmtmpflush*, the same location previously cleared. We will proceed with the analysis outlined by Craig, documented [here](https://sandflysecurity.com/blog/bpfdoor-an-evasive-linux-backdoor-technical-analysis/) on the SandFly Security blog, aiming to correlate the evidence from the strace log(s) with the analysis results provided in the blog.

> 1. Copy binary to the /dev/shm directory (Linux ramdisk).
> 2. Rename and run itself as /dev/shm/kdmtmpflush.

Here is the relevant evidence from PID 6017 - Copy (Step 1) and Rename (Step 2):

```
$ cat log.6017
execve("/bin/cp", ["/bin/cp", "./BPFDoor", "/dev/shm/kdmtmpflush"], 0x558e3e816890 /* 12 vars */) = 0
```

Not explicitly highlighted by Craig, but permissions are adjusted to facilitate the execution of the newly copied binary (PID 6018).

```
$ cat log.6018
execve("/bin/chmod", ["/bin/chmod", "755", "/dev/shm/kdmtmpflush"], 0x558e3e816890 /* 12 vars */) = 0
fchmodat(AT_FDCWD, "/dev/shm/kdmtmpflush", 0755) = 0
```

The copying mechanism itself is quite interesting from a Linux internals perspective (PID 6017), demonstrating various system calls in action:

```
$ cat log.6017
stat("/dev/shm/kdmtmpflush", 0x7ffd7e118030) = -1 ENOENT (No such file or directory)
newfstatat(AT_FDCWD, "./BPFDoor", {st_mode=S_IFREG|0755, st_size=32608, ...}, 0) = 0
newfstatat(AT_FDCWD, "/dev/shm/kdmtmpflush", 0x7ffd7e117dc0, 0) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "./BPFDoor", O_RDONLY) = 3
fstat(3, {st_mode=S_IFREG|0755, st_size=32608, ...}) = 0
openat(AT_FDCWD, "/dev/shm/kdmtmpflush", O_WRONLY|O_CREAT|O_EXCL, 0755) = 4
fstat(4, {st_mode=S_IFREG|0755, st_size=0, ...}) = 0
fadvise64(3, 0, 0, POSIX_FADV_SEQUENTIAL) = 0
mmap(NULL, 139264, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f8de68c0000
read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\220#\0\0\0\0\0\0"..., 131072) = 32608
write(4, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\220#\0\0\0\0\0\0"..., 32608) = 32608
read(3, "", 131072)                     = 0
close(4)                                = 0
close(3)                                = 0
```

> 3. Fork itself and run fork with “–init” flag which tells itself to execute secondary clean-up operations and go resident.

```
$ cat log.6019
execve("/dev/shm/kdmtmpflush", ["/dev/shm/kdmtmpflush", "--init"], 0x558e3e816868 /* 12 vars */) = 0
```

> 4. The forked version timestomps the binary file /dev/shm/kdmtmpflush and initiates packet capture loop.

Timestomping is done with the *utime()* system call: *The utime() system call changes the access and modification times of the inode specified by filename to the actime and modtime fields of times respectively.* [[1]](https://man7.org/linux/man-pages/man2/utime.2.html)

The function takes two parameters, *const char \*filename* and *const struct timeval times*. The timeeval struct is defined as follows:

```
struct timeval {
    long tv_sec;        /* seconds */
    long tv_usec;       /* microseconds */
};
```

Examining our strace output, we observe the first parameter to utimes as the filename (/dev/shm/kdmtmpflush), and the second parameter as the timeeval struct containing seconds and microseconds. This action results in timestomping the binary to the val...