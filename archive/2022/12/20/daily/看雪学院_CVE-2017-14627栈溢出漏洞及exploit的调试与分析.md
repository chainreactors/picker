---
title: CVE-2017-14627栈溢出漏洞及exploit的调试与分析
url: https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458488972&idx=1&sn=de0687bfa9fd03296e051372c3f38b65&chksm=b18ea00686f9291034706473da2cd2e85759dcedca31e322d4925ee5064a8a795b67d6acf2a1&scene=58&subscene=0#rd
source: 看雪学院
date: 2022-12-20
fetch_date: 2025-10-04T01:59:55.648529
---

# CVE-2017-14627栈溢出漏洞及exploit的调试与分析

![cover_image](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8FJVH3PGSiaY563SLhIPrI0tLDIvgmaEBhRwdEx7UmrE21FR5fc4iaqy3pJwsgQE4h3kt8Nv0Ehfdgw/0?wx_fmt=jpeg)

# CVE-2017-14627栈溢出漏洞及exploit的调试与分析

DriverUnload

看雪学苑

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8FJVH3PGSiaY563SLhIPrI0t7U4iat9p57eJV6BE54IGCFZ67h1GMSxA92hPep6txd05atWpGKj7cnA/640?wx_fmt=jpeg)

本文为看雪论坛优秀文章

看雪论坛作者ID：DriverUnload

> 纸上得来终觉浅,绝知此事要躬行  --陆游

##

```
一

前言
```

最近《漏洞战争》快看完了，也跟着书把漏洞分析了一遍。虽然也有自己的思考，但绝大部分都是复刻书中的操作。以我浅薄的知识，甚至有的时候无法理解某些操作，只好先跟着做，等快分析结束时才能恍然大悟。在分析书中下一个漏洞时，总是有种无从下手的感觉。所以就想着自主分析一下漏洞，顺便沉淀一下所学知识。

```
二

漏洞描述
```

CyberLink LabelPrint是一套快速简易的光盘卷标制作软件，支持最新lightscribe光盘封面刻录技术。 CyberLink LabelPrint 2.5中基于堆栈的缓冲区溢出允许远程攻击者通过lpp项目文件中的（1）author（INFORMATION标签内）、（2）name（INFORMATION标签内），（3）artist（TRACK标签内）或（4）default（TEXT标签内）参数执行任意代码。

```
三

漏洞分析
```

1、分析环境

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8FJVH3PGSiaY563SLhIPrI0tCt9HSo6dwZLkwBVEia8d0p6PR1aGVGL93T7DwrHE4iaApd2Ie9WLK21g/640?wx_fmt=png)

2、生成exploit

此漏洞的利用代码在Metasploit有集成，我们以一个弹计算器的形式生成一个exploit：
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HJugwvXjwy68ibYyuvFBz9qicrGEtGI0eMvShQCDbf0iaOuxV3ZZ2fLtuK0d2OUKP7tyEM1kYC44qxw/640?wx_fmt=png)
生成的exploit我们打开后，根据漏洞描述可以确定是name属性造成的堆溢出：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HJugwvXjwy68ibYyuvFBz9qzAd1ib2m5LuOpWzGtcFMQUp3nb2mjDW03scWUGeGlpSJgJ3ibIxViczdQ/640?wx_fmt=png)

我们打开exploit可以看到calc成功弹出，接下里就是分析漏洞成因了。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HJugwvXjwy68ibYyuvFBz9qHCUIlg2EgsDiaxlSUahELRO1EB8hiaQhZyFWLR1Jat3rYdAkhvRDHMGg/640?wx_fmt=png)

## 3、定位漏洞函数

首先我们运行LabelPrint，然后打开windbg，并用windbg附加LabelPrint.exe运行，并打开msf.lpp，打开后触发异常：

```
(f44.968): Access violation - code c0000005 (first chance)First chance exceptions are reported before any exception handling.This exception may be expected and handled.eax=07220042 ebx=01571fb0 ecx=00130000 edx=0722807c esi=01571ae8 edi=00000000eip=7c37042b esp=0012e16c ebp=0012eee4 iopl=0         nv up ei pl nz na pe nccs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010206*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\Program Files\CyberLink\LabelPrint\MSVCR71.dll -MSVCR71!wcscpy+0xb:7c37042b 668901          mov     word ptr [ecx],ax        ds:0023:00130000=63410:000> !address  00130000  Failed to map Heaps (error 80004005)Usage:                  MemoryMappedFileAllocation Base:        00130000Base Address:           00130000End Address:            00134000Region Size:            00004000Type:                   00040000    MEM_MAPPEDState:                  00001000    MEM_COMMITProtect:                00000002    PAGE_READONLYMapped file name:       PageFile
```

可以看到这是调用MSVCR71!wcscpy的时候，由于循环复制内存数据到栈空间时，未能检测复制的内存大小，导致覆盖到00130000这个只读内存空间，最后造成异常。同时我们再看看栈发生什么变化：

```
0:000> kbChildEBP RetAddr  Args to Child             WARNING: Stack unwind information not available. Following frames may be wrong.0012eee4 0001001b 002d0042 00010001 00500042 MSVCR71!wcscpy+0xb0012eee8 002d0042 00010001 00500042 005c0042 0x1001b0012eeec 00010001 00500042 005c0042 00250042 0x2d00420012eef0 00500042 005c0042 00250042 007e007e 0x100010012eef4 005c0042 00250042 007e007e 00250042 0x5000420012eef8 00250042 007e007e 00250042 00010001 0x5c00420012eefc 007e007e 00250042 00010001 00350042 0x2500420012ef00 00250042 00010001 00350042 007f007f 0x7e007e0012ef04 00010001 00350042 007f007f 00050042 0x2500420012ef08 00350042 007f007f 00050042 00440044 0x100010012ef0c 007f007f 00050042 00440044 00570042 0x3500420012ef10 00050042 00440044 00570042 00500042 0x7f007f*** ERROR: Module load completed but symbols could not be loaded for C:\Program Files\CyberLink\LabelPrint\LabelPrint.exe0012ef14 00440044 00570042 00500042 00420042 0x500420012ef18 00570042 00500042 00420042 00420042 LabelPrint+0x400440012ef1c 00500042 00420042 00420042 00420042 0x5700420012ef20 00420042 00420042 00420042 00420042 0x5000420012ef24 00420042 00420042 00420042 00420042 LabelPrint+0x200420012ef28 00420042 00420042 00420042 00420042 LabelPrint+0x200420012ef2c 00420042 00420042 00420042 00420042 LabelPrint+0x200420012ef30 00420042 00420042 00420042 00420042 LabelPrint+0x200420012ef34 00420042 00420042 00420042 00420042 LabelPrint+0x200420012ef38 00420042 00420042 00420042 00420042 LabelPrint+0x200420012ef3c 00420042 00420042 00420042 00420042 LabelPrint+0x200420012ef40 00420042 00420042 00420042 00420042 LabelPrint+0x200420012ef44 00420042 00420042 00420042 00420042 LabelPrint+0x200420012ef48 00420042 00420042 00420042 00420042 LabelPrint+0x200420012ef4c 00420042 00420042 00420042 00420042 LabelPrint+0x200420012ef50 00420042 00420042 00420042 00420042 LabelPrint+0x200420012ef54 00420042 00420042 00420042 00420042 LabelPrint+0x200420012ef58 00420042 00420042 00420042 00420042 LabelPrint+0x20042........
```

可以看到栈已经被破坏了，反汇编MSVCR71!wcscpy：

```
0:000> u MSVCR71!wcscpyMSVCR71!wcscpy:7c370420 8b4c2404        mov     ecx,dword ptr [esp+4]7c370424 8b542408        mov     edx,dword ptr [esp+8]7c370428 668b02          mov     ax,word ptr [edx]7c37042b 668901          mov     word ptr [ecx],ax7c37042e 41              inc     ecx7c37042f 41              inc     ecx7c370430 42              inc     edx7c370431 42              inc     edx0:000> uMSVCR71!wcscpy+0x12:7c370432 6685c0          test    ax,ax7c370435 75f1            jne     MSVCR71!wcscpy+0x8 (7c370428)7c370437 8b442404        mov     eax,dword ptr [esp+4]7c37043b c3              ret
```

可以看到wcscpy没有自己的栈帧，同时也没有任何改变栈的操作，所以栈顶一定存放着返回地址。

```
0:000> dd esp0012e16c  004657c8 0012e8a8 07226924 75c13e590012e17c  01cba6c0 00120008 75c14677 0721f3dc0012e18c  002962e0 0012eed4 0048b218 000000000012e19c  00410c26 01571ae8 0012e8a8 0012f3600012e1ac  01571fb0 00000000 00369008 01cba4900012e1bc  01cba4ac 01cbabd0 0726eda0 0012e2340012e1cc  01cba458 00000000 00000000 01cba3c80012e1dc  05c755dc 760dc744 0012e204 75db3a0c0:000> ub 004657c8LabelPrint+0x657b4:004657b4 7404            je      LabelPrint+0x657ba (004657ba)004657b6 8b06            mov     eax,dword ptr [esi]004657b8 eb02            jmp     LabelPrint+0x657bc (004657bc)004657ba 33c0            xor     eax,eax004657bc 8b4c242c        mov     ecx,dword ptr [esp+2Ch]004657c0 50              push    eax004657c1 51              push    ecx004657c2 ff150cf14800    call    dword ptr [LabelPrint+0x8f10c (0048f10c)]0:000> dd 0048f10c0048f10c  7c370420 7c378a5d 7c379aca 7c3639fc0048f11c  7c372806 7c38ab8d 7c38b668 7c3901c40048f12c  7c370223 7c36240d 7c37043c 7c3745a00048f13c  7c391173 7c3902cd 7c375867 7c391a3e0048f14c  7c390c31 7c39108f 7c37056a 7c3866550048f15c  7c3704ff 7c378ad2 7c378b03 7c378aeb0048f16c  7c3703f6 00000000 75c14642 75c13e590048f17c  75c13eae 75c36ba7 75c145d2 75c13ed50:000> u 7c370420MSVCR71!wcscpy:7c370420 8b4c2404        mov     ecx,dword ptr [esp+4]7c370424 8b542408        mov     edx,dword ptr [esp+8]7c370428 668b02          mov     ax,word ptr [edx]7c37042b 668901          mov     word ptr [ecx],ax7c37042e 41              inc     ecx7c37042f 41              inc     ecx7c370430 42              inc     edx7c370431 42              inc     edx
```

可以看到函数在004657c2这个地址调用wcscpy进行内存拷贝，我们将此函数暂且称为vulfunc。用IDA中打开此函数：

```
int __thiscall vulfunc(_DWORD **this, _DWORD *a2, wchar_t *Destination){.....   v10 = 0;  VariantInit(&pvarg);  v4 = *this[2];  v9 = this[2];  v12 = 0;  if ( (*(int (__stdcall **)(_DWORD *, _DWORD *, int *))(v4 + 28))(v9, a2, &v10) >= 0 && v10 )  {    (*(void (__stdcall **)(int, VARIANTARG *))(*(_DWORD *)v10 + 32))(v10, &pvarg);    if ( pvarg.vt == 8 )    {      sub_4652C0(&pvarg);      v5 = a2 ? (const wchar_t *)*a2 : 0;      wcscpy(Destination, v5);  //这里拷贝造成了异常      if ( a2 )        sub_40D110(a2);    }    VariantClear(&pvarg);    (*(void (__stdcall **)(int))(*(_DWORD *)v10 + 8))(v10);    v12 = -1;    v6 = VariantClear(&pvarg);    if ( v6 < 0 )      sub_483340(v6);    return 0;  }    .....
```

## 4、确定函数执行流程

现在我们确定了漏洞函数，重新附加在vulfunc函数头下断：

```
(a34.5ac): Break instruction exception - code 80000003 (first chance)eax...