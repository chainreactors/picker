---
title: My `Blind Date` with CVE-2025-29824
url: https://starlabs.sg/blog/2025/07-my-blind-date-with-cve-2025-29824/
source: Blogs on STAR Labs
date: 2025-07-17
fetch_date: 2025-10-06T23:29:06.537335
---

# My `Blind Date` with CVE-2025-29824

[![logo](https://starlabs.sg/logo-white.png)](https://starlabs.sg/ "  (Alt + H)")

* [Home](https://starlabs.sg/ "Home")
* [About](https://starlabs.sg/about/ "About")
* [Advisories](https://starlabs.sg/advisories/ "Advisories")
* [Blog](https://starlabs.sg/blog/ "Blog")
* [Achievements](https://starlabs.sg/achievements/ "Achievements")
* [Publications](https://starlabs.sg/publications/ "Publications")
* [Search](https://starlabs.sg/search/ "Search (Alt + /)")

[Home](https://starlabs.sg/) » [Blogs](https://starlabs.sg/blog/)

# My `Blind Date` with CVE-2025-29824

July 16, 2025 · 10 min · Ong How Chong

Table of Contents

* [TL;DR](#tldr)
* [Technical Deep Dive Into The Vulnerability](#technical-deep-dive-into-the-vulnerability)
* [Summary:](#summary)
* [CVSSv3.1 Scoring System:](#cvssv31-scoring-system)
* [How Microsoft Fixed the Bug](#how-microsoft-fixed-the-bug)
  + [Patch Analysis - Before vs. After](#patch-analysis---before-vs-after)
    - [CClfsRequest::Cleanup() Implementation](#cclfsrequestcleanup-implementation)
    - [CClfsLogCcb::Cleanup() Changes](#cclfslogccbcleanup-changes)
    - [CClfsRequest::Close() Changes](#cclfsrequestclose-changes)
  + [Cleanup VS Close](#cleanup-vs-close)
  + [FsContext2 Structure Deep-Dive](#fscontext2-structure-deep-dive)
* [How to Trigger the Bug](#how-to-trigger-the-bug)
  + [Triggering the Vulnerability](#triggering-the-vulnerability)
  + [Finding the Right Functions](#finding-the-right-functions)
  + [Vulnerable Functions Found](#vulnerable-functions-found)
  + [Attack Vectors](#attack-vectors)
  + [Step-by-Step Exploitation](#step-by-step-exploitation)
* [Proof-of-Concept](#proof-of-concept)
  + [Crash Context](#crash-context)
  + [Variant Analysis](#variant-analysis)
* [Enhanced Detection Strategies](#enhanced-detection-strategies)
* [Suggested Mitigations](#suggested-mitigations)
* [References:](#references)

In April 2025, Microsoft patched a vulnerability that had become a key component in sophisticated ransomware attack chains. `CVE-2025-29824`, an use-after-free bug in the Windows Common Log File System (CLFS) driver, wasn’t the initial entry point for attackers. Instead, [threat actors first compromised Cisco ASA firewalls](https://www.security.com/threat-intelligence/play-ransomware-zero-day), then used this Windows kernel vulnerability as the crucial privilege escalation step that transformed limited network access into complete system domination. This multi-stage approach represents the evolution of modern ransomware operations: sophisticated threat actors chaining together network infrastructure vulnerabilities with Windows kernel bugs to devastating effect.

## TL;DR[#](#tldr)

So my mentor dropped this assignment on me: “CVE-2025-29824 was used in-the-wild to pwn Windows machines - figure out how they did it. Oh, and there are no public samples, so you’re going in blind. Good luck!” 😅

Turns out, it’s a use-after-free vulnerability in the Windows Common Log File System (CLFS) driver. When a log file handle is closed, the `FsContext2` structure is incorrectly freed in `CClfsRequest::Cleanup()`, while another IRP request can still be in progress. The attackers chained this with a Cisco ASA exploit.

**The challenge:** Reverse engineer how this actually works, understand why Microsoft’s reference counting went sideways, and build a working PoC from scratch.

**Spoiler alert:** it involves a lot more assembly diving and crash dump analysis than I initially signed up for! 🔍💥

## Technical Deep Dive Into The Vulnerability[#](#technical-deep-dive-into-the-vulnerability)

## Summary:[#](#summary)

| **Product** | Microsoft Windows |
| --- | --- |
| **Vendor** | Microsoft |
| **Severity** | High |
| **Affected Versions** | Windows 10-11, Windows Server 2008-2025 |
| **Tested Versions** | Windows 11 23H2 |
| **Impact** | Elevation of Privilege |
| **CVE ID** | CVE-2025-29824 |
| **CWE** | CWE-416: Use After Free |
| **PoC available?** | Yes |
| **Patch available?** | Yes |
| **Exploit available?** | No |

## CVSSv3.1 Scoring System:[#](#cvssv31-scoring-system)

**Base Score:** 7.8 (HIGH)
**Vector String:** `CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H`

| **Metric** | **Value** |
| --- | --- |
| **Attack Vector (AV)** | Local |
| **Attack Complexity (AC)** | Low |
| **Privileges Required (PR)** | Low |
| **User Interaction (UI)** | None |
| **Scope (S)** | Unchanged |
| **Confidentiality Impact (C)** | High |
| **Integrity Impact (I)** | High |
| **Availability Impact (A)** | High |

## How Microsoft Fixed the Bug[#](#how-microsoft-fixed-the-bug)

### Patch Analysis - Before vs. After[#](#patch-analysis---before-vs-after)

To analyze the vulnerability fix, we compared two versions of `clfs.sys`:

**Before the patch:**

* Version: `10.0.22621.5097`
* SHA256: `3FB7DA92269380F7BC72A1AD1B06D9BF1CB967AC3C5C7010504C841FCCC6108E`

**After the patch:**

* Version: `10.0.22621.5192`
* SHA256: `969AC3B22CA9A22D73E8CC0BC98D9CF8A969B7867FAF2EE1093B0B0695D3439F`

The security fixes are implemented within the `CClfsLogCcb::Cleanup()` and `CClfsRequest::Close()` functions.

#### CClfsRequest::Cleanup() Implementation[#](#cclfsrequestcleanup-implementation)

The cleanup process follows this sequence:

```
CClfsRequest::Cleanup(PIRP Irp){
    ...
    CClfsLogCcb::AddRef(FsContext2);
    CClfsLogCcb::Cleanup(FsContext2);
    CClfsLogCcb::Release(FsContext2);
    ...
}
```

`CClfsLogCcb::AddRef()` performs atomic increment operations on the `FsContext2` reference counter:

```
CClfsLogCcb::AddRef(FsContext2){
    return _InterlockedIncrement(FsContext2->reference_count);
}
```

`CClfsLogCcb::Release()` atomically decrements the `FsContext2` reference counter and triggers cleanup when the count reaches zero, invoking the destructor `CClfsLogCcb::~CClfsLogCcb()` for proper resource deallocation.

```
CClfsLogCcb::Release(FsContext2){
    refcount = _InterlockedDecrement(&FsContext2->reference_count);
    if ( !refcount && FsContext2 ){
        CClfsLogCcb::~CClfsLogCcb(FsContext2);
        ...
    }
    return refcount;
}
```

#### CClfsLogCcb::Cleanup() Changes[#](#cclfslogccbcleanup-changes)

Pre-patch implementation:

```
CClfsLogCcb::Cleanup(FsContext2)
{
    ...
    CClfsLogCcb::Release(FsContext2);
}
```

Post-patch implementation:

```
CClfsLogCcb::Cleanup(FsContext2)
{
    ...
    if(!PatchFlag()){
        CClfsLogCcb::Release(FsContext2);
    }
}
```

This patch makes it such that `CClfsLogCcb::Cleanup()` no longer calls `CClfsLogCcb::Release(FsContext2)`. This has instead been moved into `CClfsRequest::Close()`.

#### CClfsRequest::Close() Changes[#](#cclfsrequestclose-changes)

Pre-patch implementation:

```
CClfsRequest::Close(PIRP Irp){
    CClfsLogFcbCommon *ReservedContext;
    ...
    boolean = ExAcquireResourceExclusiveLite(&ReservedContext->m_resLockFcb, 1u);
    CClfsLogFcbCommon::Close(ReservedContext);
    if (boolean){
        ExReleaseResourceForThreadLite(&ReservedContext->m_resLockFcb, (ERESOURCE_THREAD)KeGetCurrentThread());
    }
    ...
    return 0;
}
```

Post-patch implementation:

```
CClfsRequest::Close(PIRP Irp){
    CClfsLogFcbCommon *ReservedContext;
    ...
    FileObject = CurrentStackLocation->FileObject;
    if (PatchFlag()){
        FsContext2 = (CClfsLogCcb *)CurrentStackLocation->FileObject->FsContext2;
        v10 = FsContext2;    //save FsContext2
        if (FsContext2){
            CClfsLogCcb::AddRef(FsContext2);    //increment reference count to FsContext2
            CClfsLogCcb::Close(FsContext2);    //decrement reference count to FsContext2
        }
    }
    ...
    boolean = ExAcquireResourceExclusiveLite(&ReservedContext->m_resLockFcb, 1u);
    CClfsLogFcbCommon::Close(ReservedContext);
    if (boolean){
        ExReleaseResourceForThreadLite(&ReservedContext->m_resLockFcb, (ERESOURCE_THREAD)KeGetCurrentThread());
        FsContext2 = v10;    //load FsContext2
    }
    ...
    if (PatchFlag()){
        FileObject->FsContext = 0;
        FileObject->FsContext2 = 0;
...