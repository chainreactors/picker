---
title: 主机提权 | 浅析sudo堆缓冲区溢出漏洞CVE-2021-3156
url: https://mp.weixin.qq.com/s?__biz=Mzg5MTc3ODY4Mw==&mid=2247496852&idx=1&sn=84850e657a6a4b987a6989f1917b95e5&chksm=cfca9780f8bd1e969cde4f57453d79f7bc3f1abe5d1fadecb8d905d2e58b5ee86964cdb06299&scene=58&subscene=0#rd
source: 微步在线研究响应中心
date: 2022-10-27
fetch_date: 2025-10-03T21:01:15.281670
---

# 主机提权 | 浅析sudo堆缓冲区溢出漏洞CVE-2021-3156

![cover_image](https://mmbiz.qpic.cn/mmbiz_jpg/fFyp1gWjicMI1OibyfUFGXcg2icRYIicv6h8gibRKdpCcnth9dHe4DT4nrQcwIamtvYH9Uibv0uLrg85UJGYHibwoHkbA/0?wx_fmt=jpeg)

# 主机提权 | 浅析sudo堆缓冲区溢出漏洞CVE-2021-3156

原创

m1k0

微步在线研究响应中心

![](https://mmbiz.qpic.cn/mmbiz_jpg/fFyp1gWjicMJasbTOEml0jviatLrkYy1A6NxWSic8LyMWIV3XiaIwhuEfBBeU85PnFkDpcfdWgSGrMXmLlRrTbqJIg/640?wx_fmt=jpeg)

1

**概述**

**1.1漏洞介绍**

2021年1月26日，sudo发布安全通告，修复了一个类Unix操作系统在命令参数中转义反斜杠时存在基于堆的缓冲区溢出漏洞。当sudo通过-s或-i命令行选项在shell模式下运行命令时，它将在命令参数中使用反斜杠转义特殊字符。但使用-s或-i标志运行sudoedit时，实际上并未进行转义，从而可能导致缓冲区溢出。只要存在sudoers文件（通常是 /etc/sudoers），攻击者就可以使用本地普通用户利用sudo造成内核崩溃，甚至获得系统root权限。

 ![](https://mmbiz.qpic.cn/mmbiz_png/fFyp1gWjicMI1OibyfUFGXcg2icRYIicv6h8w2ynFtSxZZACPNlB6ofMhSMWAtr1j3hC7kS3qzPOzhGOCxOL7jnwYg/640?wx_fmt=png)

## **1.2 漏洞影响版本**

```
Sudo 1.8.2 - 1.8.31p2Sudo 1.9.0 - 1.9.5p1
```

**1.3 漏洞自查及修补建议**

我们可以在终端中输入sudo -V查看sudo版本如下图所示：

![](https://mmbiz.qpic.cn/mmbiz_png/fFyp1gWjicMI1OibyfUFGXcg2icRYIicv6h8PicRFthoop5JNAc5ZODIFowqZx2d1Br43VELoIicYGjFyBtWVdV59x6Q/640?wx_fmt=png)![](https://mmbiz.qpic.cn/mmbiz_png/fFyp1gWjicMI1OibyfUFGXcg2icRYIicv6h8L8rfkAOvqaJLnXXdL2Ou6KzncdscSQYydCpbH3yX5OqVtRvPiciaCRSQ/640?wx_fmt=png)

判断本地sudo版本是否存在该漏洞，我们可以输入“sudoedit -s /”来手动测试，如下图：

![](https://mmbiz.qpic.cn/mmbiz_png/fFyp1gWjicMI1OibyfUFGXcg2icRYIicv6h8uErGibLsaKDdUWWtdCk90fk7dtFJ0Wtjk6ytaibWefm6IBV3d3lVFyibQ/640?wx_fmt=png)

执行命令后回显为sudoedit的用法则说明该sudo版本漏洞已经被修补，而存在漏洞的sudo会回显“sudoedit:/:not a regular file”如下图：

![](https://mmbiz.qpic.cn/mmbiz_png/fFyp1gWjicMI1OibyfUFGXcg2icRYIicv6h8ibp5fib5Xfpe5BicDBYYNKN3QXyYBP4cqLVmjTRN8x81YiaBpicvZLtacmA/640?wx_fmt=png)

针对该漏洞的修补，只需要及时更新sudo即可：

```
sudo apt update sudo // Debian / Ubuntusudo yum -y update sudo // CentOS
```

2

**漏洞分析**

## **2.1 漏洞成因**

漏洞发生的根本原因在于sudo错误地将参数中的反斜杠“/”进行了转义。在通常情况下，通过shell（sudo -i或sudo
-s）执行命令时，sudo会转义特殊字符，然而“-s”或“-i”也可能被用来运行sudoedit，在这种情况下，实际上特殊字符没有被转义，这就可能导致缓冲区溢出。

此漏洞的关键POC如下：

![](https://mmbiz.qpic.cn/mmbiz_png/fFyp1gWjicMI1OibyfUFGXcg2icRYIicv6h8ibyE3wvGaalSDjOSib2uPPOxw2icJMkQoBLUrBqGbVcOoTDb7fmclUaVA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/mmbiz_png/fFyp1gWjicMI1OibyfUFGXcg2icRYIicv6h8CYvm5iarV3H5ia4mMJ3BGQibymZCk78UdqRj3JicfnbViahynDibCDrYKDjg/640?wx_fmt=png)

由上图可知，当我们直接执行图中的命令时，回显的信息提示这是一个内存错误，这就说明sudo没有正确的处理好反斜杠，调用python生成的80个垃圾字符“A”并没有被正确转义导致缓冲区溢出。

随后我们可以深入到sudo源码中查看为何上图的一条命令可以造成缓冲区溢出，从而导致内核崩溃甚至达到提权的目的。

在sudo.c的main函数中，程序会调用parse\_args函数来处理传入的参数，其中有一段处理转义字符的代码片段如下：

```
int parse_args(int argc, char **argv, int *nargc, char ***nargv,struct sudo_settings **settingsp, char ***env_addp){......// 条件，当flags设置为MODE_SHELL或MODE_LOGIN_SHELL，且mode设置为MODE_RUN时if (ISSET(flags, MODE_SHELL|MODE_LOGIN_SHELL)&& ISSET(mode, MODE_RUN)) {//开始构造"shell -c <command>"char **av, *cmnd = NULL;int ac = 1;if (argc != 0) {   /* shell -c"command" */   char *src, *dst;   size_t size = 0;   for (av = argv; *av != NULL; av++)size += strlen(*av) + 1;   if (size == 0 || (cmnd = reallocarray(NULL, size, 2)) ==NULL)sudo_fatalx(U_("%s: %s"), __func__, U_("unableto allocate memory"));   if (!gc_add(GC_PTR, cmnd))exit(1);// 开始处理传入的参数   for (dst = cmnd, av = argv; *av != NULL; av++) {for (src = *av; *src != '\0'; src++) {    /*quote potential meta characters */// 将字符转义，如果存在 "_" "-" "$" 就在 command前面加上转义符"\"    if (!isalnum((unsigned char)*src)&& *src != '_' && *src != '-' && *src != '$')*dst++ = '\\';    *dst++ = *src;}*dst++ = ' ';   }   if (cmnd != dst)dst--;  /*replace last space with a NUL */   *dst = '\0';   ac += 2; /* -c cmnd */}......}
```

上图中可以看到参数的处理方式为：当flags设置为MODE\_SHELL或MODE\_LOGIN\_SHELL，且mode设置为MODE\_RUN时，控制流会进入条件判断的代码中，构造shell -c <command>指令，并在其中处理<command>中的一些转义字符，在这些字符前添加反斜杠。

而当执行sudo命令时设置了-s或-i参数，parse\_arg函数将会同时设置MODE\_RUN和MODE\_SHELL标志：

```
int parse_args(int argc, char **argv, int *nargc, char***nargv, struct sudo_settings **settingsp, char ***env_addp) {······ /*First, check to see if we were invoked as "sudoedit". */ proglen = strlen(progname); if (proglen > 4 &&strcmp(progname + proglen - 4, "edit") == 0) { progname = "sudoedit"; mode = MODE_EDIT; sudo_settings[ARG_SUDOEDIT].value = "true"; } ······ case 'i': sudo_settings[ARG_LOGIN_SHELL].value = "true"; // 设置MODE_LOGIN_SHELLSET(flags, MODE_LOGIN_SHELL); break;······case 's': sudo_settings[ARG_USER_SHELL].value = "true"; // 设置 flags为MODE_SHELLSET(flags, MODE_SHELL); break; ······    if (!mode){/* Defer -k mode setting until we know whether it is a flag ornot */if(sudo_settings[ARG_IGNORE_TICKET].value != NULL){if (argc == 0&& !(flags & (MODE_SHELL | MODE_LOGIN_SHELL))){         mode = MODE_INVALIDATE; /* -k by itself */sudo_settings[ARG_IGNORE_TICKET].value = NULL;valid_flags = 0;}}// 未设置mode时默认为MODE_RUNif (!mode)mode = MODE_RUN; /* running a command */}//...//若标志位为MODE_LOGIN_SHELLif (ISSET(flags, MODE_LOGIN_SHELL)){......// 同时设置 MODE_SHELLSET(flags, MODE_SHELL);}//...}
```

**阶段性结论：**

经过目前的分析我们可以得知，parse\_arg函数会首先检测命令长度，如果长度progname大于4且后面的字母是“edit”，则说明调用的命令为sudoedit。随后程序开始构造shell -c <command>指令，在构造的过程中若<command>中存在-s参数，程序会同时设置MODE\_RUN和MODE\_SHELL标志，最终进入处理转义字符的代码片段。

下面我们进一步追踪程序流，程序会进入policy\_check函数，由于该函数中使用了虚表，无法静态分析后续调用，因此使用GDB动态调试进行跟踪，在调用GDB后使用以下语句引入sudoedit并设置参数：

```
file sudoedit //输入需要调试的文件set args -s '\' AAAAAAAA              //设置参数b policy_check //在policy_check处打断点
```

随后在GDB中输入r（run）执行到断点处，输入s（step）步入，根据调试发现程序流下一个调用的函数为sudoers\_policy\_check，如下图：

![](https://mmbiz.qpic.cn/mmbiz_png/fFyp1gWjicMI1OibyfUFGXcg2icRYIicv6h8y3Bw86ElT1UOv427L2IzEyPibGwmCEIAtOfGxpXXYZCGw70dgu5vwxA/640?wx_fmt=png)

随着动态调试发现的sudoers\_policy\_check函数，进一步进行源码跟踪：

```
sudoers_policy_check(int argc, char * const argv[], char*env_add[], char **command_infop[], char **argv_out[], char**user_env_out[]) {struct sudoers_exec_args exec_args; int ret; debug_decl(sudoers_policy_check,SUDOERS_DEBUG_PLUGIN) if (!ISSET(sudo_mode, MODE_EDIT)) SET(sudo_mode, MODE_RUN); exec_args.argv = argv_out; exec_args.envp = user_env_out; exec_args.info = command_infop; ret = sudoers_policy_main(argc, argv, 0, env_add,&exec_args); if (ret == true && sudo_version >= SUDO_API_MKVERSION(1, 3)) { /*Unset close function if we don't need it to avoid extra process. */ if (!def_log_input && !def_log_output&& !def_use_pty && !sudo_auth_needs_end_session()) sudoers_policy.close = NULL; } debug_return_int(ret); }
```

根据源码我们不难得出，程序流进入到了sudoers\_policy\_main方法中：

```
int sudoers_policy_main(int argc, char * const argv[],int pwflag, char *env_add[], void *closure) {··· ··· ··· ··· /** Make a local copy of argc/argv, withspecial handling* for pseudo-commands and the '-i' option.*/ if (argc == 0) { ··· ··· } else { /*Must leave an extra slot before NewArgv for bash's --login */ NewArgc = argc; NewArgv = reallocarray(NULL, NewArgc + 2, sizeof(char *)); ··· ··· } memcpy(++NewArgv, argv,argc * sizeof(char *)); NewArgv[NewArgc] = NULL; ··· ··· } } ··· ··· //<command>处理取消转义的方法cmnd_status = set_cmnd(); ··· ··· ··· ··· ··· ··· }
```

在sudoers\_policy\_main方法中，我们找到了用于处理command中取消转义的方法set\_cmnd，随后我们通过动态调试的方法查看sudo是如何处理我们传入的参数的，此时我们可以得到NewArg的结构如下图：

![](https://mmbiz.qpic.cn/mmbiz_png/fFyp1gWjicMI1OibyfUFGXcg2icRYIicv6h83zyZzZB5Z0PyNLfk7C2iab3czlmlNzaBdYxniambannfSIFJ4icQsIjcg/640?wx_fmt=png)

可见NewArg用于接收我们传入的参数，其中NewArgc指参数个数（3），NewArgv为一个数组，分别存放[sudoedit，’\\’,AAAAAAAA]，随后进入set\_cmnd函数中：

```
static int set_cmnd(void) {··· ··· ··· ··· /*set user_args */ if (NewArgc > 1) { char *to, *from,**av; size_t size,n; /* Alloc and build up user_args. */ //根据参数总长度计算size， 后续malloc 申请，没有问题 for (size = 0, av = NewArgv + 1; *av;av++) size += strlen(*av) + 1; if (size == 0 ||(user_args = malloc(size)) == NULL) { sudo_warnx(U_("%s: %s"),__func__, U_("unable to allocatememory")); debug_return_int(-1); } if (ISSET(sudo_mode,MODE_SHELL|MODE_LOGIN_SHELL)) { /** When running a command via a shell,the sudo front-end* escapes potential meta chars.  We unescape non-spaces* for sudoers matching and loggingpurposes.*/  //将所有参数拷贝到一起放到堆中，逻辑是遇到'\'加非空格类型字符则只拷贝非空格字符 //但这里\x00 并不算空格类型字符 //代码没有考虑参数如果只有一个'\'或以'\'结尾并且下两个字符后就是另一个字符串情况 for (to = user_args, av =NewArgv + 1; (from = *av);av++) { while ...