---
title: Mali-cious Intent: Exploiting GPU Vulnerabilities (CVE-2022-22706 / CVE-2021-39793)
url: https://starlabs.sg/blog/2025/12-mali-cious-intent-exploiting-gpu-vulnerabilities-cve-2022-22706/
source: Blogs on STAR Labs
date: 2025-02-03
fetch_date: 2025-10-06T20:35:20.342137
---

# Mali-cious Intent: Exploiting GPU Vulnerabilities (CVE-2022-22706 / CVE-2021-39793)

[![logo](https://starlabs.sg/logo-white.png)](https://starlabs.sg/ "  (Alt + H)")

* [Home](https://starlabs.sg/ "Home")
* [About](https://starlabs.sg/about/ "About")
* [Advisories](https://starlabs.sg/advisories/ "Advisories")
* [Blog](https://starlabs.sg/blog/ "Blog")
* [Achievements](https://starlabs.sg/achievements/ "Achievements")
* [Publications](https://starlabs.sg/publications/ "Publications")
* [Search](https://starlabs.sg/search/ "Search (Alt + /)")

[Home](https://starlabs.sg/) » [Blogs](https://starlabs.sg/blog/)

# Mali-cious Intent: Exploiting GPU Vulnerabilities (CVE-2022-22706 / CVE-2021-39793)

February 2, 2025 · 17 min · Ng Zhi Yang (@rainbowpigeon\_)

Table of Contents

* [Vulnerability Overview](#vulnerability-overview)
  + [Affected Products](#affected-products)
  + [CVSS3.1 Score](#cvss31-score)
  + [Termux](#termux)
  + [Root Cause Analysis](#root-cause-analysis)
  + [Triggering the bug](#triggering-the-bug)
  + [Exploitation Primitive](#exploitation-primitive)
  + [Attack Strategy: Root Reverse Shell](#attack-strategy-root-reverse-shell)
  + [Escalating to Root via `init` Hijacking](#escalating-to-root-via-init-hijacking)
  + [Overwriting Vendor Kernel Modules](#overwriting-vendor-kernel-modules)
  + [Loading Kernel Module](#loading-kernel-module)
  + [Bypassing SELinux and Obtaining a Root Reverse Shell](#bypassing-selinux-and-obtaining-a-root-reverse-shell)
  + [Exploit Execution: A Step-by-Step Breakdown](#exploit-execution-a-step-by-step-breakdown)
  + [Closing Thoughts](#closing-thoughts)
* [References](#references)

Imagine downloading a game from a third-party app store. You grant it seemingly innocuous permissions, but hidden within the app is a malicious exploit that allows attackers to steal your photos, eavesdrop on your conversations, or even take complete control of your device. This is the kind of threat posed by vulnerabilities like `CVE-2022-22706` and `CVE-2021-39793`, which we’ll be dissecting in this post. These vulnerabilities affect Mali GPUs, commonly found in many Android devices, and allow unprivileged apps to gain root access.

## Vulnerability Overview[#](#vulnerability-overview)

### Affected Products[#](#affected-products)

| Product | Mali GPU Kernel Driver |
| --- | --- |
| Vendor | ARM |
| Severity | High - A non-privileged user can get a write access to read-only memory pages. |
| Affected Versions | - Midgard GPU Kernel Driver: All versions from r26p0 - r31p0 - Bifrost GPU Kernel Driver: All versions from r0p0 - r35p0 - Valhall GPU Kernel Driver: All versions from r19p0 - r35p0 |
| Tested Versions | - Pixel 6, MP1.0, 2022 - **Downgraded** to Android 12.0.0 (`SD1A.210817.015.A4`, Oct 2021) - `Linux localhost 5.10.43-android12-9-00002-g4fb696975cdd-ab7658202 #1 SMP PREEMPT Thu Aug 19 00:59:56 UTC 2021 aarch64` |
| CWE | CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer |

### CVSS3.1 Score[#](#cvss31-score)

* **Base Score:** 7.8 (High)
* **Vector String:** [CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H](https://www.first.org/cvss/calculator/3.1#CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H)

### Termux[#](#termux)

This Termux output shows the context of the exploit, running from an unprivileged untrusted app context.

```
~ $ cat /proc/self/attr/current
u:r:untrusted_app_27:s0:c222,c256,c512,c768
~ $ id
uid=10222(u0_a222) gid=10222(u0_a222) groups=10222(u0_a222),3003(inet),9997(everybody),20222(u0_a222_cache),50222(all_a222)
```

### Root Cause Analysis[#](#root-cause-analysis)

We found a critical vulnerability in the `kbase_jd_user_buf_pin_pages()` function of the Mali GPU kernel driver. This function is crucial: it manages how the GPU accesses memory, preparing user-provided memory buffers and (supposedly) ensuring the app has the right permissions (read or write). Looking at the [`Patch Changelist`](https://android.googlesource.com/kernel/google-modules/gpu/%2B/5381ff7b4106b277ff207396e293ede2bf959f0c%5E%21/), the issue becomes clear. The vulnerability is in how `kbase_jd_user_buf_pin_pages()` checks those permissions. It’s all about the `KBASE_REG_GPU_WR` (GPU Write) and `KBASE_REG_CPU_WR` (CPU Write) flags—they tell the driver what kind of access is needed. An app should need both flags set for GPU write access, but the code only checks for `KBASE_REG_GPU_WR` flag, leaving a gaping hole.

```
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note
 /*
  *
- * (C) COPYRIGHT 2010-2021 ARM Limited. All rights reserved.
+ * (C) COPYRIGHT 2010-2022 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the
  * GNU General Public License version 2 as published by the Free Software
@@ -1683,7 +1683,8 @@
 				/* The allocation could still have active mappings. */
 				if (user_buf->current_mapping_usage_count == 0) {
 					kbase_jd_user_buf_unmap(kctx, reg->gpu_alloc,
-						(reg->flags & KBASE_REG_GPU_WR));
+						(reg->flags & (KBASE_REG_CPU_WR |
+							       KBASE_REG_GPU_WR)));
 				}
 			}
 		}
@@ -4561,6 +4562,7 @@
 	struct mm_struct *mm = alloc->imported.user_buf.mm;
 	long pinned_pages;
 	long i;
+	int write;

 	if (WARN_ON(alloc->type != KBASE_MEM_TYPE_IMPORTED_USER_BUF))
 		return -EINVAL;
@@ -4575,41 +4577,37 @@
 	if (WARN_ON(reg->gpu_alloc->imported.user_buf.mm != current->mm))
 		return -EINVAL;

+	write = reg->flags & (KBASE_REG_CPU_WR | KBASE_REG_GPU_WR);
+
 #if KERNEL_VERSION(4, 6, 0) > LINUX_VERSION_CODE
-	pinned_pages = get_user_pages(NULL, mm,
-			address,
-			alloc->imported.user_buf.nr_pages,
+	pinned_pages = get_user_pages(
+		NULL, mm, address,
+		alloc->imported.user_buf.nr_pages,
 #if KERNEL_VERSION(4, 4, 168) <= LINUX_VERSION_CODE && \
 KERNEL_VERSION(4, 5, 0) > LINUX_VERSION_CODE
-			reg->flags & KBASE_REG_GPU_WR ? FOLL_WRITE : 0,
-			pages, NULL);
+		write ? FOLL_WRITE : 0, pages, NULL);
 #else
-			reg->flags & KBASE_REG_GPU_WR,
-			0, pages, NULL);
+		write, 0, pages, NULL);
 #endif
 #elif KERNEL_VERSION(4, 9, 0) > LINUX_VERSION_CODE
-	pinned_pages = get_user_pages_remote(NULL, mm,
-			address,
-			alloc->imported.user_buf.nr_pages,
-			reg->flags & KBASE_REG_GPU_WR,
-			0, pages, NULL);
+	pinned_pages = get_user_pages_remote(
+		NULL, mm,
+		address, alloc->imported.user_buf.nr_pages,
+		write, 0, pages, NULL);
 #elif KERNEL_VERSION(4, 10, 0) > LINUX_VERSION_CODE
-	pinned_pages = get_user_pages_remote(NULL, mm,
-			address,
-			alloc->imported.user_buf.nr_pages,
-			reg->flags & KBASE_REG_GPU_WR ? FOLL_WRITE : 0,
-			pages, NULL);
+	pinned_pages = get_user_pages_remote(
+		NULL, mm,
+		address, alloc->imported.user_buf.nr_pages,
+		write ? FOLL_WRITE : 0, pages, NULL);
 #elif KERNEL_VERSION(5, 9, 0) > LINUX_VERSION_CODE
-	pinned_pages = get_user_pages_remote(NULL, mm,
-			address,
-			alloc->imported.user_buf.nr_pages,
-			reg->flags & KBASE_REG_GPU_WR ? FOLL_WRITE : 0,
-			pages, NULL, NULL);
+	pinned_pages = get_user_pages_remote(
+		NULL, mm,
+		address, alloc->imported.user_buf.nr_pages,
+		write ? FOLL_WRITE : 0, pages, NULL, NULL);
 #else
 	pinned_pages = pin_user_pages_remote(
 		mm, address, alloc->imported.user_buf.nr_pages,
-		reg->flags & KBASE_REG_GPU_WR ? FOLL_WRITE : 0, pages, NULL,
-		NULL);
+		write ? FOLL_WRITE : 0, pages, NULL, NULL);
 #endif

 	if (pinned_pages <= 0)
@@ -4843,7 +4841,7 @@
 						kbase_reg_current_backed_size(reg),
 						kctx->as_nr);

-			if (reg && ((reg->flags & KBASE_REG_GPU_WR) == 0))
+			if (reg && ((reg->flags & (KBASE_REG_CPU_WR | KBASE_REG_GPU_WR)) == 0))
 				writeable = false;

 			kbase_jd_user_buf_unmap(kctx, alloc, writeable);
```

The patch shows the core of the problem. The `FOLL_WRITE` flag is set if `KBASE_REG_GPU_WR` is set, but not `KBASE_REG_CPU_WR`. This is incorrect. It should only be set if both flags are set. Because of this oversight, a malicious app can request CPU write access (by setting `KBASE_REG_CPU_WR`) without needing the required GPU write access (`KBASE_REG_GPU_WR`). This allows the ap...