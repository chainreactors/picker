---
title: shiro 721 CVE-2019-12422
url: https://www.freebuf.com/vuls/416385.html
source: FreeBuf网络安全行业门户
date: 2025-01-08
fetch_date: 2025-10-06T20:10:05.171874
---

# shiro 721 CVE-2019-12422

[![freeBuf](/images/logoMax.png)](/)

主站

分类

云安全

AI安全

开发安全

终端安全

数据安全

Web安全

基础安全

企业安全

关基安全

移动安全

系统安全

其他安全

特色

热点

工具

漏洞

人物志

活动

安全招聘

攻防演练

政策法规

[报告](https://www.freebuf.com/report)[专辑](/column)

* ···
* [公开课](https://live.freebuf.com)
* ···
* [商城](https://shop.freebuf.com)
* ···
* 用户服务
* ···

行业服务

政 府

CNCERT
CNNVD

会员体系（甲方）
会员体系（厂商）
产品名录
企业空间

[知识大陆](https://wiki.freebuf.com/page)

搜索

![](/freebuf/img/7aa3bf7.svg) ![](/freebuf/img/181d733.svg)

创作中心

[登录](https://www.freebuf.com/oauth)[注册](https://www.freebuf.com/oauth)

官方公众号企业安全新浪微博

![](/images/gzh_code.jpg)

FreeBuf.COM网络安全行业门户，每日发布专业的安全资讯、技术剖析。

![FreeBuf+小程序](/images/xcx-code.jpg)

FreeBuf+小程序把安全装进口袋

[![](https://image.3001.net/images/20231020/1697804527_653270ef7570cc7356ba8.png)](https://wiki.freebuf.com)

shiro 721 CVE-2019-12422

* ![]()
* 关注

* [漏洞](https://www.freebuf.com/articles/vuls)

shiro 721 CVE-2019-12422

2025-01-29 16:48:49

所属地 广东省

**Description**[5]

The cookie rememberMe is encrypted by AES-128-CBC mode, and this can be vulnerable to padding oracle attacks. Attackers can use a vaild rememberMe cookie as the prefix for the Padding Oracle Attack,then make a crafted rememberMe to perform the java deserilization attack like [SHIRO-550](https://issues.apache.org/jira/browse/SHIRO-550).

Steps to reproduce this issue:

1. Login in the website and get the rememberMe from the cookie.
2. Use the rememberMe cookie as the prefix for Padding Oracle Attack.
3. Encrypt a ysoserial's serialization payload to make a crafted rememberMe via Padding Oracle Attack.
4. Request the website with the new rememberMe cookie, to perform the deserialization attack.

# 密码原理

AES-128加密过程：

1. 填充数据确保数据长度为16字节整数倍
2. 按照某个工作模式，对数据进行加密

shiro的默认配置：

![image](https://image.3001.net/images/20241128/1732765853_6747e89dbd245c1a5c843.png!small)

## 填充规则

PKCS#5 按照严格定义来讲最多只能填充8个字节，但Java中没有对PKCS5和PKCS7进行严格划分，Aes128实际填充肯定会出现填充超过8个字节的情况，所以实际填充逻辑是PSCS7

```
原数据的最后一个分组					  填充情况
 -----------------------------------------------------------------------
 01 02 03 04 05 06 07				 9个0x09
 01 02 03 04 05 06 07 08        	 8个0x08
 刚好16字节                     	  16个0x10  //防止明文数据干扰填充长度的判断
```

[padding - PKCS7 / PKCS5 填充算法 - 个人文章 - SegmentFault 思否](https://segmentfault.com/a/1190000019793040)

**解密成功的判断标准仅是看解密结果是否符合填充规则**

伪代码：

```
bool isDecryptedSuccess(const vector<uint8_t>& decryptedData) {
    size_t dataLength = decryptedData.size();

    // 检查数据长度是否大于 0
    if (dataLength == 0) {
        return false; // 数据为空，解密失败
    }

    // 获取最后一个字节的值，表示填充的字节数
    uint8_t paddingLen = decryptedData[dataLength - 1];

    // 检查填充值是否在有效范围内
    if (paddingLen < 1 || (paddingLen > 8 && paddingLen != 16)) {
        return false;
    }

    // 检查填充的字节是否与填充值一致
    for (size_t i = 1; i <= paddingLen; ++i) {
        if (decryptedData[dataLength - i] != paddingLen) {
            return false; // 填充不一致，解密失败
        }
    }

    return true;
}
```

## CBC 工作模式

**加密**：

![image](https://image.3001.net/images/20241128/1732766088_6747e988da36977f388cb.png!small)

**解密**

![image](https://image.3001.net/images/20241128/1732766109_6747e99db6d9a51876e63.png!small)

对于其中的`Block Cipher Encryption`或`Block Cipher Decription`，我们不用关系其算法是什么,它可以是任何分组密码算法，（DES，AES,...），将其看成一个black box就行

![image](https://image.3001.net/images/20241128/1732766125_6747e9ad4d060574a0410.png!small)

# Padding Attack

## 密文to明文

仅作为补充知识，了解已知密文如何破解明文，本次漏洞在 明文to密文 部分

**利用条件**：

1. 已知密文，初始向量（一般放在密文的第一个分组）
2. 假设服务器会返回2种状态

```
1. 服务端解密成功，并且反序列成功(且返回的是必须是Principal对象），响应头中没有remberMe=deleteMe
2. 服务端解密失败，响应头返回remberMe=deleteMe
```

[Shiro 密钥爆破 - FreeBuf网络安全行业门户](https://www.freebuf.com/vuls/415408.html),中阐明了具体触发remberMe=deleteMe的条件
为了满足这两种状态必须：
payload = 合法数据 + 测试数据（padding oracle)
![image](https://image.3001.net/images/20241128/1732766140_6747e9bcb6e7e1b9a2fa5.png!small)
**java序列化数据后的脏数据不影响反序列化结果**[2]，合法数据是为了让payload解密成功后能够反序列成功，这样就不会因为反序列失败而remberMe=deleteMe，只会因为测试数据不符合填充规则（BadPaddingException）而返回remberMe=deleteMe；即解密成功必然不会返回remberMe=deleteMe，解密失败必然返回remberMe=deleteMe

### **原理**

为了方便讲述，设置以下条件(shiro 中Aes 128是16字节为一个分组）

```
密码分组大小：8 bytes
```

现假设发来数据

```
paddingOracle=7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6...
-------------------分解-----------------------------
初始化向量IV: 7B  21  6A  63  49  51  17  0F
第一组密文C1: F8  51  D6  CC  68  FC  95  37
第二组密文C2: 85  87  95  A2  8E  D4  AA  C6
....
第n组密文Cn:  ....
```

> IV 看作C0

#### **尝试破解第一组密文：**

| 已知条件 | 未知条件(目标) |
| --- | --- |
| 1.C0,C1,C2...Cn; 2. P1 = C0 ⊕ IM1, P2 = C1 ⊕ IM2 ... Pn = Cn-1 ⊕ IMn | 中间值： IM1,IM2,...IMn |

由于Cn，D()，Key都是固定的，所以中间值IMn必然是固定的，所以只要解出中间值，就能利用 C0 ⊕ IM1 == P1得出第一组明文

发送数据 ：合法数据(validData) + PaddingOracle (po)

**定义：**

* 令`po = C0_t + C1` (“+”指的是连接两个分组，C0\_t是用来遍历的，C1是固定的)
* `P1_t`是在解密C1过程中出现的垃圾数据，我们只关心其填充情况即可

**计算IM1[7]: 填充0x01的情况**

---

```
C1               |  F8  51  D6  CC  68  FC  95  37
D()              |  [--Block Cipher Decription---]
IM1              |  b1  b2  b3  b4  b5  b6  b7  b8
C0_t             |  00  00  00  00  00  00  00  xx
															⊕
------------------------------------------------------------
P1_t             |  b1  b2  b3  b4  b5  b6  b7  01
```

所以我们需要不断遍历C0\_t的最后一个字节C0\_t[7]（表中`xx`），让其从00向ff不断增大,**当且仅当**`P1_t[7]== 01`时，才不会返回remeberMe=deleteMe (利用条件中第一种状态)

> 有没有可能在这个过程中出现02 02填充情况？有但概率极低，保守估算：
>
> p(b7 = 02 )\* p(b8 ⊕ C0\_t[7]先出现02，后出现01) ==1/256 \* 1/2 = 1/512 约等于 0.2% 实际情况只会更低
>
> 03 03 03就概率更低了，其他更不用说。所以不考虑

这时我们就可以计算出IM1的最后一个字节`IM1[7] == C0_t[7] ⊕ 0x01`，

> 假设此时`C0_t[7] = 3C`则`IM1[7] = 0x3D`从而计算得出`P1[7] == IM1[7] ⊕ C0[7] == 0x3D ⊕ 0x7B`

**计算IM1[6] : 填充0x02的情况**

---

```
C1              |  F8  51  D6  CC  68  FC  95  37
D               |  [--Block Cipher Decription---]
IM1             |  b1  b2  b3  b4  b5  b6  b7  3D
C0_t            |  00  00  00  00  00  00  xx  3F
															                            ⊕
------------------------------------------------------------
P1_t            |  b1  b2  b3  b4  b5  b6  02  02
```

> 此时已知IM1[7] == 3D,且此时我们期待的P1\_t [7]== 0x02,因此C0\_t[7]也要调整为 3D⊕02 = 3F
>
> 如此当且仅当P1\_t[6] == 02 时才不会返回rememberMe=deleteMe,即状态1

仿照上一轮，遍历IV\_t[6]，直至服务端返回状态1，

> 假设此时`C0_t[6] == 0x24`计算可得，`IM1[6]== 0x24 ⊕ 0x02 == 0x26`然后得出P1[6]

重复上述步骤直至，计算出完整的P1

后面第n组密文的破解也是一样的,核心就是计算出中间值

## 明文to密文

又称：**CBC字节翻转攻击**

each block of ciphertext decrypts to an unknown value, then is XOR’d with the previous block of ciphertext. By carefully selecting the previousblock, we can control what the next block decrypts to. Even if the next block decrypts to a bunch of garbage, it’s still being XOR’d to a value that we control, and can therefore be set to anything we want. [1]

与 **从密文to明文**部分相同的是，**都需要获取中间值IM**,且获取方法相同，但不同的是前者是从头到尾破解出明文，后者是从尾到头构造密文。

**原理**：
![image.png](https://image.3001.net/images/20250129/1738140497_6799eb51b4875d96eb942.png!small)

> Pn ⊕ IMn ⊕ IMn == Pn ⊕ 0 == Pn

**步骤**[1]

* Select a string,`P`, that you want to generate ciphertext,`C`, for：选取我们的payload作为这里的P
* Pad the string to be a multiple of the blocksize, using appropriate padding, then split it into blocks numbered from 1 to n
* Generate a block of random data (`Cn`- ultimately, the final block of ciphertext)：最后一个密文分组可以是随机数据（仅限最后一个密文分组）
* For each block of plaintext, **starting with the last one**：

```
po = [0x00]*16  +  Cn   //padding oracle 长度始终为两个分组长
```

（1）初始化我们要构造的密文`cipherText = new byte[0]`，并插入之前生成的Cn（随机数据）
（2）选取2个分组,第一个分组永远为16个0x00,
（3） 按照**密文to明文**的**原理**部分，不断遍历第一个分组，最终计算出Cn的中间值IMn
（4）令分组`Cn-1 == IMn ⊕ Pn`,（Pn是我们payload的第n分组）将Cn-1插入到`cipherText`(头插法)
（5）将Cn-1作为下一轮po的第二分组，计算IMn-1,重复以上过程直至获取完整的`cipherText`

# PayLoad

Principal 到 renberMe输出的完整过程

* AbstractRemeberMeManager:
  ![image](https://image.3001.net/images/20241128/1732766281_6747ea495866cd7c38a44.png!small)
  反序列化，然后加密
  ![image](https://image.3001.net/images/20241128/1732766297_6747ea59ad311e94a26e8.png!small)
  CookieRememberMeManager (extends AbstractRememberMeManager): 将数据base64编码然后设置为cookie值（name已经设置了），存入request
  ![image](https://image.3001.net/images/20241128/1732766317_6747ea6d4a3600490d0ba.png!small)
* ...