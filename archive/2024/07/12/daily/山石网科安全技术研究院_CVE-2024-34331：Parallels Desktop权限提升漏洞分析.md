---
title: CVE-2024-34331：Parallels Desktop权限提升漏洞分析
url: https://mp.weixin.qq.com/s?__biz=MzUzMDUxNTE1Mw==&mid=2247506915&idx=1&sn=40b10ca14c76a8004c4792e3dac86271&chksm=fa520e5dcd25874bfc6b07882ebdf3a476767cd18b82924130b7d1ed0975095138f7aafe98fd&scene=58&subscene=0#rd
source: 山石网科安全技术研究院
date: 2024-07-12
fetch_date: 2025-10-06T17:44:35.210353
---

# CVE-2024-34331：Parallels Desktop权限提升漏洞分析

![cover_image](https://mmbiz.qpic.cn/mmbiz_jpg/Gw8FuwXLJnQ7fJuib0Mm4pRULibibzn8pD1fqvHcLvLS1rDgjPgXpEa2TP1G8S8iagcrUpZjepJsG0RgEicqz05TKsA/0?wx_fmt=jpeg)

# CVE-2024-34331：Parallels Desktop权限提升漏洞分析

原创

unr4v31

山石网科安全技术研究院

Parallels Desktop是macOS下的一个虚拟机软件，在其打包功能中存在一处安全性问题。本文通过利用 Parallels Desktop 对 macOS 安装程序的信任，进行本地权限提升 [1]。

# 漏洞详情

* 受影响产品：Parallels Desktop for macOS [2]
* 受影响主机：基于x86\_64的主机（搭载Intel处理器的Mac）
* 受影响版本：16.0.0 至 19.3.0
* 修复版本：19.3.1
* CVE编号：CVE-2024-34331

# 漏洞发现

在使用 Parallels 的大规模部署包进行测试时，使用了2018年款的 Intel Mac mini 和一个 macOS 虚拟机。在测试过程中注意到一个奇怪的现象，那就是在创建 macOS 虚拟机时，从未出现过密码提示。这不符合常理，因为Parallels 使用了苹果的 createinstallmedia程序，此程序需要 root 权限。经过进一步检查，通过一个名为 repack\_osx\_install\_app.sh 的脚本确认了这一点，该脚本位于 Parallels Desktop.app/Contents/Resources 下：

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnQ7fJuib0Mm4pRULibibzn8pD12JkIY8VCGC1vvJcWfiaqL0GAnHicDD3exmDAyx2Jia10vS3Z412M0oFxg/640?wx_fmt=png&from=appmsg)

从以上bash脚本中可以看到，在运行 createinstallmedia 时并没有进行任何校验和验证，这可能是一个非常容易被利用的漏洞。但现在存在另一个疑问，Parallels 是如何在没有管理员凭据的情况下以 root 身份运行 createinstallmedia 程序的呢？

# 程序SUID位的魔力

在Unix系统中，存在多个权限标识（如Linux定义在cred结构体中）：

* UID (User ID) - 实际用户标识：指启动进程的用户的实际用户ID。例如，如果以用户名`alice`登录系统，那么该进程的UID就是`alice`的用户ID。
* GID (Group ID) - 实际组标识：指启动进程的用户所属的实际组的组ID，表示用户所属的组。例如，如果`alice`属于组`developers`，那么该进程的GID就是`developers`的组ID。
* EUID (Effective User ID) - 有效用户标识：在程序运行时用于权限检查的用户ID。它可以与UID相同，也可以不同，这取决于程序是否设置了特殊权限位，如Set-User-ID（SUID）。当程序具有SUID权限时，EUID通常会变为程序文件的所有者的用户ID。这允许程序以文件所有者的权限运行，通常用于提供临时的权限提升，例如`passwd`命令。
* EGID (Effective Group ID) - 有效组标识：在程序运行时用于权限检查的组ID，程序具有SGID权限时，EGID通常会变为程序文件的所有者的组ID。
* SUID (Set-User-ID) - 设置用户标识：SUID是一种文件权限，用于可执行文件，当设置了SUID位的可执行程序运行时，它的EUID将变为文件所有者的UID，而不是启动进程的实际UID。典型的例子是`passwd`程序，它需要以root权限更改密码。
* SGID (Set-Group-ID) - 设置组标识：SGID是一种文件权限，类似于SUID，但是针对组。例如，某些目录需要以特定组的权限运行，以便其他用户可以访问其中的文件。
* FSUID (Filesystem User ID) - 文件系统用户标识：在文件系统级别上用于权限检查的用户ID，确保文件系统上的访问权限正确。
* FSGID (Filesystem Group ID) - 文件系统组标识：在文件系统级别上用于权限检查的组ID。

例如，要查看macOS下/usr/bin/top文件的权限，可以使用：

```
ls -la /usr/bin/top

# 输出结果为
-r-sr-xr-x  1 root  wheel  273520  6 15  2023 /usr/bin/top
```

对于上面的输出结果，root为所有者，所有者具有读取权限，s表示设置了 Set-User-ID（SUID）权限，当执行此文件时，进程的有效用户 ID（EUID）将变为文件所有者的用户 ID，而不是启动进程的实际用户 ID。wheel为文件所属的用户组，用户组成员具有可读和可执行权限，没有写权限。其他人（非所有者且非组成员）具有可读和可执行权限，没有写入权限。总之，/usr/bin/top文件是一个具有 SUID 权限的普通文件，它允许以 root 用户的权限运行 `top` 命令。

总结，这个 S-Bit 所做的是允许可执行文件将其 UID（用户 ID）更改为文件所有者的 UID。如果文件的所有者是 root，那么当前程序就可以以 root 身份运行了。

此外，可以通过以下命令查找到所有具有 S-Bit 的文件：

```
/usr/bin/find . -perm -u=s
```

# Parallels历史权限提升漏洞

在ZDI发布的《BASH PRIVILEGED-MODE VULNERABILITIES IN PARALLELS DESKTOP AND CDPATH HANDLING IN MACOS》[3] 一文中，详细解释了SUID导致的 Parallels 提权问题。

在ZDI的文章中提到，Parallels Desktop有几个setuid二进制文件：prl\_update\_helper 和 Parallels Service，这两个二进制文件都以root权限运行，并且通过调用bash脚本来以root权限运行命令：

![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnQ7fJuib0Mm4pRULibibzn8pD1A2ibic5UwfgYXKR6pDh8Bdqy6OpJ33AojILr6e4J32SymvU4eVBlHoCA/640?wx_fmt=png&from=appmsg)

对于在二进制程序中通过调用bash脚本来以root权限运行命令这类用例，bash提供专门的特权模式 [4] ，参数为“-p”。

在使用bash特权模式时，bash shell 会在有效用户标识与实际用户标识不相等时降低权限，有效用户标识被重置为实际用户标识的值。同样，组标识也适用于相同的规则。在特权模式下，bash 不会降低有效权限，并会忽略环境中的敏感变量和 shell 函数。以下是在 bash 的 shell.c 文件中找到的相关源代码：

```
int
main (argc, argv, env)
     int argc;
     char **argv, **env;
{
. . .
  running_setuid = uidget ();
. . .
  if (running_setuid && privileged_mode == 0)
    disable_priv_mode ();
. . .
  shell_initialize ();
. . .
  if (locally_skip_execution == 0 && running_setuid == 0)
    {
. . .
      run_startup_files ();
```

这里的 uidget 函数在从 setuid/setgid 进程启动 bash 时设置 running\_setuid。在下面代码中，如果未指定特权模式，则使用 setuid 和 setgid 调用将权限降低为实际标识的权限：

```
/* Fetch the current set of uids and gids and return 1 if we're running
   setuid or setgid. */
static int
uidget ()
{
  uid_t u;

  u = getuid ();
. . .
  current_user.uid = u;
  current_user.gid = getgid ();
  current_user.euid = geteuid ();
  current_user.egid = getegid ();

  /* See whether or not we are running setuid or setgid. */
  return (current_user.uid != current_user.euid) ||
           (current_user.gid != current_user.egid);
}

void
disable_priv_mode ()
{
  setuid (current_user.uid);
  setgid (current_user.gid);
  current_user.euid = current_user.uid;
  current_user.egid = current_user.gid;
}
```

通过以上两段bash源码，我们了解了bash特权模式专门针对于这种情景所做的权限控制。而在18.1.0版本之前的Parallels Desktop没有利用bash特权模式，也没有过滤不受信任的环境变量，这就导致本地权限提升。

在 Parallels Desktop 的情况中，二进制文件使用 setuid() 系统调用将真实用户标识设置为有效用户标识。这种实现的问题在于，敏感的环境变量（如 BASH\_ENV、ENV、SHELLOPTS、BASHOPTS、CDPATH、GLOBIGNORE 和其他 shell 函数）会被 bash 处理。这是因为 bash 不知道 setuid 或 setgid 执行，并信任其环境。最终，具有对环境变量控制权的本地非特权用户可以利用此漏洞以 root 权限执行代码。

* CVE-2023-27322（ZDI-23-216）- 通过Parallels服务进行本地权限提升

Parallels Service 会 fork 一个子进程，并使用一个非交互式的 bash shell（以 /bin/bash -s 形式调用）来执行嵌入的脚本。父进程通过管道将嵌入的脚本写入运行 bash shell 的子进程。在调用 bash shell 之前，Parallels Service 调用 setuid(0) 将真实用户标识设置为有效用户标识（root）。以下是 Parallels Desktop 版本 17.1.4 中可执行文件中的相关代码片段：

```
__text:000000010000603B loc_10000603B:                          ; CODE XREF: child_process+4D↑j
__text:000000010000603B                                         ; child_process+68↑j
__text:000000010000603B                 call    _geteuid
__text:0000000100006040                 test    eax, eax
__text:0000000100006042                 jnz     short loc_10000605B
__text:0000000100006044                 call    _getuid         ;  when effective uid is 0
__text:0000000100006049                 mov     ebx, eax
__text:000000010000604B                 call    _geteuid
__text:0000000100006050                 cmp     ebx, eax        ; check real uid == effective uid
__text:0000000100006052                 jz      short loc_10000605B
__text:0000000100006054                 xor     edi, edi        ; uid_t
__text:0000000100006056                 call    _setuid         ;  setuid(0)
__text:000000010000605B
__text:000000010000605B loc_10000605B:                          ; CODE XREF: child_process+E2↑j
__text:000000010000605B                                         ; child_process+F2↑j
__text:000000010000605B                 call    _getuid
__text:0000000100006060                 test    eax, eax
__text:0000000100006062                 jz      short loc_1000060B9
__text:0000000100006064
__text:0000000100006064 loc_100006064:                          ; CODE XREF: child_process+162↓j
__text:0000000100006064                 mov     rdi, [r14]      ; __path
__text:0000000100006067                 mov     rsi, r14        ; __argv
__text:000000010000606A                 call    _execv
```

`execv` 函数是对 `execve` 的一个包装，它使用 `_NSGetEnviron()` 获取环境变量并将其传递给 `execve`。因此，作为子进程生成的 Bash shell 可以访问由启动 Parallels Service 的用户设置的所有环境变量，该用户可能是一个非特权用户。最终通过使用bash特权模式参数“-p”修复了此漏洞。

* CVE-2023-27324 （ZDI-23-218）和 CVE-2023-27325（ZDI-23-219），通过Parallels Updater进行本地权限提升。这两处漏洞是在Parallels Updater prl\_update\_helper 二进制文件中发现的。在CVE-2023-27324中，prl\_update\_helper 二进制文件调用一个名为 inittool 的bash脚本，而无需设置特权模式：

  ```
      snprintf(&script_path, 0x400uLL, "%s/Contents/MacOS/inittool", appbundle_path);
      __argv[0] = &script_path;
      __argv[1] = "install";
      __argv[2] = "-t";
      __argv[3] = target_path;
      __argv[4] = 0LL;
  . . .
          v48 = posix_spawn(&v47.st_dev, &script_path, 0LL, 0LL, __argv, &_envp);
  ```

  ![](https://mmbiz.qpic.cn/mmbiz_png/Gw8FuwXLJnQ7fJuib0Mm4pRULibibzn8pD10LPcniaqJQibMATClHJMUWoQ8ky2nUN9HzYqy9M4F81FEcicoYLhOOy2w/640?wx_fmt=png&from=appmsg)

  在调用`inittool`脚本之前，将真正的用户标识符设置为有效用户标识符，即root。这意味着bash将作为root运行，并将信任其执行环境，这可能会导致本地特权升级：

  ```
  __text:0000000100005B90 start           proc near
  . . .
  __text:0000000100005B90
  __text:0000000100005B90                 push    rbp
  __text:0000000100005B91                 mov     rbp, rsp
  __text:0000000100005B94                 push    r15
  __text:0000000100005B96                 push    r14
  __text:0000000100005B98                 push    rbx
  __text:0000000100005B99                 sub     rsp, 0CD8h
  __text:0000000100005BA0                 mov     rax, cs:___stack_chk_guard_ptr
  __text:0000000100005BA7                 mov     rax,...