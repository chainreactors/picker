---
title: HXP38C3 Mbins Wp 解释器：侧信道攻击与模拟执行技术深度解析
url: https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458589387&idx=1&sn=e5c3af05513fa019057d15ec6357373a&chksm=b18c284186fba15712d674a366bb5f842083724468f1ca4b5dea0735c708f504eaa00e19ad88&scene=58&subscene=0#rd
source: 看雪学苑
date: 2025-02-11
fetch_date: 2025-10-06T20:38:37.523979
---

# HXP38C3 Mbins Wp 解释器：侧信道攻击与模拟执行技术深度解析

![cover_image](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8E4gvpb3vgYVWnRWiamTMSjXTF8aMHzXQRWS5aZCfaluD9EYjjzHbrBxxgab1R0ZVibQpVtTH03oBSA/0?wx_fmt=jpeg)

# HXP38C3 Mbins Wp 解释器：侧信道攻击与模拟执行技术深度解析

SleepAlone

看雪学苑

## 这是我做过的最难的逆向题，题目给了1000个二进制程序，单个难度不大，但是把1000个统一起来自动化那真是太难了，根据这题是考自动化。

```
一

题目背景
```

题目给了chk0.bin-chk999.bin共1000个文件，每个文件接收0x12长度的16进制字符串，如果正确返回0，每个正确的字符串为一个x，y坐标，在 Shamir 秘密共享中，密钥可以通过拉格朗日插值法从足够多的点数中恢复，题目中规定的点数为 ≥ 950

```
# This file was *autogenerated* from the file derive_key.sage
from sage.all_cmdline import *   # import sage library

_sage_const_202750432774689774479024096223623722409 = Integer(202750432774689774479024096223623722409); _sage_const_2 = Integer(2); _sage_const_950 = Integer(950); _sage_const_0 = Integer(0); _sage_const_16 = Integer(16)
p = _sage_const_202750432774689774479024096223623722409

F = Zmod(p)
G = F['x']; (x,) = G._first_ngens(1)

# just the accepted input values from the challenges
solutions = []

points = [*{int.from_bytes(s[:_sage_const_2 ], 'big'): int.from_bytes(s[_sage_const_2 :], 'big') for s in solutions}.items()]

if len(points) >= _sage_const_950 :
    key = G.lagrange_polynomial(points)[_sage_const_0 ]

    print(f"key: {key.lift().to_bytes(_sage_const_16 , 'big').hex()}")
```

所以至少需要搞对950.，好了，开始长征。

```
二

ida 初探
```

可以看到核心逻辑是由一个指令解释器通过解析指令格式，完成各种操作：

```
__int64 __fastcall VM(__int64 *a1)
{
  __int64 result; // rax
  unsigned int *v3; // rdx
  unsigned int v4; // edi
  __int64 v5; // r14
  __int64 v6; // rdi
  unsigned int v7; // r8d
  __int64 v8; // rsi
  __int64 v9; // rcx
  __int64 v10; // rdx
  unsigned int v11; // edi
  __int64 v12; // rcx
  __int64 *v13; // rax
  __int64 v14; // rdi
  __int64 (__fastcall *v15)(_QWORD, __int64, __int64, __int64, __int64, __int64, __int64); // r10
  __int64 v16; // rax
  char v17; // cl
  __int64 v18; // rdx
  unsigned int v19; // edx
  unsigned int v20; // ecx
  unsigned __int64 *v21; // rax
  unsigned __int64 v22; // rcx
  __int64 v23; // [rsp-8h] [rbp-18h]

  v23 = result;
  v3 = (unsigned int *)a1[31];
  v4 = *v3;
  v5 = (__int64)(v3 + 1);
  a1[31] = (__int64)(v3 + 1);
  v6 = _byteswap_ulong(v4);
  v7 = (unsigned int)v6 >> 29;
  if ( (unsigned int)v6 < 0x20000000 || v7 == 1 && (result = v6 & 0x10000000, (v6 & 0x10000000) == 0) )
  {
    v8 = ((unsigned int)v6 >> 19) & 0x1F;
    if ( (BYTE3(v6) & 1 & (v7 == 1)) != 0 || (v6 & 0xE1000000) == 0 )
    {
      if ( v7 == 1 || (unsigned int)v6 >> 25 == 9 || (unsigned int)v6 >> 25 == 7 )// imm
        v9 = v6 << 50 >> 50;                    // low 14 bits signed
      else
        v9 = v6 & 0x3FFF;                       // low 14 bits unsigned
    }
    else
    {
      v9 = a1[((unsigned int)v6 >> 9) & 0x1F];
    }
    v10 = a1[((unsigned int)v6 >> 14) & 0x1F];
    v11 = (unsigned int)v6 >> 25;
    if ( v7 == 1 )
    {
      switch ( v11 & 7 )
      {
        case 0u:
          result = v10 == v9;
          a1[v8] = result;
          break;
        case 1u:
          result = v10 != v9;
          a1[v8] = result;
          break;
        case 2u:
          result = v10 <= v9;
          a1[v8] = result;
          break;
        case 3u:
          result = v10 < v9;
          a1[v8] = result;
          break;
        case 4u:
          result = v10 <= (unsigned __int64)v9;
          a1[v8] = result;
          break;
        case 5u:
          result = v10 < (unsigned __int64)v9;
          a1[v8] = result;
          break;
        default:
LABEL_20:
          result = 0LL;
          a1[v8] = 0LL;
          break;
      }
    }
    else
    {
      switch ( v11 & 0xF )
      {
        case 0u:
          v12 = v10 | v9;
          goto LABEL_38;
        case 1u:
          v12 = v10 ^ v9;
          goto LABEL_38;
        case 2u:
          v12 = v10 & v9;
          goto LABEL_38;
        case 3u:
          v12 = v10 + v9;
          goto LABEL_38;
        case 4u:
          v18 = v10 - v9;
          goto LABEL_48;
        case 5u:
          v12 = v10 * v9;
LABEL_38:
          result = v12;
          a1[v8] = v12;
          return result;
        case 6u:
          result = v10 / (unsigned __int64)v9;
          a1[v8] = v10 / (unsigned __int64)v9;
          return result;
        case 7u:
          result = v10 / v9;
          a1[v8] = v10 / v9;
          return result;
        case 8u:
          v18 = v10 % (unsigned __int64)v9;
          goto LABEL_48;
        case 9u:
          v18 = v10 % v9;
          goto LABEL_48;
        case 0xAu:
          v18 = v10 << v9;
          goto LABEL_48;
        case 0xBu:
          v18 = v10 >> v9;
          goto LABEL_48;
        case 0xCu:
          v18 = (unsigned __int64)v10 >> v9;
          goto LABEL_48;
        case 0xDu:
          v18 = __ROL8__(v10, v9);
          goto LABEL_48;
        case 0xEu:
          v18 = __ROR8__(v10, v9);
LABEL_48:
          result = v18;
          a1[v8] = v18;
          break;
        default:
          goto LABEL_20;
      }
    }
    return result;
  }
  if ( v7 == 1 )
  {
    v7 = ((unsigned int)v6 >> 26) & 3;
    if ( v7 == 2 )
    {
      v14 = ((unsigned int)v6 >> 20) & 0x1F;
      v15 = (__int64 (__fastcall *)(_QWORD, __int64, __int64, __int64, __int64, __int64, __int64))a1[v14];
      if ( (unsigned __int64)v15 < a1[32] || (unsigned __int64)v15 >= a1[33] )
      {
        result = v15(*a1, a1[1], a1[2], a1[3], a1[4], a1[5], v23);
        *a1 = result;
        a1[31] = v5;
      }
      else
      {
        v16 = a1[30];                           // PUSH
        *(_QWORD *)(v16 - 8) = v5;              // call
        result = v16 - 8;
        a1[31] = a1[v14];
        a1[30] = result;
      }
      return result;
    }
    if ( !v7 )
    {
      v13 = (__int64 *)a1[30];                  // pop
      a1[31] = *v13;                            // ret
      result = (__int64)(v13 + 1);
      a1[30] = result;
      return result;
    }
    if ( (v6 & 0x2000000) != 0 )                // check 26 bit
    {
      result = 37LL;
      v17 = 39;
    }
    else
    {
      result = ((unsigned int)v6 >> 20) & 0x1F; // 21-25
      if ( !a1[result] )
        goto LABEL_52;
      result = 42LL;
      v17 = 44;
    }
    a1[31] = (__int64)v3 + ((__int64)((unsigned __int64)(unsigned int)v6 << v17) >> result);
LABEL_52:
    if ( (v6 & 0x2000000) == 0 )
      return result;
  }
  if ( v7 == 2 )
  {
    if ( (((unsigned int)v6 >> 27) & 3) != 0 )  // 2829
    {
      v19 = ((unsigned int)v6 >> 21) & 0x1F;    // 22-26
      v20 = WORD1(v6) & 0x1F;
      result = (unsigned __int16)v6 - 0x8000LL;
      if ( (v6 & 0x8000u) == 0LL )
        result = (unsigned __int16)v6;
      if ( (((unsigned int)v6 >> 27) & 3) == 1 )
      {
        result = *(_QWORD *)(a1[v20] + result);
        a1[v19] = result;                       // load
      }
      else
      {
        switch ( ((unsigned int)v6 >> 26) & 3 ) // store
        {
          case 0u:
            *(_BYTE *)(a1[v20] + result) = a1[v19];
            break;
          case 1u:
            *(_WORD *)(a1[v20] + result) = a1[v19];
            break;
          case 2u:
            *(_DWORD *)(a1[v20] + result) = a1[v19];
            break;
          case 3u:
            *(_QWORD *)(a1[v20] + result) = a1[v19];
            break;
        }
      }
    }
    else
    {
      v21 = (unsigned __int64 *)a1[31];
      v22 = _byteswap_uint64(*v21);
      result = (__int64)(v21 + 1);
      a1[31] = result;
      a1[WORD1(v6) & 0x1F] = v22;
    }
  }
  return result;
}
```

指令在data段里，这里不管调试，使用pyda侧信道（关于pyda 看前面的文章），或者直接将这段代码复制出来放在本地跑，都可以知道这段程序的行为。

部分数据j结构可以猜出来，VM\_context可以表示如下：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8E4gvpb3vgYVWnRWiamTMSjXmicQ4sHUeExUV8SoQx8OJGW8fUXKE1hrgO5nszGbJpc2NjZKnl0AtXw/640?wx_fmt=png&from=appmsg)

## 源代码模拟

当然，也不是简单的复制，多打开几个bin，会发现在指令解析前都会有不同的操作，可以总结为(’big‘,’liitle’) X (’lfsr’,’no\_lfsr’)的笛卡尔积，共四种情况，在个别的bin中，还会对指令码做初始化操作，这些初始化操作都是为了call 其他的函数

源代码模拟代码如下：

```
#include<stdio.h>
#include<stdint.h>
#include"defs.h"
#include <intrin.h>
#include<iostream>
#include <cstdarg>

using namespac...