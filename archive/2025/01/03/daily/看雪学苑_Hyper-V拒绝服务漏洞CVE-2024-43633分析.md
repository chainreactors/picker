---
title: Hyper-V拒绝服务漏洞CVE-2024-43633分析
url: https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458587938&idx=1&sn=501d4121b0437af290d817483a675882&chksm=b18c23a886fbaabe422e605465696484340427bfb6526e2118e6f832e266bac9bce720eff738&scene=58&subscene=0#rd
source: 看雪学苑
date: 2025-01-03
fetch_date: 2025-10-06T20:09:48.790995
---

# Hyper-V拒绝服务漏洞CVE-2024-43633分析

![cover_image](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8FVzNwDWrTVic9ZOChjQcCJd9vgRYZmeqfrYkaCbIwO0Pfniaur5icGia3OWNudYxD7SHxCSKPNiaavtwQ/0?wx_fmt=jpeg)

# Hyper-V拒绝服务漏洞CVE-2024-43633分析

王cb

看雪学苑

这篇文章的目的是介绍今年11月发布的的Hyper-V拒绝服务漏洞CVE-2024-43633分析。文章结合了逆向代码和调试结果分析了CVE-2024-43633漏洞利用过程和漏洞成因。

## 复现环境

Win11 23h2

Win11 22h2

##

## CVE-2024-43633漏洞分析

CVE-2024-43633是笔者今年7月向微软MSRC提交的Hyper-V拒绝服务漏洞，漏洞可在Win11 23h2上复现,漏洞致谢发布于11月，漏洞的成因主要存在于Hyper-V根分区的vmbusr.sys驱动未正确处理虚拟机重置后vmbus通道分区的引用与解引用次数不一致导致触发内核崩溃断言的拒绝服务结果。

```
00 ffffcd04`0d0d7460 fffff800`872daeef     vmbusr!ChDereferenceChannelInternal+0x9c
01 ffffcd04`0d0d7490 fffff800`872b5173     vmbusr!ChServerChannelReleasedByClientLocked+0x57
02 ffffcd04`0d0d74c0 fffff800`872da012     vmbusr!ChpPartitionWaitChannelClosed+0xc7
03 ffffcd04`0d0d7500 fffff800`872d8c87     vmbusr!ChResetPartition+0x3e
void __fastcall ChDereferenceChannelInternal(__int64 a1, int a2, __int16 a3)
{
 IoQueueWorkItem(
        ChLocalOfferRemoveWorkItem,
        (PIO_WORKITEM_ROUTINE)ChDestroyChannelWorkItem,
        DelayedWorkQueue,
        0i64);

}
void __fastcall ParentReleaseInterruptResources(PVOID Channel)
{
//这里也会调用 XPartDeref
 XPartDeref(Channel);
}
void __fastcall ChpDestroyChannel(PVOID P)
{
  XPartDeref(*((_QWORD *)P + 26));
}
//通道析构时会对分区会加引用一次解引用三次
void __fastcall ChDestroyChannelWorkItem(PDEVICE_OBJECT DeviceObject, PVOID Context)
{
//加引用一次
 _InterlockedIncrement64((volatile signed __int64 *)(Channel + 0x88)) <= 1
//call ChDereferenceChannelInternal and ParentReleaseInterruptResources
ChpDestroyChannel(Channel);
 XPartDeref(Channel);
}
void __fastcall XPartDeref(__int64 Channel)
{
  signed __int64 v1; // rax
  bool v2; // cc
  signed __int64 v3; // rax
  //+0x88是引用计数字段
  v1 = _InterlockedExchangeAdd64((volatile signed __int64 *)(Channel + 0x88), 0xFFFFFFFFFFFFFFFFui64);
  v2 = v1 <= 1;
  v3 = v1 - 1;
  if ( v2 )
  {
  //
  导致最后的引引用次数会变成负数-1
    if ( v3 )
      __fastfail(0xEu);
  }
}
```

当运行在虚拟机中的程序通过hypercall类型HvCallPostMessage向运行在Hyper-V根分区的vmbus通道提供程序Virtualization Service Providers (VSP)发送CHANNELMSG\_INITIATE\_CONTACT消息后，vmbusr.sys驱动为将要创建的vmbus通道创建一个新的vmbus通道分区XPart分配给虚拟机。

在这之前虚拟机启动时自带的vmbus服务已经向vsp申请过分区，每个分区独立管理它所属的通道互相并不冲突，所有创建的通道通过一个链表结构维护在win11 23h2的虚拟机上下文偏移量为XPart+3b8，所有可以连接的通道必须是在Hyper-V根分区通过vmbus api向vmbusr.sys驱动申请分配的。

一般是hyper-v集成服务的系统保留通道，或者是host端调用vmbuspiper.dll的api手动申请的通道，所有通道的CLASSID和INSTANCEID会在CHANNELMSG\_OFFERCHANNEL回调sint消息中在synic\_message页面通知虚拟机中的Virtualization Service Consumers(vsc)程序，之后vsc可以创建并映射gpadl共享页面和vsp建立vmbus通道通信，具体细节可以参考笔者之前的vmbus通道相关文章。

复现此漏洞并不需要产生实际的通道通信，只需要建立通道并在uefi程序中调用\_\_fastfail触发重置虚拟机就能复现漏洞，笔者使用的通道是hyper-v自带的集成服务Hyper-V Data Exchange Service (KVP)通道默认配置下启用可以复现，在默认情况下不管的通道的建立还是创建通信或者是销毁通道的相关操作引用与解引用次数都是对称的，当vsc客户端发送CHANNELMSG\_GPADL\_TEARDOWN和CHANNELMSG \_CLOSECHANNEL消息以触发与通道关联的资源被释放时，通常会对通道进行解引用，当通道的解引用次数降为0后会调用通道销毁例程，在销毁例程会解引用通道所在的分区，分区的解引用次数降为0后会调用分区销毁例程，直到完成整个虚拟机资源释放。

这里有个检查是当分区的解引用次数降为0继续解引用，这个引用次数会变成负数-1导致进入内核崩溃断言\_\_fastfail的拒绝服务结果。一般情况下虚拟机退出时分区销毁例程调用完成后引用次数解引用为0，导致这个现象出现只存在于虚拟机重置后对分区的复用这个不安全的调用中，在win11 23h2及以下的版本中虚拟机重置后所有分配的分区并没有真正的销毁。

也就是说没有移出虚拟机对象的分区链表，而是再次复用并调用一次多余的解引用，导致分区的引用与解引用次数不一致，在虚拟机重置恢复运行后这个复用的分区再次分配给虚拟机资源，但这些重新分配的分区和通道引用计数还是正常的受影响的还是那一次多余的解引用。

当关闭虚拟机时所有的引用析构后这多余的一次解引用会将分区引用次数会变成负数-1导致拒绝服务，而在win11 24h2版本中虚拟机重置后所有分配的分区自动析构所有相关联对象并移出链表，这样就不存在复用和多余的解引用漏洞，因此笔者的漏洞不能在win11 24h2版本中复现。下面我们通过逆向代码了解一下漏洞的成因。

## CVE-2024-43633漏洞逆向分析

```
//在win11 23h2逆向代码
00 ffffbb0f`5a82ee30 fffff803`3e0b888b     vmbusr!XPartDeref+0x11
01 ffffbb0f`5a82ee60 fffff803`3e0d7f62     vmbusr!XPartRemovePartition+0x1bb
02 ffffbb0f`5a82eec0 fffff803`3e0d6bb7     vmbusr!ChResetPartition+0x5e
03 ffffbb0f`5a82eef0 fffff803`3e0aea6a     vmbusr!RootIoctlVdevReset+0xe3
04 ffffbb0f`5a82ef30 fffff803`26dfe7b8     vmbusr!RootIoctlDeviceControlPreprocess+0xea
//虚拟机重置会调用,关闭虚拟机也会调用
void __fastcall XPartRemovePartition(LIST_ENTRY *SubPartcreated, __int64 a2, __int64 a3)
{
bool __fastcall XPartIsSubPartition(__int64 a1)
{
  return *(_QWORD *)(a1 + 0x4F0) != 0i64;
}
  if ( SubPartcreated.SubPartition_4f0 )
  {
    if ( prevpartitionlinkptr )
      goto pengding;
  }
  else if ( prevpartitionlinkptr )
  {
    // (SubPart + 8)+0,prevpartitionlinkptr
    if ( prevpartitionlinkptr->Blink != SubPartcreated
      || (prevpartitionlinkptrnext = SubPartcreated->Blink, prevpartitionlinkptrnext->Flink != SubPartcreated) )
    {
LABEL_12:
      __fastfail(3u);
    }
    prevpartitionlinkptrnext->Flink = prevpartitionlinkptr;
    prevpartitionlinkptr->Blink = prevpartitionlinkptrnext;
    SubPartcreated->Flink = 0i64;
  }
  pengding:
  ...
  //解引用
   XPartDeref((__int64)SubPartcreated);
}

//在win11 24h2逆向代码
void __fastcall XPartRemovePartition(LIST_ENTRY *thispart, __int64 a2, __int64 a3)
{
if ( thispart->Flink )
  {
    // removeentryPLIST_ENTRY
    if ( thisFlink->Blink != thispart )
      goto LABEL_13;
    thisBlink = thispart->Blink;
    if ( thisBlink->Flink != thispart )
      goto LABEL_13;
    thisBlink->Flink = thisFlink;
    thisFlink->Blink = thisBlink;
  }
   }
  // +378parentpart
  // bool __fastcall XPartIsSubPartition(__int64 a1)
  // {
  //   return *(_QWORD *)(a1 + 0x378) != 0i64;
  // }
  parentpart = thispart[0x37].Blink;
  if ( parentpart )
  {
    linkpart368ptr = (_LIST_ENTRY *)((char *)parentpart + 0x368);
    linkpart368ptrFlink = linkpart368ptr->Flink;
    if ( linkpart368ptr->Flink->Blink == linkpart368ptr )
    {
      thispart->Flink = linkpart368ptrFlink;
      thispart->Blink = linkpart368ptr;
      linkpart368ptrFlink->Blink = thispart;
      linkpart368ptr->Flink = thispart;
      goto pendging;
    }
LABEL_13:
    __fastfail(3u);
  }
  pengding:
  ...
  //解引用
   XPartDeref((__int64)SubPartcreated);
}
```

通过上面的逆向代码可以看出在win11 23h2版本中与虚拟机重置后移除分区的逻辑如果要移除分区SubPartition\_4f0是个有效的指针，会直接跳出if和else代码块，并没有进入后面的else分支将当前分区没有移出分区链表，导致虚拟机重置后时会再次调用这个函数对复用的分区再次分配给虚拟机，并再次调用XPartDeref多解引用一次导致分区的引用与解引用次数不一致。

而在win11 24h2中XPartRemovePartition直接将当前分区移出链表尽管有对子分区的判断，但是因为分区已经被移出链表了，就不存在复用的情况，自然也不存在多余的解引用漏洞。

## CVE-2024-43633漏洞调试分析

```
//先下断点
3: kd>bp  vmbusr!XPartDeref; ba w1 rcx+88  " r;k;r $t1=rcx+3b8;r $t2=$t1; dc $t2-3b8+88;r $t1=poi($t1); .for(r $t3=0;$t1 > $t2 or $t1 < $t2;r $t3=$t3+1){r $t1=poi($t1); };.printf \"%p Channel count %p\r\n\",$t2-3b8+88, $t3;gc"

//正常析构时分区引用次数为通道的数量*2次引用次数数加上分区本身的一次引用1e=e*2+1+1
rax=ffffe60151627928 rbx=ffffe60151627850 rcx=000000000000001d
rdx=ffffe60151627928 rsi=ffffe6014ff9c0e8 rdi=ffffe6015125a000
rip=fffff8033e0b1a76 rsp=ffffbb0f55517200 rbp=0000000000000000
 r8=fffff8033e0c6780  r9=ffffe60151627928 r10=fffff8033e0b1a20
r11=0000000000000000 r12=ffffe6012e9f43b0 r13=ffffe6012ff8d000
r14=fffff8033e0b1a20 r15=fffff80322403980
iopl=0         nv up ei pl nz na po nc
cs=0010  ss=0018  ds=002b  es=002b  fs=0053  gs=002b             efl=00040206
vmbusr!ChDestroyChannelWorkItem+0x56:
fffff803`3e0b1a76 48ffc1          inc     rcx
 # Child-SP          RetAddr               Call Site
00 ffffbb0f`55517200 fffff803`22403a80     vmbusr!ChDestroyChannelWorkItem+0x56
01 ffffbb0f`55517250 fffff803`22552315     nt!IopProcessWorkItem+0x100
02 ffffbb0f`555172c0 fffff803`22554d07     nt!ExpWorkerThread+0x155
03 ffffbb0f`555174b0 fffff803`2261ae24     nt!PspSystemThreadStartup+0x57
04 ffffbb0f`55517500 00000000`00000000     nt!KiStartSystemThread+0x34
//分区引用计数
ffffe601`5125a088  0000001e 00000000 00050000 00050003  ................
ffffe601`5125a098  00000000 00000000 00000000 00000000  ................
ffffe601`5125a0a8  00000000 00000000 b0cad258 000019fe  ........X.......
ffffe601`5125a0b8  4fae8000 ffffe601 4ff8fd60 ffffe601  ...O....`..O....
ffffe601`5125a0c8  00020101 000002e0 00000000 00000000  ................
ffffe601`5125a0d8  00000000 00000000 4ea30000 ffffe601  ...........N....
ffffe601`5125a0e8  00000000 00000000 00000000 00000000  ................
ffffe601`5125a0f8  00000000 00000000 00000000 00000000  ................
//通道引用计数
ffffe6015125a088 Channel count 000000000000000e

//虚拟机重置后引用次数比正常少了1
rdx=0000000000000001 rsi=ffffe6014ea30000 rdi=0000000000000000
rip=fffff8033...