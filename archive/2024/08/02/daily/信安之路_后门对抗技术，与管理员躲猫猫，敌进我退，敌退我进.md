---
title: 后门对抗技术，与管理员躲猫猫，敌进我退，敌退我进
url: https://mp.weixin.qq.com/s?__biz=MzI5MDQ2NjExOQ==&mid=2247499530&idx=1&sn=e68c15f49398bf1120b6d36bb16ee36a&chksm=ec1dcf22db6a463491e997033d5fbedc6b8638641cfc0190b196e83329d8ae269c543fc995b3&scene=58&subscene=0#rd
source: 信安之路
date: 2024-08-02
fetch_date: 2025-10-06T18:03:16.040085
---

# 后门对抗技术，与管理员躲猫猫，敌进我退，敌退我进

![cover_image](https://mmbiz.qpic.cn/mmbiz_jpg/sGfPWsuKAfficMZicZumUEkmkNavNqy6iaahVrN25Mq6gYDIEn5jO4IB8pKXGUA2CIichsqBrse9aMibQnV0f3dxtvg/0?wx_fmt=jpeg)

# 后门对抗技术，与管理员躲猫猫，敌进我退，敌退我进

信安之路

以下文章来源于NOP Team
，作者NOP Team

![](http://wx.qlogo.cn/mmhead/Q3auHgzwzM6K7BscJ2NDJk9qyHicAcWbGDib8p30BNlxspq0YjvQib3uQ/0)

**NOP Team**
.

有态度，不苟同 No System Is Safe！

在介绍原理之前，先来看一下实战效果，模拟挖矿程序在系统运行，当管理员登入后，停止运行，管理员退出时启动挖矿脚本，说干就干。

### 1. 模拟挖矿程序

建一个名为 `miner.sh` 的脚本，模拟一个挖矿程序

```
#!/bin/bash
# 模拟一个长时间运行的挖矿程序while true; do  echo "Mining..."  sleep 5done
```

添加执行权限

> chmod +x miner.sh

![](https://mmbiz.qpic.cn/sz_mmbiz_png/fZT30hrVgRf196p0aHEMmkLmqXpbeoKF6K3FVpBxzmaDBdQPvXUdJp56snxY2ZEfM3S1LdhfPV6aHsez2zclHA/640?wx_fmt=other&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

### 2. 编写停止挖矿脚本

我们可以直接写入到配置文件中，但是为了演示清晰，还是单独弄一个脚本

```
stop_miner.sh#!/bin/bash
# 获取 miner.sh 的 PID 并终止它PID=$(pgrep -f miner.sh)if [ -n "$PID" ]; then  echo "Stopping miner.sh (PID: $PID)"  kill $PIDelse  echo "miner.sh is not running"fi
```

添加执行权限

> chmod +x stop\_miner.sh

![](https://mmbiz.qpic.cn/sz_mmbiz_png/fZT30hrVgRf196p0aHEMmkLmqXpbeoKFcJeRPVYvZ8Yvh1gruNiceEuAKVknISoC7ejhRvxvOwLFicz6NVJHr2og/640?wx_fmt=other&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

### 3. 编写开启挖矿的脚本

```
start_miner.sh#!/bin/bash
# 启动 miner.shecho "Starting miner.sh"./miner.sh &
```

添加执行权限

> chmod +x start\_miner.sh

![](https://mmbiz.qpic.cn/sz_mmbiz_png/fZT30hrVgRf196p0aHEMmkLmqXpbeoKF0AFwWchNbxiaypibfzGDEaloWCOL2h8TtFBor1kz1yCTicyyuDiaamvyWQ/640?wx_fmt=other&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

### 4. 修改管理员的 Shell 配置文件

我们修改 `root` 的配置文件，之后使用普通用户来观察挖矿程序执行情况

`EXIT` 信号是 Bash 内部的一种机制，用于表示脚本或会话的正常结束

```
/root/.bashrc
```

![](https://mmbiz.qpic.cn/sz_mmbiz_png/fZT30hrVgRf196p0aHEMmkLmqXpbeoKFzdCt0Z4zV4xAnv3zCg5JIibVxb4Quc4spkWlYdHTyAoP1YM7fM4N60A/640?wx_fmt=other&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

### 5. 开始实验

使用普通用户观察挖矿程序的进程情况

#### 【 root 登录 】

![](https://mmbiz.qpic.cn/sz_mmbiz_png/fZT30hrVgRf196p0aHEMmkLmqXpbeoKFxJ8HvrqAGIR9nya4I94A59K7yWKYhUxc6UiaK67PlcfggVskcRT85mA/640?wx_fmt=other&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

此时使用普通用户查看相关挖矿进程

![](https://mmbiz.qpic.cn/sz_mmbiz_png/fZT30hrVgRf196p0aHEMmkLmqXpbeoKFefRlIPSF6fLFun7vdpW1Xxsb0RSeicFb66YXE0wtES7pFf1QGVP1x6A/640?wx_fmt=other&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

并不存在我们设置的挖矿进程

#### 【 root 退出登录 】

![](https://mmbiz.qpic.cn/sz_mmbiz_png/fZT30hrVgRf196p0aHEMmkLmqXpbeoKFo5G3ExgzbqAe4GrMNFxibXUZAO3pc7Qf3XkribXpkHNM5ib8dXnVXyicpw/640?wx_fmt=other&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/fZT30hrVgRf196p0aHEMmkLmqXpbeoKFej2UIxeraHvQ0aBT08YdXdnKqdOdQ8n0hqQVnBjRjUvHTVoibRKTSVQ/640?wx_fmt=other&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

可以看到，root 退出登录后，挖矿病毒开始运行

#### 【 root 再次登录 】

![](https://mmbiz.qpic.cn/sz_mmbiz_png/fZT30hrVgRf196p0aHEMmkLmqXpbeoKFpRhcAsIKLqsSyJzXpED5QAsb5CzRE2siaWTzGvQ0IjecnEDbf2k6DeA/640?wx_fmt=other&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/fZT30hrVgRf196p0aHEMmkLmqXpbeoKFnI6RHGQcibAiaJSbjsLEiaJlicxOVQjbMjnJgey4CJWvnxNJ8z1MNVDC0Q/640?wx_fmt=other&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

可以看到挖矿进程又没了(进程终止了)

#### 【 root 再次退出登录 】

![](https://mmbiz.qpic.cn/sz_mmbiz_png/fZT30hrVgRf196p0aHEMmkLmqXpbeoKFkxbf9ib7WjHLEDhIoDDWCrDOLFJ2LKicxx1C30v7KUzmgUtickiaiadX80w/640?wx_fmt=other&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/fZT30hrVgRf196p0aHEMmkLmqXpbeoKFCrwpdLWMvAhKCPxUIb6qVCnTicuagib2L1KoiatWr8uicOrrkmLMkKiaf6g/640?wx_fmt=other&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

挖矿进程再次出现，**成功完成了与管理员的躲猫猫**。

### 6、原理介绍

`trap` 命令是 Unix 和 Linux 系统中用于处理信号（signals）的一个命令。信号是由操作系统或其他程序发给进程的一种通知，用于请求进程执行某些操作或进行某种处理。`trap` 命令允许在接收到特定信号时执行自定义的命令或脚本，从而实现灵活的信号处理机制。

#### 语法格式

> trap 'commands' signals

* `commands`：在接收到指定信号后要执行的命令或脚本。
* `signals`：要捕获和处理的信号列表。信号可以用名字（如 `SIGHUP`、`SIGINT`）或对应的信号编号表示

#### Trap 信号

`trap` 能够处理哪些信号呢？

`trap` 一共就两个参数，其中 `-l` 可以显示支持处理的信号

> trap -l

![](https://mmbiz.qpic.cn/sz_mmbiz_png/fZT30hrVgRf196p0aHEMmkLmqXpbeoKFEMT2wcQ4jxXzu1C4eGYXweD9y1EMs6miaIhibTkhQfzpdOAqYGEYumBA/640?wx_fmt=png&from=appmsg&wxfrom=13)

```
 1) SIGHUP   2) SIGINT   3) SIGQUIT  4) SIGILL   5) SIGTRAP 6) SIGABRT  7) SIGBUS   8) SIGFPE   9) SIGKILL 10) SIGUSR111) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP21) SIGTTIN 22) SIGTTOU 23) SIGURG  24) SIGXCPU 25) SIGXFSZ26) SIGVTALRM 27) SIGPROF 28) SIGWINCH  29) SIGIO 30) SIGPWR31) SIGSYS  34) SIGRTMIN  35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+338) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+843) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+1348) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-1253) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-758) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-263) SIGRTMAX-1  64) SIGRTMAX
```

这其中比较常见的信号如下：

* `SIGHUP` (1)：挂起信号，通常在终端关闭时发送。
* `SIGINT` (2)：中断信号，通常由 Ctrl+C 组合键发送。
* `SIGTERM` (15)：终止信号，用于请求程序正常终止。
* `SIGKILL` (9)：强制终止信号，无法捕获或忽略。
* `SIGQUIT` (3)：退出信号，通常由 Ctrl+\ 组合键发送。

#### Trap 命令

通过 `trap` 将命令(command)绑定在特定的一些信号上，当接收到对应信号后，将会执行绑定的命令

查看已经绑定的命令:

> trap -p

![](https://mmbiz.qpic.cn/sz_mmbiz_png/fZT30hrVgRf196p0aHEMmkLmqXpbeoKFKluvxj54IxjwU5lzXYoOgZs4vs4OJYiabJYmSGSiacarD5EjBIcSxGoA/640?wx_fmt=other&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

在 `trap` 命令的 `command` 部分，可以使用几乎任何有效的 Shell 命令或一组命令。以下是一些常见形式的内容：

1. 单一命令

> trap 'echo "SIGINT received"' SIGINT

2. 多个命令

可以使用分号（`;`）或逻辑运算符（如 `&&` 或 `||`）连接多个命令

> trap 'echo "SIGINT received"; cleanup && exit' SIGINT

3. Shell 函数

可以定义一个函数，然后在 `trap` 中调用这个函数

```
cleanup() {    echo "Cleaning up..."    # 清理操作}
trap cleanup SIGINT
```

4. **复杂命令块**

可以使用花括号 `{}` 包含一组命令，形成一个命令块

> trap '{ echo "SIGINT received"; cleanup; exit; }' SIGINT

5. **执行脚本**

你可以调用外部脚本来处理信号。例如：

> trap '/path/to/your\_script.sh' SIGINT

6. **命令替换**

你可以使用命令替换（command substitution）来动态生成要执行的命令

> trap "$(echo 'echo SIGINT received; exit')" SIGINT

7. **条件语句**

可以在 `trap` 命令中使用条件语句（如 `if`，`case`）

> trap 'if [ -f /tmp/flag ]; then echo "Flag is set"; else echo "No flag"; fi' SIGINT

8. 忽略语句

可以将命令设置为空字符串，这样信号就会被忽略，什么都不做（影响系统默认对信号的处理，也就是真正意义上的什么都不做）

> trap '' SIGINT

9. 恢复默认

> trap - SIGINT

通过 `trap -` 可以将信号处理恢复为默认行为

#### Trap 作用范围

`trap` 作用范围是怎样的呢？

* 系统级？
* 用户级？
* 进程树级？
* 进程级？

在 bash 中进行如下配置，设置 `trap` 命令捕获 SIGINT 信号（`Ctrl+C`）

> trap 'echo "SIGINT received"' SIGINT

![](https://mmbiz.qpic.cn/sz_mmbiz_png/fZT30hrVgRf196p0aHEMmkLmqXpbeoKFaLmLicoL0h5fvK4NfebgOOpTDEW9Znxfdatj0IpNLxdcBoR1FThWBWQ/640?wx_fmt=other&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

之后输入  `Ctrl+C` 观察一下效果

![](https://mmbiz.qpic.cn/sz_mmbiz_png/fZT30hrVgRf196p0aHEMmkLmqXpbeoKFVzkt0r4HWYT1vVn7eNODv1bb6Y6mNjzrdY3ThqCw90YbYFoueg9RFw/640?wx_fmt=other&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

退出当前会话，再次登录测试

![](https://mmbiz.qpic.cn/sz_mmbiz_png/fZT30hrVgRf196p0aHEMmkLmqXpbeoKFa3srPv1NIC5MQbwE4LreEjtsmy2pulOgG7ndDKJr0Vz3RtJlH3ia0cg/640?wx_fmt=other&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

可以看到，再次登录相同系统、相同用户后，之前设置的 trap 就不见了，也没有任何效果了

因此 trap 的作用范围不是系统级，也不是用户级，接下来测试在已经设置了 trap 的 bash 进程中再开启一个 bash ，看看父进程的 trap 会不会传递给子进程

![](https://mmbiz.qpic.cn/sz_mmbiz_png/fZT30hrVgRf196p0aHEMmkLmqXpbeoKFAmGFZUvasLGhMgHlzGstbkvPZQVMT3VC5ZRHxZHtTCfT3zJeoC2onQ/640?wx_fmt=other&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

实验证明，`trap` 的作用范围就是在进程级，不会传递给子进程

#### Trap 是否影响默认行为

默认情况下，我们 `Ctrl+C` 是传递 `SIGINT` 信号，终止进程，那如果我们设置 `Trap`，默认的终止进程的效果还存在吗？

我们使用一个脚本来进行测试

```
#!/bin/bash
trap 'echo "SIGINT received, but I will not exit!"' SIGINT
echo "Running script. PID: $$"while true; do    sleep 1done
```

脚本捕获 `Ctrl+C` 信号，并输出特定信息，脚本一直循环，我们看一下我们执行后，是否可以通过 `Ctrl+C` 进行终止

![](https://mmbiz.qpic.cn/sz_mmbiz_png/fZT30hrVgRf196p0aHEMmkLmqXpbeoKF0icDRaHDvZmhvBpGL8iaulBPKvvpqMH1qIXy...