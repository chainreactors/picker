---
title: 微信4.0聊天记录数据库文件解密分析
url: https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458584587&idx=1&sn=bd672102f10e062f90cd9276a1d2ca2f&chksm=b18c368186fbbf971c94b8c1ff5aa3460e81079ace27c66b897bb8b03ab4f35a74c45888ba97&scene=58&subscene=0#rd
source: 看雪学苑
date: 2024-12-01
fetch_date: 2025-10-06T19:36:50.857279
---

# 微信4.0聊天记录数据库文件解密分析

![cover_image](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8EEoP87icqNvOd9jAibJHwnO4nN5iawSEJz4ODwiaLtk5F1SYGztfWfia5rK7g9xV0kk4mJRWaT7h5YeiaQ/0?wx_fmt=jpeg)

# 微信4.0聊天记录数据库文件解密分析

techliu

看雪学苑

**1**

**工具介绍**

代码仓库：https://github.com/0xlane/wechat-dump-rs

微信4.0的数据库解密已在工具中实现，寻找方式依然是暴力搜索。

工具支持：

◆导出已登录微信进程的 db key

◆通过指定 key 离线解密微信数据库文件

◆将 db key 转为 sqlcipher 原始密钥

具体使用方式参考README.md（*https://github.com/0xlane/wechat-dump-rs/blob/v4/README.md*）

**2**

**库表结构**

4.0.0.26（*https://github.com/0xlane/wechat-dump-rs/blob/v4/docs/wechat\_4\_0\_0\_26\_table\_struct.md*）

**3**

**微信4.0分析记录**

要定位 key 的位置之前肯定先要找到真实的 key ，下面简单记录一下寻找过程。使用微信版本 4.0.0.26 进行分析。

数据文档存储位置发生变化：`C:\Users\xxx\Documents\xwechat_files\wxid_xxxxx\db_storage`，且不可修改。

进程名从 Wechat.exe 变化为 Weixin.exe，关键 DLL 从 WeChatWin.dll 变化为 Weixin.dll，微信将很多库静态编译成这1个文件所以很大，IDA打开都要解析很久才行。

先说一下取巧的简单办法，根据之前版本微信找 key 经验，可以使用 CE 在内存中搜索`SetDBKey`就可以定位到一个日志打印的位置，这个位置所在的函数就是`SetDBKey`函数，第二个参数就是 key 指针。（ps：可以观察一下指针周围有什么可以用于定位的特征）

下面说复杂方法，因为微信使用的是WCDB*（https://github.com/Tencent/wcdb/）*，WCDB 算是 sqlcipher 和 sqlite 定制，所以根据https://github.com/Tencent/wcdb/wiki/C++-加密与配置*（https://github.com/Tencent/wcdb/wiki/C++-%E5%8A%A0%E5%AF%86%E4%B8%8E%E9%85%8D%E7%BD%AE）*可知微信内部应该需要调用`setCipherKey`进行加密配置，所以如果能定位到这个函数就可以找到 key。

直接定位这个函数尝试了下并不好找，另外Weixin.dll里的一些代码还是混淆的，但还是要往简单了想，继续找特征字符串定位一些关键函数，通过看源码找`setCipherKey`调用的函数，一层层向下找一直找到一个能定位的位置然后倒推回来。如果实在没办法定位它，就尝试定位它附近的函数，一般编译后也都在一起。

大致思路是这样。实际过程中，我先去找`sqlite3_exec`去了，想看一下微信执行的 sql 语句。

按上面思路对`sqlite3_exec`定位，内部没有明显字符串，比较幸运的是函数开头调用的`sqlite3SafetyCheckOk`里面有个字符串 "unopened" 在内存中直接定位到了有且仅有一个的位置`Weixin.dll+410BDCB`，该位置必然是`sqlite3SafetyCheckOk`：

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8HZ1qpdHbJnLTL6CddicV04gBqvN0mHCMKgibvBbYIxVYxhTLNkHTn7R6KrqePJbicC7mor1GK3kfeFA/640?wx_fmt=jpeg&from=appmsg)

转到 IDA 中找所有交叉引用，只有 52 个，可以挨个看过去：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HZ1qpdHbJnLTL6CddicV04gSKrXlnHXoEZniaic0ic9eh1riby8CjF3ow44uR52ZvGxmeC1DCicjwAQ4oA/640?wx_fmt=png&from=appmsg)

在里面找到最像`sqlite3_exec`的：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HZ1qpdHbJnLTL6CddicV04gPF3DZX4O2q38klVBZqFggJ68jwHzabDCrKMiaQbTVIRhfGIT13cA2NQ/640?wx_fmt=png&from=appmsg)

然后对照源码将 sqlite3\_exec 调用的函数一一定位，还可以找到几个比较关键的函数：

◆`sqlite3_prepare_v2`

◆`sqlite3_column_count`

◆`sqlite3_column_name`

◆`sqlite3_column_text`

然后找到这几个又能找出一片，不一一列举了。

现在在 windbg 里对`sqlite3_exec`下断点，监控后发现和想象中的不一样，只有一两个固定的语句经过`sqlite3_exec`执行：

```
0:059> bp weixin+0x4602e50 ".printf \"%ma\\n\", rdx;"
0:059> g
ModLoad: 00007ff9`78030000 00007ff9`780b3000   C:\Windows\System32\fwpuclnt.dll
ModLoad: 00007ff9`78360000 00007ff9`7836a000   C:\Windows\System32\rasadhlp.dll
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid
Weixin!GetHandleVerifier+0x3c40f90:
00007ff8`d0d22e50 4157            push    r15
0:021> g
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid
Weixin!GetHandleVerifier+0x3c40f90:
00007ff8`d0d22e50 4157            push    r15
0:021> g
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid
Weixin!GetHandleVerifier+0x3c40f90:
00007ff8`d0d22e50 4157            push    r15
```

所以微信并不直接通过`sqlite3_exec`执行 sql，此时对`sqlite3_prepare_v2`下断比较有用，基本执行的所有语句都会经过这个函数：

```
0:025> g
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid
Weixin!GetHandleVerifier+0x3746d00:
00007ff8`d0828bc0 4883ec38        sub     rsp,38h
0:025> g
PRAGMA checkpoint_fullfsync = TRUE
Weixin!GetHandleVerifier+0x3746d00:
00007ff8`d0828bc0 4883ec38        sub     rsp,38h
0:025> g
PRAGMA temp_store = 1
Weixin!GetHandleVerifier+0x3746d00:
00007ff8`d0828bc0 4883ec38        sub     rsp,38h
0:025> g
PRAGMA cipher_compatibility = 4
Weixin!GetHandleVerifier+0x3746d00:
00007ff8`d0828bc0 4883ec38        sub     rsp,38h
0:025> g
PRAGMA cipher_page_size = 4096
Weixin!GetHandleVerifier+0x3746d00:
00007ff8`d0828bc0 4883ec38        sub     rsp,38h
0:025> g
PRAGMA journal_mode
Weixin!GetHandleVerifier+0x3746d00:
00007ff8`d0828bc0 4883ec38        sub     rsp,38h
0:025> g
SELECT name, rootpage, sql FROM "main".sqlite_master ORDER BY rowid
Weixin!GetHandleVerifier+0x3746d00:
00007ff8`d0828bc0 4883ec38        sub     rsp,38h
0:025> g
PRAGMA checkpoint_fullfsync = TRUE
Weixin!GetHandleVerifier+0x3746d00:
00007ff8`d0828bc0 4883ec38        sub     rsp,38h
```

可以看到一些 sqlcipher 配置参数：

```
PRAGMA journal_mode
PRAGMA cipher_compatibility = 4
PRAGMA cipher_page_size = 4096
PRAGMA checkpoint_fullfsync = TRUE
PRAGMA temp_store = 1
```

根据`cipher_compatibility = 4`可知新版微信使用的是 sqlcipher4，其他参数没怎么变基本默认。然后这时候已经可以使用之前快速方法找到的 key 尝试解开数据库了。

通过这个函数能观察到要执行的所有语句，但是并不能拿到执行结果。比如期间看到一个比较有意思的查询语句想看一下查询结果：

```
SELECT 1 FROM main.LoginKeyInfoTable LIMIT 1
PRAGMA main.table_info('LoginKeyInfoTable')
CREATE UNIQUE INDEX IF NOT EXISTS LoginKeyInfoTable_USER_KEYINFO ON LoginKeyInfoTable(user_name_md5, key_info_md5)
COMMIT
SELECT user_name_md5, key_md5, key_info_md5, key_info_data FROM main.LoginKeyInfoTable WHERE user_name_md5 == '963a71084510983d212311f24bfdea5a9d' ORDER BY rowid DESC LIMIT 1
```

此时需要监控`sqlite3_column_text`，从返回值中就可以拿到每列值内容：

```
0:021> g
SELECT user_name_md5, key_md5, key_info_md5, key_info_data FROM LoginKeyInfoTable WHERE user_name_md5 == '963a71084510983d212311f24bfdea5a9d' ORDER BY rowid DESC LIMIT 1
Weixin!GetHandleVerifier+0x3746d00:
00007ff8`d0828bc0 4883ec38        sub     rsp,38h
0:016> bp weixin+4107110
0:016> g
Breakpoint 1 hit
Weixin!GetHandleVerifier+0x3745250:
00007ff8`d0827110 56              push    rsi
0:016> gu;da rax
00000237`74852030  "963a71084510983d212311f24bfdea5a9d"        // user_name_md5
00000237`74852050  ""
0:016> g
Breakpoint 1 hit
Weixin!GetHandleVerifier+0x3745250:
00007ff8`d0827110 56              push    rsi
0:016> gu;da rax
00000237`7484b460  ""                                          // key_md5
0:016> g
Breakpoint 1 hit
Weixin!GetHandleVerifier+0x3745250:
00007ff8`d0827110 56              push    rsi
0:016> gu;da rax
00000237`7484b910  "6d4196fc4b3183a88692bde4e82966db"           // key_info_md5
00000237`7484b930  ""
```

但是你会发现拿不到`key_info_data`值，因为它是 BLOB 类型，`sqlite3_column_text`只能看到 TEXT 类型值，所以对于不同的值需要监控不同的 sqlite3 接口：

```
bp weixin+4108bc0 ".printf \"%ma\\n\", rdx;"
bp weixin+4602e50 ".printf \"%ma\\n\", rdx;"
bp weixin+4106f30
bp weixin+4107010 "gu;db rax;"
bp weixin+4107040 "gu;db rax;"
bp weixin+4107070
bp weixin+41070B0
bp weixin+41070E0
bp weixin+4107110
bp weixin+4107140
```

刚开始我以为这个`key_info_data`里就是 db key，发现并不是，login key 和 db key 是不一样的，login key 每次登录都会变化，db key 重新登录不会变。

此时已经扯远了，继续想办法定位`setCipherKey`。

`setCipherKey`中实际调用的是`innerDatabase->setConfig`：

```
void Database::setCipherKey(const UnsafeData& cipherKey, int cipherPageSize, CipherVersion cipherVersion)
{
    if (cipherKey.size() > 0) {
        m_innerDatabase->setConfig(
        CipherConfigName,
        std::static_pointer_cast<Config>(std::make_shared<CipherConfig>(
        cipherKey, cipherPageSize, cipherVersion)),
        Configs::Priority::Highest);
    } else {
        m_innerDatabase->removeConfig(CipherConfigName);
    }
}
```

我注意到传给`setConfig`的第一个参数是`CipherConfigName`，它是一个定值：`com.Tencent.WCDB.Config.Cipher`，在`CoreConst.cpp`中被初始化。

该字符串在内存中有且仅有一处：

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8HZ1qpdHbJnLTL6CddicV04guU4P0PVSNagltAc6fVE8Ca5MWiacaicYwH4ib3TDmKecdCtXO0afT99HQ/640?wx_fmt=jpeg&from=appmsg)

由此在 IDA 中找到对应位置在`.data`区域：

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8HZ1qpdHbJnLTL6CddicV04gSiaBiahFrxJajPScYNFdEbfnM5qfYvNKTgEO65CLfQVzfLyDKgD8hj3g/640?wx_fmt=jpeg&from=appmsg)

交叉引用只有2处，实际是在一起，该位置就是`CoreConst`文件范围，可以看到我标记的`com_Tencent_WCDB_Config_Cipher`才是真正的全局变量`CipherConfigName`：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HZ1qpdHbJnLTL6CddicV04gX90Yqs9eem8dpfhfXx9nB2Stc4LMQ6ymWO8PU4l6n124gV9I57SMdQ/640?wx_fmt=png&from=appmsg)

然后找它的交叉引用，也仅有4处而已：

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8HZ1qpdHbJnLTL6CddicV04gf94gmMoepZVut68wYIIAv2no9lxBFCXiaG6DvWsibU6fHhPVgOibGX2wA/640?wx_fmt=jpeg&from=appmsg)

因为 c++ 类调用的原因，调用`setConfig`时，`CipherConfigName`实际是第二个参数，也就是说和`RDX`有关，从上图也能直观看...