---
title: 2024 KCTF 大赛 | 第六题《异星文明》设计思路及解析
url: https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458569936&idx=1&sn=94431185e5dcff1344fba864a2043436&chksm=b18dfc5a86fa754ceac89be21f3462918ad74052c6f29b7aff5d2d3e377af0e743bbbe0e08bd&scene=58&subscene=0#rd
source: 看雪学苑
date: 2024-08-29
fetch_date: 2025-10-06T18:04:47.041323
---

# 2024 KCTF 大赛 | 第六题《异星文明》设计思路及解析

![cover_image](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8Gb5CwDibtC2z0wz9WZPnQLf7Jz7yZbCkkTStWHRLbKXQWibZHbC26F46icCuib03rCReMblWYMGlfXcg/0?wx_fmt=jpeg)

# 2024 KCTF 大赛 | 第六题《异星文明》设计思路及解析

原创

2024 KCTF

看雪学苑

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8Gb5CwDibtC2z0wz9WZPnQLfCYeucIE8ibAS8Ciablmia6icXZkyLtcG4ic7qn6NWibBMQRXdP8fzDwdlt4w/640?wx_fmt=jpeg&from=appmsg)

2024 KCTF 大赛于8月15日正式开赛！比赛设置了多维度的评分体系，包括难度值、火力值和精致度积分，旨在引导竞赛的难度和趣味度，使其更具挑战性和吸引力。同时，也为参赛选手提供了更加公平、有趣的竞赛平台。

今天中午12点，第六题《异星文明》已截止答题，本题围观人数1000+，共有5支战队成功破解，分别是Nepnep、tacesrever、崇文路大专、hzqmwne、雨落星沉。

\*注意：签到题《逐光启航》持续开放，整个比赛期间均可提交答案获得积分

一起来看看本题设计思路和解析吧！

**出题战队：newbiezx**

**战队成员ID：**n00bzx

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Gb5CwDibtC2z0wz9WZPnQLfT8ibf6bamrM4CYzDK4nsoT1WYncBtUXct8ML2TanN25UBelyjvos01Q/640?wx_fmt=png&from=appmsg)

**设计思路**

公开的用户名/密码:

Username：5D39642871C061E7
key：9FF4D2D192B6081530E2C792605EBC939763C5681D4E2AF9366880D4A15B0553

题目答案：
Username：KCTF
Key：901AB07A40D87A7B96ED4B0420EA2B552C9E12C71F9E967E5BEA37A83BC79E1F

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8Gb5CwDibtC2z0wz9WZPnQLfpJTGODAtwib5ZaMVzzKyaK34vpn0v6lT2uje5uk3dkgnEhGGO36h1CQ/640?wx_fmt=other&from=appmsg)

题目名称:智慧中心登录器

题目背景：高中的时候经常偷玩电脑，被智慧中心抓了好几次，今天我搞到了他们的登录程序，看看能不能登录学校官网后台。

混淆器的思路是，准备一个context栈,每次调用指令的时候进入虚拟机，把栈迁移至虚拟空间。调用指令后，退出虚拟机，退出前，将下一条指令的key压入栈，在dispatcher函数中解密下一条指令的opcode，跳往执行下一条指令。

进入函数第一时间保存所有寄存器，依照x64调用约定拷贝参数，全部寄存器入context栈，退出时恢复到上一个函数的context.对于jmp使用直接修改opcode，call则不进入虚拟机，执行完毕第一时间保存返回值并返回到dispatcher，handler象征性地加了一条花指令，每个handler在程序中都分配一块128字节的空间，handler指令的开始位置在空间里是随机的，随机后剩余空间填满一些假的指令bytes。

就这么简单，明年上大学我会加入一些表达式混淆和api混淆。不算难解，之前比赛看到一题类似思路的，也是一个tea算法，但是它没有经过dispatcher分发指令。

给出一种可能解法：

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8Gb5CwDibtC2z0wz9WZPnQLfzjDibxNzFIX4Zbqibahm0OfLpR4X33EEsN44vbumb5ukgBnpQ1rnuu2A/640?wx_fmt=other&from=appmsg)

这是保存寄存器至context：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Gb5CwDibtC2z0wz9WZPnQLfl46L3KaEFlQ2gD0mpRwmvIY54WNA2OyNkrlWtpTHxibdpsGnjjFM6pw/640?wx_fmt=png&from=appmsg)

这是计算函数ctx的地址并压入第一条指令的密钥：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Gb5CwDibtC2z0wz9WZPnQLfpo3cyqNkb29Lsszu2uSMglA09S5T2N0X2ZpyDKwrmwtoPov1WANQyA/640?wx_fmt=png&from=appmsg)

拷贝参数，如果这是第一次进入vm，则初始化虚拟栈和ctx栈：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Gb5CwDibtC2z0wz9WZPnQLfpcyA7ZicrUQHVwa4WsLZwJZ9XvDJlib7l9SXD62DR6ichXGVAmJ9JJWpg/640?wx_fmt=png&from=appmsg)

进入dispatcher，dispatcher代码(汇编和c++混编)：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Gb5CwDibtC2z0wz9WZPnQLfTOxqacIIDoZuFFt5ic9BOZbTibn5EQ5AsAjCI1bXSTUUMorQlibHRzanA/640?wx_fmt=png&from=appmsg)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Gb5CwDibtC2z0wz9WZPnQLfIULmGA56DegczNf4WTPnMrbsjt2r0qeo3icJCqL6meGgcypBTlN0WQQ/640?wx_fmt=png&from=appmsg)

解析版：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Gb5CwDibtC2z0wz9WZPnQLfesyrZZNBsj6eweBlib1RBntvS35e1EmMGzrVIBGicGQahuA7q8A7Gt2w/640?wx_fmt=png&from=appmsg)

进入vm：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Gb5CwDibtC2z0wz9WZPnQLfjK1qMcBpNib5Rsx9sfXIia1LF7ySlNTT85P9PJZssBmHFw8OIrmQdkGg/640?wx_fmt=png&from=appmsg)

退出vm：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Gb5CwDibtC2z0wz9WZPnQLfVv0Zrxch3sTs2oje3sTYjIIX2K6jJDxsZqRwwkTAUG76wkABonqwfA/640?wx_fmt=png&from=appmsg)

恢复符号位，执行原指令，备份符号位，push密钥，再跳往退出虚拟机。

一条一条指令跑下来，就可以恢复原程序(除了jmp和call)，unicorn啥的都行。恢复源程序后，分块解密32轮tea，每块解密两次即可(tea的key来源于sum，参数也有变，不过大同小异)，解密脚本见附件。

keygen脚本：

```
#include<iostream>#include<windows.h>#define getpos(X,N) (((X)>>((N)<<3))&0xFF)const char* zx = "welcome_to_fzbz,my_name_is_sbzx!";const char* sb = "0123456789ABCDEF";void gen(BYTE* N,BYTE* O){    BYTE usn[17] = { 0 };    for (int i = 0; i < 16; i++)    {        usn[i] = N[i] ^ zx[i];    }    BYTE out[0x100] = { 0 };    for (int s = 0; s < 32; s += 8)    {        DWORD sum = *(DWORD*)(usn + 8);        DWORD delta = *(DWORD*)(usn + 12);        DWORD v0, v1;        v0 = *(DWORD*)(zx+s);        v1 = *(DWORD*)(zx + s+4);        for (int i = 0; i < 31; i++)        {            sum += delta;        }        v0 ^= sum;        v1 ^= sum;        for (int i = 0; i < 31; i++)        {            v1 -= ((v0 << 4) + getpos(sum, 2)) ^ (v0 + sum) ^ ((v0 >> 5) + getpos(sum, 1));            sum -= delta;            v0 -= ((v1 << 4) + getpos(sum, 3)) ^ (v1 + sum) ^ ((v1 >> 5) + getpos(sum, 0));        }        sum = *(DWORD*)usn;        delta = *(DWORD*)(usn + 4);        for (int i = 0; i < 31; i++)        {            sum += delta;        }        v0 ^= sum;        v1 ^= sum;        for (int i = 0; i < 31; i++)        {            v1 -= ((v0 << 6) + getpos(sum, 3)) ^ (v0 + sum) ^ ((v0 >> 3) + getpos(sum, 2));            sum -= delta;            v0 -= ((v1 << 6) + getpos(sum, 0)) ^ (v1 + sum) ^ ((v1 >> 3) + getpos(sum, 1));        }        *(DWORD*)(out + s) = v0;        *(DWORD*)(out + s + 4) = v1;    }    for (int i = 0; i < 32; i++)    {        BYTE M = out[i];        O[i * 2] = sb[M >> 4];        O[i * 2 + 1] = sb[M & 0xf];    }}//keygenint main(){    char out[0x100] = { 0 };    const char* username = "KCTF";    char h[17] = { 0 };    strcpy((char*)h, username);    gen((BYTE*)h, (BYTE*)out);    std::cout << out;}
```

**赛题解析**

以下解析由看雪学者【mb\_mgodlfyn】给出，来自【hzqmwne】战队。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Gb5CwDibtC2z0wz9WZPnQLfzqwwMib7Kwe5bFJ0BKHprSx2Maf9Lj0Fb7iaGs03vGR63CRVvYk3ncEw/640?wx_fmt=png&from=appmsg)

静态分析，从start函数开始，进入 sub\_140108580 ，然后是 sub\_140108000 （位于zxvmp1区段），里面有一个大循环，未被混淆的代码差不多只有这些，另外多出来的有zxvmp开头的几个区段。导入表只有少量函数，而且无法直接找到交叉引用。

```
__int64 __usercall sub_140108000@<rax>(        __int32 a1@<edx>,        unsigned __int64 a2@<rcx>,        __int64 a3@<rbx>,        __int64 a4@<rbp>,        __int64 a5@<rdi>,        __int64 a6@<rsi>,        __int64 a7@<r12>,        __int64 a8@<r13>,        __int64 a9@<r14>,        __int64 a10@<r15>){  __int64 result; // rax  char *v11; // rax  struct machine *v12; // rax  struct machine *v13; // [rsp+20h] [rbp-78h]  __int32 v14; // [rsp+28h] [rbp-70h]  unsigned __int64 i; // [rsp+30h] [rbp-68h]  unsigned int v16; // [rsp+38h] [rbp-60h]  struct instruction *current_inst; // [rsp+40h] [rbp-58h]  __int64 v18; // [rsp+48h] [rbp-50h]  char *v19; // [rsp+58h] [rbp-40h]  unsigned __int64 v20; // [rsp+60h] [rbp-38h]  __int64 v21; // [rsp+70h] [rbp-28h]  __int64 v22; // [rsp+80h] [rbp-18h]   v13 = sub_14010848F();   // it always return constant value 0x140006000  current_inst = v13->current_inst;  v13->field_D8 = a1;  v19 = &sub_140108370()[current_inst->field_10];  for ( i = a2; ; i += 4LL )  {    result = current_inst->field_18;    if ( i == result )      break;    v16 = *(_DWORD *)&v19[i];    if ( v13->field_D4 )    {      i = sub_1401083D0(current_inst, v13->field_D0, v13->field_DC);      v16 = *(_DWORD *)&v19[i];      v13->field_D4 = 0;      v14 = v13->field_DC;    }    else if ( v13->field_D8 )    {      v14 = v13->field_D8;      v13->field_D8 = 0;    }    else    {      v14 = *(_DWORD *)v13->maybe_rsp;      v13->maybe_rsp += 8LL;    }    v20 = current_inst->field_28 / 12uLL;    v11 = sub_140108370();    v18 = sub_1401082A0(&v11[current_inst->field_20], v14 ^ v16, 0LL, (unsigned int)v20);    if ( (v18 & 0x4000000000000000LL) != 0 )    {      v21 = sub_1401083A0() + (v18 & 0xBFFFFFFFFFFFFFFFuLL);      sub_14010848F()->field_A8 = v21;      v12 = sub_14010848F();      ((void (*)(void))v12->field_A8)();    }    else    {      v22 = sub_1401083A0() + (v18 & 0x7FFFFFFFFFFFFFFFLL);      sub_14010848F()->field_A8 = v22;      sub_1401085FB(a3, a4, a5, a6, a7, a8, a9, a10);      if ( v18 < 0 )        return v13->field_B0;    }  }  return result;}
```

动态分析，修改exe头关闭dynamic base，然后上x64dbg调试，在调试器环境下输入公开的name-serial能正常通过，是个好消息，至少题目没有埋暗坑。

观察导入表的函数，猜测程序会通过GetWindowTextW函数获取输入框的值。下个断点观察调用栈和返回地址，向上找几层找到调用来源是0x140108207（位于sub\_140108000的一个分支中）

0x140108207是 ((void (\*)(void))v12->field\_A8)(); 间接调用，在这里下断点然后单步进入，发现总是会调用一个导入表的函数。

回到GetWindowTextW，这个函数被调用了两次，分别对应两个输入框的值。在第二次调用到的时候，对第一个参数的内存下硬件数据读取断点，继续执行，程序停在了0x140114994（movzx eax, word ptr [rax+rcx\*2]），这里是访问输入的serial的地方。

继续执行会返回到0x14010825D（sub\...