---
title: 原创Paper | parse-server 从原型污染到 RCE 漏洞(CVE-2022-39396) 分析
url: https://mp.weixin.qq.com/s?__biz=MzAxNDY2MTQ2OQ==&mid=2650967645&idx=1&sn=109a11ab8834fb555d5b67282d2bea42&chksm=8079cc6fb70e4579fd233ae2605ac1ddba7fe836c4f3194b4eb776f399aff4906e3b1680d6c7&scene=58&subscene=0#rd
source: Seebug漏洞平台
date: 2023-04-01
fetch_date: 2025-10-04T11:22:29.659953
---

# 原创Paper | parse-server 从原型污染到 RCE 漏洞(CVE-2022-39396) 分析

![cover_image](https://mmbiz.qpic.cn/mmbiz_jpg/3k9IT3oQhT0LKdg5YNbuIWibejXeYsia3pRBx821dePC1Ko6FA1WFyOJ1yK48RLRaBNlIV0fSxrAavjAcGp0hZAw/0?wx_fmt=jpeg)

# 原创Paper | parse-server 从原型污染到 RCE 漏洞(CVE-2022-39396) 分析

原创

404实验室

知道创宇404实验室

![](https://mmbiz.qpic.cn/mmbiz_gif/3k9IT3oQhT1iaezR7tUcyEUGKhvic5YJ9ibO6O0kdKbpTj0siban0INVzQ36Y8ic7gibCGjNrX9qzbe5Kics4AOhKpoBA/640?wx_fmt=gif)

作者：billion@知道创宇404实验室
日期：2023年3月31日

parse-server公布了一个原型污染的RCE漏洞，看起来同mongodb有关联，so跟进&&分析一下。

**1、BSON潜在问题**

参考资料

parse-server使用的mongodb依赖包版本是3.6.11，在`node-mongodb-drive <= 3.7.3` 版本时，使用1.x版本的bson依赖处理数据。

根据BSON文档的介绍，存在一种Code类型，可以在反序列化时被执行

![](https://mmbiz.qpic.cn/mmbiz_png/3k9IT3oQhT0LKdg5YNbuIWibejXeYsia3pmicVHAbouyjlTMk33iaV15jCN53ia4iaYTyUcNaibN8QA7ymSXur9ich8licQ/640?wx_fmt=png)

跟进BSON的序列化过程

```
} else if (value['_bsontype'] === 'Code') {
        index = serializeCode(
          buffer,
          key,
          value,
          index,
          checkKeys,
          depth,
          serializeFunctions,
          ignoreUndefined
        );
```

当对象的`_bsontype`键为`Code`时，就会被判断为Code类型，后面就会调用serializeCode函数进行序列化。

在反序列化时，遇到Code类型，会进行eval操作

```
var isolateEval = function(functionString) {
  // Contains the value we are going to set
  var value = null;
  // Eval the function
  eval('value = ' + functionString);
  return value;
};
```

根据官方的文档，可以了解到这本身就是bson内置的功能，不过需要打开evalFunctions参数

翻翻源码可以看到

```
var deserializeObject = function(buffer, index, options, isArray) {
  var evalFunctions = options['evalFunctions'] == null ? false : options['evalFunctions'];
  var cacheFunctions = options['cacheFunctions'] == null ? false : options['cacheFunctions'];
  var cacheFunctionsCrc32 =
    options['cacheFunctionsCrc32'] == null ? false : options['cacheFunctionsCrc32'];
```

`evalFunctions`参数默认情况下是未定义的，所以可以用原型污染来利用，该特性可以一直利用到bson <= 4.1.0

**2、Code上传点**

参考资料

mongodb在处理文件时，采用了一种叫GridFS的东西

![](https://mmbiz.qpic.cn/mmbiz_png/3k9IT3oQhT0LKdg5YNbuIWibejXeYsia3pzoRq74mISXwgusOOeSwc6mlHyPpNgficptCwicmZMKfVvWkARIN9XbwQ/640?wx_fmt=png)

看图大致可以了解到GridFS在存储文件时，把元数据(metadata)放到`fs.files`表，把文件内容放到`fs.chunks`表

跟进parse-server的源码，可以找到处理metadata的过程

node\_modules/parse-server/lib/Routers/FilesRouter.js

![](https://mmbiz.qpic.cn/mmbiz_png/3k9IT3oQhT0LKdg5YNbuIWibejXeYsia3p040icDCuXQPS64cZczhN27M7vdxm9hibb3JMCyok5fysvwibCFkaQPd4A/640?wx_fmt=png)

node\_modules/parse-server/lib/Adapters/Files/GridFSBucketAdapter.js

![](https://mmbiz.qpic.cn/mmbiz_png/3k9IT3oQhT0LKdg5YNbuIWibejXeYsia3p8fzgn9mNAXRJkVKlIibgjAHpJ5iaqZiaQEpwJJ1EnJdp0UDgjfHUercAA/640?wx_fmt=png)

输入进来的metadata被直接传入到了数据库中，并没有进行过滤

在测试的时候，发现metadata并没有保存到数据库中

![](https://mmbiz.qpic.cn/mmbiz_png/3k9IT3oQhT0LKdg5YNbuIWibejXeYsia3p78A79ibuXsYbaSHE1elZIBVdGYXGBUrY5yDkNIAwSXSeMWdCVEtWgag/640?wx_fmt=png)

排查了一下middleware，可以找到以下验证

node\_modules/parse-server/lib/middlewares.js

只有当`fileViaJSON=true`时，才会把fileData拷贝过去

```
if (fileViaJSON) {
    req.fileData = req.body.fileData; // We need to repopulate req.body with a buffer
    var base64 = req.body.base64;
    req.body = Buffer.from(base64, 'base64');
  }
```

回溯一下

```
var fileViaJSON = false;

  if (!info.appId || !_cache.default.get(info.appId)) {
    // See if we can find the app id on the body.
    if (req.body instanceof Buffer) {

      try {
        req.body = JSON.parse(req.body);
      } catch (e) {
        return invalidRequest(req, res);
      }

      fileViaJSON = true;
    }
```

当info.appId没有设置的话，就会进入if，fileViaJSON就被设置为true；或者是缓存中没有info.appId的信息

```
function handleParseHeaders(req, res, next) {
  var mount = getMountForRequest(req);
  var info = {
    appId: req.get('X-Parse-Application-Id'),
```

向上翻翻代码，就可以看到appId的赋值

后面还会有一处校验

```
if (req.body && req.body._ApplicationId && _cache.default.get(req.body._ApplicationId) && (!info.masterKey || _cache.default.get(req.body._ApplicationId).masterKey === info.masterKey)) {
      info.appId = req.body._ApplicationId;
      info.javascriptKey = req.body._JavaScriptKey || '';

    } else {
      return invalidRequest(req, res);
    }
```

这一步需要保证`_ApplicationId`是正确的appId，否则就退出了

所以认证这里有两种构造方式

No.1

让请求头中的`X-Parse-Application-Id`是一个不存在的appid，然后修改body中的`_ApplicationId`是正确的appid

![](https://mmbiz.qpic.cn/mmbiz_png/3k9IT3oQhT0LKdg5YNbuIWibejXeYsia3plyKDWuPGe1SibDLmAd3ibicYtx2NGibsf7cs4mxaWibic9HcG0xjXeN3oPpg/640?wx_fmt=png)

在fs.files表中也能够看到上传的metadata信息

![](https://mmbiz.qpic.cn/mmbiz_png/3k9IT3oQhT0LKdg5YNbuIWibejXeYsia3pQ9uAibKWfC9kf3rHic8Cme9aBib8Q9HQ9tPzZC3H8ibAXqIKnJxhsHw0gA/640?wx_fmt=png)

现在Code类型已经上传了，所以在找到一处原型污染，就可以RCE了

No.2

不设置`X-Parse-Application-Id`请求头

![](https://mmbiz.qpic.cn/mmbiz_png/3k9IT3oQhT0LKdg5YNbuIWibejXeYsia3p8cRTNiaCj2WN7WniaPIb6eYgQodfvtVQ22NCNjFaMSmAIrO0Gzmhmaaw/640?wx_fmt=png)

结果

![](https://mmbiz.qpic.cn/mmbiz_png/3k9IT3oQhT0LKdg5YNbuIWibejXeYsia3phPuqlOltp7GxQ8ibx2ic3pgpY8EJibRQWbzl7S2hrTgSAQxLxolXYResg/640?wx_fmt=png)

**3、原型污染**

参考资料

根据官方公告，应该在mongo目录下有原型污染，大致上过了一遍代码，感觉下面这一部分可能有

```
for (var restKey in restUpdate) {
    if (restUpdate[restKey] && restUpdate[restKey].__type === 'Relation') {
      continue;
    }

    var out = transformKeyValueForUpdate(className, restKey, restUpdate[restKey], parseFormatSchema); // If the output value is an object with any $ keys, it's an
    // operator that needs to be lifted onto the top level update
    // object.

    if (typeof out.value === 'object' && out.value !== null && out.value.__op) {
      mongoUpdate[out.value.__op] = mongoUpdate[out.value.__op] || {};
      mongoUpdate[out.value.__op][out.key] = out.value.arg;
    } else {
      mongoUpdate['$set'] = mongoUpdate['$set'] || {};
      mongoUpdate['$set'][out.key] = out.value;
    }
  }
```

如果能控制`out.value.__op` `out.key` `out.value.arg`，那就可以污染原型的`evalFunctions`了

回溯变量，跟进`transformKeyValueForUpdate()`函数

```
const transformKeyValueForUpdate = (className, restKey, restValue, parseFormatSchema) => {
  // Check if the schema is known since it's a built-in field.
  var key = restKey;
  var timeField = false;

  switch (key) {
    case 'objectId':
    case '_id':
      if (['_GlobalConfig', '_GraphQLConfig'].includes(className)) {
        return {
          key: key,
          value: parseInt(restValue)
        };
      }

      key = '_id';
      break;

    case 'createdAt':
    case '_created_at':
      key = '_created_at';
      timeField = true;
      break;

    case 'updatedAt':
    case '_updated_at':
      key = '_updated_at';
      timeField = true;
      break;

    case 'sessionToken':
    case '_session_token':
      key = '_session_token';
      break;

    case 'expiresAt':
    case '_expiresAt':
      key = 'expiresAt';
      timeField = true;
      break;
........
    case '_rperm':
    case '_wperm':
      return {
        key: key,
        value: restValue
      };
......
  }
```

返回值大都是`{key, value}`的形式，如果key是case中的任一个，那必然不可能返回`__proto__`，继续看后面的部分

```
if (parseFormatSchema.fields[key] && parseFormatSchema.fields[key].type === 'Pointer' || !parseFormatSchema.fields[key] && restValue && restValue.__type == 'Pointer') {
    key = '_p_' + key;
  } // Handle atomic values

  var value = transformTopLevelAtom(restValue);

  if (value !== CannotTransform) {
    if (timeField && typeof value === 'string') {
      value = new Date(value);
    }

    if (restKey.indexOf('.') > 0) {
      return {
        key,
        value: restValue
      };
    }

    return {//这里
      key,
      value
    };
  } // Handle arrays
```

在最终污染的位置`restKey`应该是`evalFunctions`，所以不会进入`if (restKey.indexOf('.') > 0) {`这个分支，可以通过第二个`return`返回key和value

跟进`transformTopLevelAtom()`函数

```
function transformTopLevelAtom(atom, field) {
  switch (typeof atom) {
.......
    case 'object':
      if (atom instanceof Date) {
        // Technically dates are not rest format, but, it seems pretty
        // clear what they should be transformed to, so let's just do it.
        return atom;
      }

      if (atom === null) {
        return atom;
      } // TODO: check validity harder for the __type-defined types

      if (at...