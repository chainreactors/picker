---
title: 鸿蒙应用签名实操及机制探究
url: https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651779697&idx=1&sn=9da7af985ae9e9735e04368441c01698&chksm=bd122b3c8a65a22ad3d49c9f5342154ba5fd1aa54f56467ff435b5e80ac6dbc692fde563965a&scene=58&subscene=0#rd
source: 美团技术团队
date: 2025-01-03
fetch_date: 2025-10-06T20:10:20.946002
---

# 鸿蒙应用签名实操及机制探究

![cover_image](https://mmbiz.qpic.cn/sz_mmbiz_jpg/hEx03cFgUsUzSHd3mSw6g7UXgr4yyFYsrFTO84kqsDeDGs86z6eic5b8y3OkicQgMMrKJ4VFaTxqy7zadAJLnx7w/0?wx_fmt=jpeg)

# 鸿蒙应用签名实操及机制探究

美团技术团队

以下文章来源于美团安全应急响应中心
，作者张晨

![](http://wx.qlogo.cn/mmhead/Q3auHgzwzM4No6FqQCzrOJzFMZzgnhL8oRvfbf2ViazKbqZYp6sxibsQ/0)

**美团安全应急响应中心**
.

美团安全应急响应中心官方公众号

![](https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVsE4Nicq51WdnKEhcaEEYDS4h6jA6JOZ3fnENgFV1B6ianDTqaQ3nzNOjvHUB79ocldrVj4YlkAW6g/640?wx_fmt=png)

## 0x00 背景

华为鸿蒙单框架操作系统HarmonyOS NEXT已于2024年10月23日正式发布Release版。HarmonyOSNEXT仅支持鸿蒙原生应用，不再兼容安卓。本文对鸿蒙公开资料进行了深入分析和解读，梳理了鸿蒙单框架应用的签名机制，拆解每一步的实操过程和背后的实现原理，并对源码分析整理签名的校验机制。从中管中窥豹，探究鸿蒙系统的安全设计思路，给从事鸿蒙研发的同学提供一些借鉴。

成文过程中特别参考OpenHarmony 5.0.0-Release版的文档和源码，详见

https://gitee.com/openharmony/docs/blob/OpenHarmony-5.0.0-Release/zh-cn/release-notes/OpenHarmony-v5.0.0-release.md。‍‍‍

**|** 本文转载自公众号：[美团安全应急响应中心](https://mp.weixin.qq.com/s?__biz=MzI5MDc4MTM3Mg==&mid=2247493695&idx=1&sn=89a37bdee61841877d1acf28b8a68cbf&scene=21#wechat_redirect)

0x01 签名机制

##

签名相关的代码在developtools\_hapsigner仓库（https://gitee.com/openharmony/developtools\_hapsigner/tree/OpenHarmony-v5.0.0-Release/）里，签名流程梳理如下：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/6tKK4bYDvyn5YUP6vBPniaGQ3MjicDTN9tda11jJWaghLaoPChvFruiaw7cr0GmJxmLW8PhiaveGxoI4QRl4aYtByg/640?wx_fmt=png&from=appmsg)

签名步骤可按如下分组：

* 生成开发者签名证书，包括①、② 、③。
* 生成Profile文件，包括④ 、⑤ 。
* 生成签名的App，包括⑥ 、⑦。

**1.生成开发者签名证书**

**①****生成开发者公私钥**

通过华为的DevEco-Studio工具可以直接生成包含开发者公私钥的p12文件，操作步骤：

https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/ide-signing-V5#section462703710326。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/6tKK4bYDvyn5YUP6vBPniaGQ3MjicDTN9t8KIVaviaGPAvPjT1icCqtq2M4MTPJmSpmMnpJG64ObEHD1bc9e2JziaQQ/640?wx_fmt=png&from=appmsg)

笔者示例生成的p12文件（保存为my.p12）是标准的PKCS#12格式（定义在RFC 7292：https://datatracker.ietf.org/doc/html/rfc7292），用来存储一组或多组公钥证书（里面包含公钥）和其对应的私钥（用localKeyID字段进行匹配公私钥的匹配），使用ASN.1来定义其数据结构，并采用DER编码规则将这些结构编码为二进制形式。

可以通过openssl命令解析其结构，或者直接查看公钥证书和私钥信息：

```
openssl asn1parse -in my.p12 -inform DER  //解码DER和解析ASN.1openssl pkcs12 -info -in my.p12  //查看公钥证书和私钥信息
```

笔者用于示例生成的p12文件里包含的公钥证书如下：

```
-----BEGIN CERTIFICATE-----MIIBqTCCAU+gAwIBAgIIKG2ih6j2GSswCgYIKoZIzj0EAwIwSTEJMAcGA1UEBhMAMQkwBwYDVQQIEwAxCTAHBgNVBAcTADEJMAcGA1UEChMAMQkwBwYDVQQLEwAxEDAOBgNVBAMTB3Rlc3RzY3IwHhcNMjQwOTIzMTI1NjM3WhcNNDkwOTE3MTI1NjM3WjBJMQkwBwYDVQQGEwAxCTAHBgNVBAgTADEJMAcGA1UEBxMAMQkwBwYDVQQKEwAxCTAHBgNVBAsTADEQMA4GA1UEAxMHdGVzdHNjcjBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABD28s78rF8+X1JWgkQcfHB2Gy20MCT51Oue6eG5ZbPsUKlZrPx0aRX0einL2E5WsE3st0zI4yvj0KzhdEwksCWCjITAfMB0GA1UdDgQWBBRtCEWMjEr+bnXoAqSCfjmk1btJQDAKBggqhkjOPQQDAgNIADBFAiAAiMtQXgCMUxrKtaPKvGqllswi1FRUh1brCAbJ1t81FgIhAMXbzmeJlA7/zxZDULLRW0rCY6CU3KMDHr8N38EmuDug-----END CERTIFICATE-----
```

公钥证书的表示是遵循Privacy Enhanced Mail（PEM）协议（定义在RFC 7468：https://datatracker.ietf.org/doc/html/rfc7468）的文本文件，其格式如下：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/6tKK4bYDvyn5YUP6vBPniaGQ3MjicDTN9tYuNETtjDJsWicibiaxRZgzYN8iapdJuibFBicF8AGYsQXbYcL4qGdVTyqhzg/640?wx_fmt=png&from=appmsg)

PEM 文件的label用于指示文件的内容类型。以下是一些常见的 PEM header和footer（后面会陆续见到）：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/6tKK4bYDvyn5YUP6vBPniaGQ3MjicDTN9tQ28bKjSicsZYjou0KBVGq9y3lQaSsG0fEoVK1w6fwnSsLqdRmlaM0pg/640?wx_fmt=png&from=appmsg)

解析具体公钥证书信息可以采用如下命令（将公钥证书以文本的形式保存为my.pem文件）：

```
openssl x509 -in my.pem -text -noout
```

解析得到如下输出（重要部分加了注释）：

```
Certificate:    Data:        Version: 3 (0x2) //证书的版本号        Serial Number: 2913163237517564203 (0x286da287a8f6192b) //证书的序列号，用于唯一标识证书        Signature Algorithm: ecdsa-with-SHA256        Issuer: C = , ST = , L = , O = , OU = , CN = testscr //证书颁发者的信息        Validity            Not Before: Sep 23 12:56:37 2024 GMT //证书的开始有效期            Not After : Sep 17 12:56:37 2049 GMT //证书的结束有效期        Subject: C = , ST = , L = , O = , OU = , CN = testscr //证书持有者的信息        Subject Public Key Info:            Public Key Algorithm: id-ecPublicKey //公钥算法，这里是椭圆曲线                Public-Key: (256 bit) //公钥的位数，这里是256                pub:// 证书持有者的公钥值，以十六进制表示                    04:3d:bc:b3:bf:2b:17:cf:97:d4:95:a0:91:07:1f:                    1c:1d:86:cb:6d:0c:09:3e:75:3a:e7:ba:78:6e:59:                    6c:fb:14:2a:56:6b:3f:1d:1a:45:7d:1e:8a:72:f6:                    13:95:ac:13:7b:2d:d3:32:38:ca:f8:f4:2b:38:5d:                    13:09:2c:09:60                ASN1 OID: prime256v1                NIST CURVE: P-256        X509v3 extensions:            X509v3 Subject Key Identifier: //证书持有者的标识                6D:08:45:8C:8C:4A:FE:6E:75:E8:02:A4:82:7E:39:A4:D5:BB:49:40    Signature Algorithm: ecdsa-with-SHA256    Signature Value: //证书的数字签名值        30:45:02:20:00:88:cb:50:5e:00:8c:53:1a:ca:b5:a3:ca:bc:        6a:a5:96:cc:22:d4:54:54:87:56:eb:08:06:c9:d6:df:35:16:        02:21:00:c5:db:ce:67:89:94:0e:ff:cf:16:43:50:b2:d1:5b:        4a:c2:63:a0:94:dc:a3:03:1e:bf:0d:df:c1:26:b8:3b:a0
```

公钥信息（包括公钥算法、公钥位数、公钥值等）属于结构化数据并且较长，不利于识别和比较，所以需要用一个简短的字符串来标识公钥唯一性。常用做法是使用公钥指纹（Public Key Pin，也叫公钥Pin），计算方式是对DER编码的公钥进行SHA-256计算并进行Base64编码。

这里需要注意的是，在X509扩展字段里包括了Subject Key Identifier（SKID）字段，也是证书持有者的标识。那标识公钥的唯一性为什么不直接使用证书里自带的SKID，还要自己算一遍呢，根据RFC 3280-4.2.1.2章节（https://datatracker.ietf.org/doc/html/rfc3280#section-4.2.1.2）中对SKID的定义：

> For CA certificates, subject key identifiers SHOULD be derived from the public key **or a method that generates unique values**.
>
> Two common methods for generating key identifiers from the public key are:
>
> (1) The keyIdentifier is composed of the 160-bit SHA-1 hash of the value of the BIT STRING subjectPublicKey (excluding the tag, length, and number of unused bits).
>
> (2) The keyIdentifier is composed of a four bit type field with the value 0100 followed by the least significant 60 bits of the SHA-1 hash of the value of the BIT STRING subjectPublicKey (excluding the tag, length, and number of unused bit string bits).

SKID的计算可以通过公钥得到，但计算方式并不唯一，也可以通过任意的算法得到，只要保证唯一性就可以了。定义里推荐了两种基于SHA-1的算法，openssl采用的算法（详见v3\_skid.c的ossl\_x509\_pubkey\_hash函数：https://github.com/openssl/openssl/blob/master/crypto/x509/v3\_skid.c）是对DER编码的公钥进行SHA-1计算。

如果采用SKID来进行公钥的唯一性校验，那么攻击者可以伪造一个证书，里面的SKID和你的一样（SHA-1碰撞，或者直接照抄一下也行），这样的证书也是合法的，就可以轻易绕过对公钥的校验。所以SKID一般只用于在证书链中寻找父子关系，并不用于公钥的唯一性标识。另外，还有Authority Key Identifier（AKID）字段用于标识证书的颁发者。当验证一个证书链时，验证程序会检查每个证书的AKID和上一个证书的SKID是否匹配，确保它们形成一个连续的信任链。

使用如下命令可以从PEM协议的公钥证书中提取PEM协议的公钥：

```
openssl x509 -in my.pem -pubkey -noout
```

输出如下：

```
-----BEGIN PUBLIC KEY----- //公钥标头MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE95zFs5cFHauzIYEuuw3g2R75a1irqEW0JWP9qAKkyVCizN0nnzcn/Fo5oeSZR1iPUnJvjlnpNvZL9BcQbLqa7g==-----END PUBLIC KEY-----
```

使用如下命令可以继续转换成DER编码并计算SHA-256和Base64编码：

```
openssl pkey -pubin -outform der | openssl dgst -sha256 -binary | openssl enc -base64
```

所以结合使用如下命令可以直接从符合PEM协议的公钥证书文件中得到对应的公钥指纹：

```
openssl x509 -in my.pem -pubkey -noout | openssl pkey -pubin -outform der | openssl dgst -sha256 -binary | openssl enc -base64
```

最终笔者示例的公钥证书计算得到的公钥指纹为：

```
fzyRjPvTPElBAj0VlYlVA74M3RMtUh5ljKbOYf1NDA0=
```

**②****生成证书签名请求**

同样通过DevEco-Studio可以直接生成证书签名请求Certificate Signing Request（CSR）文件（操作步骤：https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/ide-signing-V5#section462703710326）。得到的CSR内容示例如下：

```
-----BEGIN NEW CERTIFICATE REQUEST----- //CSR标头MIIBMzCB2wIBADBJMQkwBwYDVQQGEwAxCTAHBgNVBAgTADEJMAcGA1UEBxMAMQkwBwYDVQQKEwAxCTAHBgNVBAsTADEQMA4GA1UEAxMHdGVzdHNjcjBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABD28s78rF8+X1JWgkQcfHB2Gy20MCT51Oue6eG5ZbPsUKlZrPx0aRX0einL2E5WsE3st0zI4yvj0KzhdEwksCWCgMDAuBgkqhkiG9w0BCQ4xITAfMB0GA1UdDgQWBBRtCEWMjEr+bnXoAqSCfjmk1btJQDAKBggqhkjOPQQDAgNHADBEAiAlzkRf0AHKh59/deFGo/4JHQRSbw6P+Q7qsiiMMWHT7wIgGugWrCm7tFLhmRjEEyJNOpen9kfhyOanSRrwtBlEFc0=-----END NEW CERTIFICATE REQUEST-----
```

生成的CSR文件是标准的PKCS#10格式（定义在RFC 2986：https://datatracker.ietf.org/doc/html/rfc2986），用于向证书颁发机构（CA）请求签发数字证书的文件，包含申请者的公钥和一些身份信息，这些信息将包含在颁发的证书中。可以看到CSR文件也是遵循PEM协议的，可以如下命令解析CSR文件的内容（保存为my.csr文件）：

```
openssl req -text -noout -verify -in my.csr
```

输出示例（重要部分加了注释）：

```
Certificate request self-signature verify OK //表明CSR的自签名已成功验证Certificate Request:    Data:    ...