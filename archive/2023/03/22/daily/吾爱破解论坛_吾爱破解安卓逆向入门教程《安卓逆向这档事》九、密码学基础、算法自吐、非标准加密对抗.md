---
title: 吾爱破解安卓逆向入门教程《安卓逆向这档事》九、密码学基础、算法自吐、非标准加密对抗
url: https://mp.weixin.qq.com/s?__biz=MjM5Mjc3MDM2Mw==&mid=2651139179&idx=1&sn=26e374dfb5776d41a7d3501770915a77&chksm=bd50bc3f8a2735293c12856cfabf63aa694a2c66b8846a83eb9e301ac60d31484ed1600b8e1c&scene=58&subscene=0#rd
source: 吾爱破解论坛
date: 2023-03-22
fetch_date: 2025-10-04T10:15:47.557116
---

# 吾爱破解安卓逆向入门教程《安卓逆向这档事》九、密码学基础、算法自吐、非标准加密对抗

![cover_image](https://mmbiz.qpic.cn/sz_mmbiz_jpg/LFPriaSjBUZKcpF4H5BNFvPiaibkFBHh5M1VamibWK3mLpJ1USCSmH9ZajThDDUPiaQbRkxibnb9II1M9ibFumbS8cpBA/0?wx_fmt=jpeg)

# 吾爱破解安卓逆向入门教程《安卓逆向这档事》九、密码学基础、算法自吐、非标准加密对抗

原创

吾爱pojie

吾爱破解论坛

**作者****论****坛账号：正己**

![](https://mmbiz.qpic.cn/sz_mmbiz_png/LFPriaSjBUZKcpF4H5BNFvPiaibkFBHh5M16jK9ABGQS1tibrnIXufuwRS7qdQEcH9HTUAzF0qFD05pwtTUr52Vicog/640?wx_fmt=png)

# 一、课程目标

---

1.密码学基础
2.常见编码与算法
3.非标准加密对抗

# 二、工具

---

1.教程Demo(更新)
2.MT管理器/NP管理器
3.算法助手
4.雷电模拟器
5.Android Studio
6.jadx-gui

# 三、课程内容

---

##

## 1.为什么要学这个？

* CTF
* 爬虫:算法还原、协议分析
* 网络安全:渗透测试、安全防护
  ![](https://mmbiz.qpic.cn/sz_mmbiz_png/LFPriaSjBUZKcpF4H5BNFvPiaibkFBHh5M1VZpRdUy72U9OXqZ4RWNZR6piaGdsyYf365FMtJytdMSRibagK95WsCkQ/640?wx_fmt=png)

## 2.密码学基础

### 1.什么是密码学?

密码学(cryptography)是一种将信息表述为不可读的方式，并使用一种秘密的方法将信息恢复出来的科学。密码学提供的最基本的服务是数据机密性服务，就是使通信双方可以互相发送消息，并且避免他人窃取消息的内容。加密算法是密码学的核心。

* 明文：原始消息
* 密文：加密后的消息
* 加密：从明文到密文的变换过程
* 解密：从密文到明文的变换过程
* 密钥：相用来完成加解密等过程的秘密信息
  ![](https://mmbiz.qpic.cn/sz_mmbiz_png/LFPriaSjBUZKcpF4H5BNFvPiaibkFBHh5M1VpHccDPGyvYFvXziasJjSK9kKkVDWxH8MvQ2WogBeayUgAHGYDeCl8A/640?wx_fmt=png)

## 3.常见编码

### 1.Base64编码

CyberChef
定义:
Base64是一种用64个字符表示任意二进制数据的方法，是一种编码，并非加密字符编码，由 A-Z a-z 0-9 + / 和补充字符 “=” 组成，Base64编码后的字符数是4的倍数（不足会补"="）

明文:

##

```
复制代码 隐藏代码

吾爱破解论坛
```

密文:

```
复制代码 隐藏代码

5ZC+54ix56C06Kej6K665Z2b
```

逻辑实现:

```
复制代码 隐藏代码

import java.util.Base64;

public class Base64Example {
    public static void main(String[] args) {
        String text = "吾爱破解论坛";

        // 编码
        String encodedString = Base64.getEncoder().encodeToString(text.getBytes());
        System.out.println("Encoded string: " + encodedString);

        // 解码
        byte[] decodedBytes = Base64.getDecoder().decode(encodedString);
        String decodedString = new String(decodedBytes);
        System.out.println("Decoded string: " + decodedString);
    }
}
```

自实现base64：

```
复制代码 隐藏代码

public class Base64Example {
        //base64码表
    private static final String base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

    public static void main(String[] args) {
        String originalInput = "吾爱破解论坛";

        // 编码
        String encodedString = encodeBase64(originalInput.getBytes());
        System.out.println("Encoded string: " + encodedString);

        // 解码
        byte[] decodedBytes = decodeBase64(encodedString);
        String decodedString = new String(decodedBytes);
        System.out.println("Decoded string: " + decodedString);
    }

    private static String encodeBase64(byte[] inputBytes) {
        StringBuilder sb = new StringBuilder();
        int paddingCount = (3 - inputBytes.length % 3) % 3;

        for (int i = 0; i < inputBytes.length; i += 3) {
            int b = ((inputBytes[i] & 0xFF) << 16) | ((i + 1 < inputBytes.length ? inputBytes[i + 1] & 0xFF : 0) << 8) | (i + 2 < inputBytes.length ? inputBytes[i + 2] & 0xFF : 0);
            sb.append(base64Chars.charAt((b >> 18) & 0x3F)).append(base64Chars.charAt((b >> 12) & 0x3F)).append(base64Chars.charAt((b >> 6) & 0x3F)).append(base64Chars.charAt(b & 0x3F));
        }

        for (int i = 0; i < paddingCount; i++) {
            sb.setCharAt(sb.length() - i - 1, '=');
        }

        return sb.toString();
    }

    private static byte[] decodeBase64(String inputString) {
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        int paddingCount = 0;

        for (int i = 0; i < inputString.length(); i += 4) {
            int b = (base64Chars.indexOf(inputString.charAt(i)) << 18) | (base64Chars.indexOf(inputString.charAt(i + 1)) << 12) | (i + 2 < inputString.length() && inputString.charAt(i + 2) != '=' ? base64Chars.indexOf(inputString.charAt(i + 2)) << 6 : 0) | (i + 3 < inputString.length() && inputString.charAt(i + 3) != '=' ? base64Chars.indexOf(inputString.charAt(i + 3)) : 0);
            bos.write((b >> 16) & 0xFF);
            bos.write((b >> 8) & 0xFF);
            bos.write(b & 0xFF);

            if (inputString.charAt(i + 2) == '=') {
                paddingCount++;
            }

            if (inputString.charAt(i + 3) == '=') {
                paddingCount++;
            }
        }

        byte[] result = bos.toByteArray();

        if (paddingCount > 0) {
            byte[] trimmedResult = new byte[result.length - paddingCount];
            System.arraycopy(result, 0, trimmedResult, 0, trimmedResult.length);
            return trimmedResult;
        } else {
            return result;
        }
    }
}
```

### 2.Hex编码

定义:
hex编码，又称十六进制编码(也称base16)，一般用于方便人们查看二进制文件内容，它将字节数据中的每4个bit使用数字(0-9)、字母(A-F)共16个字符等效表示，由于一个字节有8个bit，所以一个字节会被编码为2个hex字符
PS:在 ASCII 编码中，只有0到127之间的数字是表示英文字母、数字和符号的，超出这个范围的字符需要使用其他编码方式,例如汉字就需要使用 UTF-8 或 UTF-16

明文:

```
复制代码 隐藏代码

吾爱破解论坛
```

密文:

```
复制代码 隐藏代码

E590BEE788B1E7A0B4E8A7A3E8AEBAE59D9B
```

逻辑实现:
`%02X` 是一个格式化字符串，其中 `%` 是转义符，`02` 是最小宽度，表示输出的字符串至少包含两个字符，不足两个字符时用 `0` 填充，`X` 表示输出的字符集为大写的十六进制数。(算是一个特征)

```
复制代码 隐藏代码

// 将普通字符串转换为Hex字符串
public static String stringToHex(String input) {
    StringBuilder output = new StringBuilder();
    byte[] bytes = input.getBytes(StandardCharsets.UTF_8);
    for (byte b : bytes) {
        output.append(String.format("%02X", b));
    }
    return output.toString();
}
// 将Hex字符串转换为普通字符串
public static String hexToString(String input) {
    byte[] bytes = new byte[input.length() / 2];
    for (int i = 0; i < input.length(); i += 2) {
        bytes[i / 2] = (byte) Integer.parseInt(input.substring(i, i + 2), 16);
    }
    return new String(bytes, StandardCharsets.UTF_8);
}
```

### 3.Unicode编码

定义:
Unicode（统一码、万国码、单一码）是一种在计算机上使用的字符编码。

明文:

```
复制代码 隐藏代码

吾爱破解论坛
```

密文:

```
复制代码 隐藏代码

\u543E\u7231\u7834\u89E3\u8BBA\u575B
```

逻辑实现:

```
复制代码 隐藏代码

// 将字符串转换为Unicode格式
public static String stringToUnicode(String input) {
    StringBuilder output = new StringBuilder();
    for (int i = 0; i < input.length(); i++) {
        output.append(String.format("\\u%04X", (int) input.charAt(i)));
    }
    return output.toString();
}
// 将Unicode格式的字符串转换为原始字符串
public static String unicodeToString(String input) {
    StringBuilder output = new StringBuilder();
    for (int i = 0; i < input.length(); i += 6) {
        String str = input.substring(i + 2, i + 6);
        output.append((char) Integer.parseInt(str, 16));
    }
    return output.toString();
}
```

### 4.Byte数组

PS：常用于字符串加密
明文：

```
复制代码 隐藏代码

吾爱破解论坛
```

密文：

```
复制代码 隐藏代码

byte[] byteArray = new byte[]{-27,-112,-66,-25,-120,-79,-25,-96,-76,-24,-89,-93,-24,-82,-70,-27,-99,-101};
```

```
复制代码 隐藏代码

public static void main(String[] args) {
        //stringtobyte数组
    String originalInput = "吾爱破解论坛";
    byte[] bytes = originalInput.getBytes();
    System.out.println(Arrays.toString(bytes));

    //byte数组tostring
    byte[] byteArray = new byte[]{-27,-112,-66,-25,-120,-79,-25,-96,-76,-24,-89,-93,-24,-82,-70,-27,-99,-101};
    String str = new String(byteArray);
    System.out.println(str);

}
```

## 4.加密算法

### 1.消息摘要算法&单向散列函数&哈希算法

定义:
单向散列函数算法也称Hash（哈希）算法(消息摘要算法)，是一种将任意长度的消息压缩到某一固定长度（消息摘要）的函数（该过程不可逆）。Hash函数可用于数字签名、 消息的完整性检测、消息起源的认证检测等。
常见的算法:MD5、HMAC、SHA-X(SHA-1,SHA-2)

#### MD5摘要

特性:

* 压缩性:无论数据长度是多少,计算出来的MD5值长度相同(16位、32位)
* 抗修改性:即便修改一个字节，计算出来的MD5值也会巨大差异
* 抗碰撞性:知道数据和MD5值，很小概率找到相同MD5值相同的原数据
* 易计算性:由原数据容易计算出MD5值(逆推)

明文:

```
复制代码 隐藏代码

吾爱破解论坛
```

密文:

```
复制代码 隐藏代码

0bc50e2bf301b3f7c4309a9f4c9b19b2
```

逻辑实现:

```
复制代码 隐藏代码

public static void main(String[] args) throws Exception {
        MessageDigest md = MessageDigest.getInstance("MD5");
        md.update("吾爱破解论坛".getBytes());
        byte[] res = md.digest();
        System.out.println(byteToHexString(res));
    }
    public static String byteToHexString(byte[] by) {
        StringBuilder SB = new StringBuilder();

        for (int k : by) {
            int j = k;
            if (k < 0) {
                j = k + 256;
            }

            if (j < 16) {
                SB.append("0");
            }

            SB.append(Integer.toHexString(j));
        }...