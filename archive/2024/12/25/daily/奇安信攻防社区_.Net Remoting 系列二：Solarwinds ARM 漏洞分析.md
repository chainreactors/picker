---
title: .Net Remoting 系列二：Solarwinds ARM 漏洞分析
url: https://forum.butian.net/share/3998
source: 奇安信攻防社区
date: 2024-12-25
fetch_date: 2025-10-06T19:33:05.159248
---

# .Net Remoting 系列二：Solarwinds ARM 漏洞分析

#

[问答](https://forum.butian.net/questions)

*发起*

* [提问](https://forum.butian.net/question/create)
* [文章](https://forum.butian.net/share/create)

[攻防](https://forum.butian.net/community)
[活动](https://forum.butian.net/movable)

Toggle navigation

* [首页 (current)](https://forum.butian.net)
* [问答](https://forum.butian.net/questions)
* [商城](https://forum.butian.net/shop)
* [实战攻防技术](https://forum.butian.net/community)
* [漏洞分析与复现](https://forum.butian.net/articles)
  NEW
* [活动](https://forum.butian.net/movable)
* [摸鱼办](https://forum.butian.net/questions/Play)

搜索

* [登录](https://forum.butian.net/login)
* [注册](https://user.skyeye.qianxin.com/user/register?next=http://forum.butian.net/btlogin)

### .Net Remoting 系列二：Solarwinds ARM 漏洞分析

* [漏洞分析](https://forum.butian.net/topic/48)

本篇主要是以Solarwinds Arm产品介绍自定义ServerChanel的场景，漏洞分析利用是其次，事实上是去年挖的没有详细记录，后续写的，勿怪哈哈哈

起因
--
最开始的漏洞是由@SinSinology挖掘的[CVE-2023-35187](https://www.cve.org/CVERecord?id=CVE-2023-35187)后续又出现了很多CVE。
```php
This vulnerability allows remote attackers to execute arbitrary code on affected installations of SolarWinds Access Rights Manager. Authentication is not required to exploit this vulnerability.The specific flaw exists within the OpenClientUpdateFile method. The issue results from the lack of proper validation of a user-supplied path prior to using it in file operations. An attacker can leverage this vulnerability to execute code in the context of SYSTEM.
```
自定义的ServerChannel
-----------------
根据漏洞描述可以定位到OpenClientUpdateFile方法；
```php
public class TattleImplementation : RemotingObject, ITattle, IPing
{
......
public Guid OpenClientUpdateFile(string fileName)
        {
            Guid guid2;
            using (MethodCall methodCall = new MethodCall(this))
            {
                Guid guid = Guid.NewGuid();
                using (this.fileStreams.Lock())
                {
                    this.fileStreams.Add(guid, new FileStream(Path.Combine(ApplicationPaths.Instance.InstallationPath, fileName), FileMode.Open, FileAccess.Read));
                }
                guid2 = methodCall.SetResult(guid);
            }
            return guid2;
        }
        public byte[] ReadClientUpdateFile(Guid updateId, int maxBytes)
        {
            byte[] array = new byte[maxBytes];
            int num;
            using (this.fileStreams.Lock())
            {
                num = this.fileStreams[updateId].Read(array, 0, maxBytes);
            }
            Array.Resize(ref array, num);
            return array;
        }
        ......
```
很明显可以通过调用OpenClientUpdateFile返回的guid再调用ReadClientUpdateFile可以读取任意文件，并且该类继承`RemotingObject`，该类实现如下
```php
using System;
using System.Runtime.Remoting;
namespace pn.remoting
{
    public abstract class RemotingObject : MarshalByRefObject, IDisposable, IPing
    {
        public override object InitializeLifetimeService()
        {
            return null;
        }
        public string Ping(string packet)
        {
            return packet;
        }
        public void InstantiateInterface()
        {
        }
        public virtual void Dispose()
        {
            RemotingServices.Disconnect(this);
        }
    }
}
```
可以看到该类继承自MarshalByRefObject，判断是漏洞是.Net Remoting导致的，全局搜索发现主要处理在SolarWinds.ARM.Remoting.dll。看到GrpcServerChannel类
```php
namespace SolarWinds.ARM.Remoting
{
internal sealed class GrpcServerChannel : IChannelReceiver, IChannel, ISecurableChannel
{
public GrpcServerChannel(IGrpcRemotingChannelManager grpcChannelManager, string name, int port, IServerChannelSinkProvider sinkProvider = null)
{
this.port = port;
this.machineName = Dns.GetHostName();
this.baseAddresses = new string[0];
this.grpcChannelManager = grpcChannelManager;
this.name = name;
this.sinkProvider = sinkProvider ?? new BinaryServerFormatterSinkProvider(new Hashtable
{
{ "includeVersions", false },
{
"typeFilterLevel",
TypeFilterLevel.Full.ToString()
}
}, null);
this.setupChannel();
this.StartListening(null);
}
......
```
和TcpServerChannel类似的实现，看样子是服务端是基于GRPC的ServerChannel，下面分析它处理的大致逻辑。
Remoting功能代码逻辑分析
----------------
按照之前的思路梳理自定义的ServerChannel，看看注册的Channel类型是否是GrpcServerChannel，查找ChannelServices#RegisterChannelInternal的调用，找到GrpcRemotingChannelCreator#createGlobalServerChannelInternal方法，实现如下
```php
private int createGlobalServerChannelInternal(int port, bool selectServerPort)
{
    string text = string.Format("port\_{0}", port);
    object obj = this.channelAccess;
    lock (obj)
    {
        ......
        IDictionary dictionary = new Hashtable();
        dictionary["includeVersions"] = false;
        dictionary["typeFilterLevel"] = TypeFilterLevel.Full.ToString();
        IServerChannelSinkProvider serverChannelSinkProvider2;
        if (!this.applicationConfiguration.GetValue("network.dump.enabled", false))
        {
            IServerChannelSinkProvider serverChannelSinkProvider = new BinaryServerFormatterSinkProvider(dictionary, null);
            serverChannelSinkProvider2 = serverChannelSinkProvider;
        }
        ......
        IServerChannelSinkProvider serverChannelSinkProvider3 = serverChannelSinkProvider2;
        IChannelReceiver channelReceiver;
        if (selectServerPort || port &gt; 0)
        {
            channelReceiver = new GrpcServerChannel(this.grpcManager, text, port, serverChannelSinkProvider3);
            this.hostname = new Uri(channelReceiver.GetUrlsForUri("")[0]).Host;
            port = this.grpcManager.LocalPort;
            this.SetProperties(new Dictionary(StringComparer.OrdinalIgnoreCase)
            {
                { "LocalPort", port },
                { "remoteHost", this.DnsHostName },
                { "remotePort", port }
            });
            StringBuilder sb = new StringBuilder(" gRPC .netRemoting listen on port ").AppendLine(port.ToString()).AppendLine(string.Format("ARM is using following channel URIs[{0}]: ", ((GrpcServerChannel)channelReceiver).ChannelUris.Length));
           ((GrpcServerChannel)channelReceiver).ChannelUris.ForEach(delegate(string u)
            {
                sb.AppendLine(u);
            });
            Log.info(this, sb.ToString());
        }
        ......
        ChannelServices.RegisterChannel(channelReceiver, false);
    }
    return this.grpcManager.LocalPort;
}
```
传入GrpcServerChannel的sinkProvider为BinaryServerFormatterSinkProvider，并开启了Full Type Filter。
下面梳理sinkProviderChains：通读`SolarWinds.ARM.Remoting.GrpcServerChannel`的代码，和TcpServerChannel大同小异，实现大致如下
```php
//构造函数TypeFilterLevel为Full
//调用setupChannel
//调用StartListening
private void setupChannel()
{
this.channelData = new ChannelDataStore(null);
// 创建默认的SinkProviderChain provider，这里之前创建的就是BinaryServerFormatterSinkProvider
if (this.sinkProvider == null)
{
this.sinkProvider = ChannelHelper.CreateDefaultServerProviderChain();
}
this.port = this.grpcChannelManager.BindPort(this.port);
Log.debug(this, string.Format("gRPC channel bound to port {0}", this.port));
this.baseAddresses = (from hostname in this.grpcChannelManager.HostNames
select string.Format("{0}{1}:{2}", "grpc://", hostname, this.port)).ToArray();
Log.debug(this, string.Format("gRPC determines channel addresses by network interfaces [{0}] {1} {2}", this.baseAddresses.Length, Environment.NewLine, string.Join(Environment.NewLine, this.baseAddresses)));
if (this.port &gt; 0)
{
this.channelData.ChannelUris = this.baseAddresses;
}
//这里和TcpServerChannel一样
CoreChannel.CollectChannelDataFromServerSinkProviders(this.channelData, this.sinkProvider);
this.transportSink = new GrpcServerChannel.GrpcServerTransportSink(ChannelServices.CreateServerChannelSinkChain(this.sinkProvider, this));
int num = this.port;
}
.......
public void StartListening(object data)
{
//GrpcServerTransportSink绑定到port\_55555
this.grpcChannelManager.BindChannel(string.Format("port\_{0}", this.grpcChannelManager.LocalPort), this.transportSink);
}
```
这里的sinkProvider和TcpServerChannel一样，但是transportsink是自己实现的，跟进下
```php
internal sealed class GrpcServerTransportSink : IServerChannelSink, IChannelSinkBase
{
intern...