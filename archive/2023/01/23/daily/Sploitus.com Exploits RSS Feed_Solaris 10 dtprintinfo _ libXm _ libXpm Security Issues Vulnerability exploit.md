---
title: Solaris 10 dtprintinfo / libXm / libXpm Security Issues Vulnerability exploit
url: https://sploitus.com/exploit?id=1337DAY-ID-38170&utm_source=rss&utm_medium=rss
source: Sploitus.com Exploits RSS Feed
date: 2023-01-23
fetch_date: 2025-10-04T04:35:14.105860
---

# Solaris 10 dtprintinfo / libXm / libXpm Security Issues Vulnerability exploit

[x]
Dark Mode

[##### SPLOITUS](/)

# Exploit for Solaris 10 dtprintinfo / libXm / libXpm Security Issues Vulnerability CVE-2004-0687 CVE-2022-46285

2023-01-22 | CVSS 7.5

Copy
Download
Source
[Share](#share-url)

```
## https://sploitus.com/exploit?id=1337DAY-ID-38170
* Title: Multiple vulnerabilities in Solaris dtprintinfo and libXm/libXpm
* Products: Common Desktop Environment 1.6, Motif 2.1, X.Org libXpm < 3.5.15
* OS: Oracle Solaris 10 (CPU January 2021)
* Author: Marco Ivaldi <[emailÂ protected]>
* Date: 2023-01-18
* Oracle vulnerability tracking numbers:
  * S1597707 - Arbitrary printer name injection
  * S1597724 - Heap memory disclosure via long printer names
  * S1597711 - Memory corruption via malformed icon files
  * S1597730 - Stack-based buffer overflow in libXm ParseColors
* CVE IDs:
  * CVE-2022-46285 - Infinite loop on unclosed comments in X.Org libXpm
* Advisory URLs:
  * https://github.com/hnsecurity/vulns/blob/main/HNS-2022-01-dtprintinfo.txt
  * https://lists.x.org/archives/xorg-announce/2023-January/003312.html
  * https://lists.x.org/archives/xorg-announce/2023-January/003313.html
* Exploit URLs:
  * https://github.com/0xdea/exploits/blob/master/solaris/raptor_dtprintlibXmas.c

--[ 0 - Table of contents

1 - Summary
2 - Vulnerabilities
    2.1 - Arbitrary printer name injection
    2.2 - Heap memory disclosure via long printer names
    2.3 - Memory corruption via malformed icon files
    2.4 - Stack-based buffer overflow in libXm ParseColors()
3 - Analysis
    3.1 - Printer name injection and heap memory disclosure
    3.2 - Memory corruption via malformed icon files
4 - Exploitation
5 - Affected products
6 - Remediation
7 - Disclosure timeline
8 - References

--[ 1 - Summary

"What has been will be again,
 what has been done will be done again;
 there is nothing new under the Sun."
                    -- Ecclesiastes 1:9

We have identified multiple security vulnerabilities that are exploitable
via the the setuid-root dtprintinfo binary from the Common Desktop
Environment (CDE) distributed with Oracle Solaris 10 (CPU January 2021):

* A bug in the parser of the lpstat external command invoked by dtprintinfo
  to list the names of available printers allows low-privileged local users
  to inject arbitrary printer names via the $HOME/.printers file.

* Printer name injection allows low-privileged local users to manipulate
  the control flow of the target program and disclose memory contents.
  Based on our analysis, this bug does not seem to be directly exploitable
  to achieve arbitrary code execution. However, we recommend treating it as
  a potential security vulnerability and fix it as such.

* The ability to inject arbitrary printer names opens other attack vectors
  that otherwise would not be available on systems without configured
  printers. As an example, we discovered multiple icon parsing bugs in the
  Motif library libXm that cause memory corruption.

We demonstrated the possibility to exploit one of these memory corruption
bugs, a stack-based buffer overflow in the ParseColors() function of libXm,
to achieve local privilege escalation to root on Solaris 10.

--[ 2 - Vulnerabilities

Following our last CDE vulnerability disclosures [1], Oracle kindly shared
with us a copy of their then current Solaris 10 security patch set (CPU
January 2021), so that we could install it in our lab and verify the fixes
for the bugs we had reported.

In addition to verifying these fixes, we decided to take a closer look at
the dtprintinfo program distributed with CDE, because of its complexity and
its impressive historical record of high-impact vulnerabilities [2]. These
are the results of our research.

--[ 2.1 - Arbitrary printer name injection

After fruitlessly spending a few days reversing and auditing the patched
version of dtprintinfo, we came up with the idea of using the poor man's
fuzzer below to quickly check for the presence of flaws in the parsing of
the $HOME/.printers file:

bash-3.2$ cat /dev/urandom > ~/.printers
^C

Indeed, this led to immediate results. It turns out that it is possible to
inject fake printers to be displayed by dtprintinfo. To do so, we need to
craft a .printers file that contains at least one line in the following
format:

<string><space>:<\n>

Where <string> can be any string, including most special characters, and
<space> can either be a space (0x20) or a tab (0x09) character. For
instance, the following line will inject a fake printer named "FOO":

FOO :

Since dtprintinfo uses printer names as arguments for some external
commands that it invokes, it is possible to abuse this flaw to inject
arbitrary commands. For instance, to execute an injected command when we
double-click on a printer icon in the X11 GUI, we can craft a .printers
file that contains lines such as the following (space and tab characters
cannot be used in the injected command string for obvious reasons):

FOO;/usr/bin/id>/tmp/pwned; :
BAR;/usr/bin/cat</tmp/PAYLOAD; :

Unfortunately for us attackers, dtprintinfo fork()s and permanently drops
root privileges via setuid() before running external commands. Therefore,
the injected commands are executed with regular user privileges. This means
we can only abuse the described printer name injection bug to trigger an
additional second-order vulnerability, if such a vulnerability exists.
Here's a couple of ideas we have experimented with to no avail:

* Use the "cat<PAYLOAD" pattern above to trigger either an integer
  overflow, a buffer overflow, or a format string bug.
* Inject a printer name that contains a format string or a directory
  traversal payload to trigger some other bug down the line.

The third obvious idea is to inject a long printer name and see what
happens. What happened in our case is that we were able to trigger an
out-of-bound read and disclose partial heap memory contents of our target
setuid-root binary.

--[ 2.2 - Heap memory disclosure via long printer names

To reproduce this bug, first craft a malicious .printers file as follows
and create a hardlink to it named .printers.new, to prevent renaming by the
DtConfigPrinters::renameUserPrinterSelectionFile() method that gets called
while dtprintinfo is initializing queues in DtApp::UpdateQueues():

bash-3.2$ echo "FOO;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA; :" > ~/.printers
bash-3.2$ ln ~/.printers ~/.printers.new

Then, trace dtprintinfo's execution via a setuid-root truss program to log
access to interesting memory addresses:

bash-3.2$ export DISPLAY=:0
bash-3.2$ truss -fae -u '*' -u a.out /usr/dt/bin/dtprintinfo -all 2> OUT

At this point, in dtprintinfo's GUI:

* Select "View" > "Select Printers to Show..." from the menu.
* Select the injected printer to be shown.
* Click on "Apply" and then click on "OK".
* Select "Printers" > "Exit" from the menu, closing dtprintinfo.

Now, examining the .printers file modified by dtprintinfo while it was
running, we can notice that it contains non-printable characters, which are
in fact leaked heap memory contents. For instance:

bash-3.2$ od -x ~/.printers
0000000 615f 6c6c 5c20 460a 4f4f 413b 4141 4141
0000020 4141 4141 4141 4141 4141 4141 4141 4141
*
0001000 4141 4141 4141 4141 4141 3b41 0a2c 4141
0001020 4141 4141 4141 4141 4141 4141 4141 4141
*
0001400 4141 4141 4141 4141 4141 4141 4141 e948
0001420 0810 6938 0810 0409 410a 4141 4141 4141
             ^^^^^^^^^                          << 0x08106938
0001440 4141 4141 2c3b 000a
0001447

By observing the output of truss, we can find the example leaked me...