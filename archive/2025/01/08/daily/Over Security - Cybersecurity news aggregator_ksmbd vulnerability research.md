---
title: ksmbd vulnerability research
url: https://blog.doyensec.com/2025/01/07/ksmbd-1.html
source: Over Security - Cybersecurity news aggregator
date: 2025-01-08
fetch_date: 2025-10-06T20:12:38.930296
---

# ksmbd vulnerability research

[

](https://doyensec.com/img/home-video.mp4)

[![](/public/images/doyensec-logo.svg)](/index.html)

[![](/public/images/logo.svg)](/index.html)

#### ABOUT US

We are [**security engineers**](https://doyensec.com) who break bits and tell stories.

Visit us
[doyensec.com](https://doyensec.com)

Follow us
[@doyensec](https://twitter.com/doyensec)

Engage us
info@doyensec.com

#### Blog Archive

* 2025
* 2024
* 2023
* 2022
* 2021
* 2020
* 2019
* 2018
* 2017

© 2025 [Doyensec LLC](https://doyensec.com) [![](/public/images/rss.png)](/atom.xml "RSS")

# ksmbd vulnerability research

07 Jan 2025 - Posted by Norbert Szetei

## Introduction

At Doyensec, we decided to perform a vulnerability research activity on the SMB3 Kernel Server (ksmbd), a component of the Linux kernel. Initially, it was enabled as an experimental feature, but in the kernel version 6.6, the experimental flag was [removed](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=6099776f9f268e61fe5ecd721f994a8cfce5306f), and it remains stable.

Ksmbd splits tasks to optimize performance, handling critical file operations in kernel space and non-performance-related tasks, such as DCE/RPC and user account management, in user space via `ksmbd.mountd`. The server uses a multi-threaded architecture to efficiently process SMB requests in parallel, leveraging kernel worker threads for scalability and user-space integration for configuration and RPC handling.

Ksmbd is not enabled by default, but it is a great target for learning the SMB protocol while also exploring Linux internals, such as networking, memory management, and threading.

The ksmbd kernel component binds directly to port 445 to handle SMB traffic. Communication between the kernel and the `ksmbd.mountd` user-space process occurs via the [Netlink](https://en.wikipedia.org/wiki/Netlink) interface, a socket-based mechanism for kernel-to-user space communication in Linux. We focused on targeting the kernel directly due to its direct reachability, even though `ksmbd.mountd` operates with root privileges.

The illustrative diagram of the architecture can be [found here](https://lore.kernel.org/lkml/20210823025816.7496-7-namjae.jeon%40samsung.com/T/) in the mailing list and is displayed below:

```
               |--- ...
       --------|--- ksmbd/3 - Client 3
       |-------|--- ksmbd/2 - Client 2
       |       |         ____________________________________________________
       |       |        |- Client 1                                          |
<--- Socket ---|--- ksmbd/1   <<= Authentication : NTLM/NTLM2, Kerberos      |
       |       |      | |     <<= SMB engine : SMB2, SMB2.1, SMB3, SMB3.0.2, |
       |       |      | |                SMB3.1.1                            |
       |       |      | |____________________________________________________|
       |       |      |
       |       |      |--- VFS --- Local Filesystem
       |       |
KERNEL |--- ksmbd/0(forker kthread)
---------------||---------------------------------------------------------------
USER           ||
               || communication using NETLINK
               ||  ______________________________________________
               || |                                              |
        ksmbd.mountd <<= DCE/RPC(srvsvc, wkssvc, samr, lsarpc)   |
               ^  |  <<= configure shares setting, user accounts |
               |  |______________________________________________|
               |
               |------ smb.conf(config file)
               |
               |------ ksmbdpwd.db(user account/password file)
                            ^
  ksmbd.adduser ------------|
```

Multiple studies on this topic have been published, including those by [Thalium](https://blog.thalium.re/posts/ksmbd-trailer/) and [pwning.tech](https://pwning.tech/ksmbd-syzkaller/). The latter contains a detailed explanation on how to approach fuzzing from scratch using [syzkaller](https://github.com/google/syzkaller). Although the articleâs grammar is quite simple, it provides an excellent starting point for further improvements we built upon.

We began by intercepting and analyzing legitimate communication using a standard SMB client. This allowed us to extend the syzkaller grammar to include additional commands implemented in [smb2pdu.c](https://elixir.bootlin.com/linux/v6.11/source/fs/smb/server/smb2pdu.c).

During fuzzing, we encountered several challenges, one of which was addressed in the pwning.tech article. Initially, we needed to tag packets to identify the syzkaller instance (procid). This tagging was required only for the first packet, as subsequent packets shared the same socket connection. To solve this, we modified the first (negotiation) request by appending 8 bytes representing the syzkaller instance number. Afterward, we sent subsequent packets without tagging.

Another limitation of syzkaller is its [inability](https://github.com/google/syzkaller/commit/dc5564eb36462b29de4a0dbf85ef9f91df2eecca) to use `malloc()` for dynamic memory allocation, complicating the implementation of authentication in [pseudo syscalls](https://github.com/google/syzkaller/blob/master/docs/pseudo_syscalls.md). To work around this, we patched the relevant authentication (NTLMv2) and packet signature verification checks, allowing us to bypass negotiation and session setup without valid signatures. This enabled the invocation of additional commands, such as ioctl processing logic.

To create more diverse and valid test cases, we initially extracted communication using `strace`, or manually crafted packets. For this, we used Kaitai Struct, either through its [web interface](https://ide.kaitai.io/) or [visualizer](https://github.com/kaitai-io/kaitai_struct_visualizer). When a packet was rejected by the kernel, Kaitai allowed us to quickly identify and resolve the issue.

![Kaitai with SMB grammar](../../../public/images/kaitai1.png)

During our research, we identified multiple security issues, three of which are described in this post. These vulnerabilities share a common trait - they can be exploited without authentication during the session setup phase. Exploiting them requires a basic understanding of the communication process.

## Communication

During KSMBD initialization (whether built into the kernel or as an external module), the startup function `create_socket()` is called to listen for incoming traffic:

```
// https://elixir.bootlin.com/linux/v6.11/source/fs/smb/server/transport_tcp.c#L484
	ret = kernel_listen(ksmbd_socket, KSMBD_SOCKET_BACKLOG);
	if (ret) {
		pr_err("Port listen() error: %d\n", ret);
		goto out_error;
	}
```

The actual data handling occurs in the `ksmbd_tcp_new_connection()` function and the spawned per-connection threads (`ksmbd:%u`). This function also allocates the `struct ksmbd_conn`, representing the connection:

```
// https://elixir.bootlin.com/linux/v6.11/source/fs/smb/server/transport_tcp.c#L203
static int ksmbd_tcp_new_connection(struct socket *client_sk)
{
	// ..
	handler = kthread_run(ksmbd_conn_handler_loop,
			      KSMBD_TRANS(t)->conn,
			      "ksmbd:%u",
			      ksmbd_tcp_get_port(csin));
	// ..
}
```

The `ksmbd_conn_handler_loop` is crucial as it handles reading, validating and processing SMB protocol messages (PDUs). In the case where there are no errors, it calls one of the more specific processing functions:

```
// https://elixir.bootlin.com/linux/v6.11/source/fs/smb/server/connection.c#L395
		if (default_conn_ops.process_fn(conn)) {
			pr_err("Cannot handle request\n");
			break;
		}
```

The processing function adds a SMB request to the worker thread queue:

```
// ksmbd_server_process_request
static int ksmbd_server_process_request(struct ksmbd_conn *conn)
{
	return queue_ksmbd_work(conn);
}
```

This occurs inside `queue_ksmbd_work`, which allocates the `ksmbd_work` structure that wraps the session, connection, and all SMB-related data, while also performing early initialization.

In the Linux kernel, addin...