---
title: 混淆还原的几种方式实践
url: https://www.anquanke.com/post/id/302515
source: 安全客-有思想的安全新媒体
date: 2024-12-11
fetch_date: 2025-10-06T19:36:54.941588
---

# 混淆还原的几种方式实践

首页

阅读

* [安全资讯](https://www.anquanke.com/news)
* [安全知识](https://www.anquanke.com/knowledge)
* [安全工具](https://www.anquanke.com/tool)

活动

社区

学院

安全导航

内容精选

* [专栏](/column/index.html)
* [精选专题](https://www.anquanke.com/subject-list)
* [安全KER季刊](https://www.anquanke.com/discovery)
* [360网络安全周报](https://www.anquanke.com/week-list)

# 混淆还原的几种方式实践

阅读量**428619**

|评论**1**

发布时间 : 2024-12-10 10:13:31

**x**

##### 译文声明

本文是翻译文章

译文仅供参考，具体内容表达以及含义原文为准。

> 作者：@uiop

下面都是使用goron的混淆进行符号执行以及模拟执行处理的结果

# **一、控制流平坦化**

还原前

![]()

还原后

![]()

符号执行和ollvm还原思路相同：

找序言块、真实块、ret块、分发器；在deflate，不同的是需要续住寄存器的值来精准找到下一真实块

![]()

发现赋值在序言块

![]()

思路

在执行真实块之前对x29偏移出进行初始化赋值或者直接将序言块寄存器状态续到真实块对代码进行修改，结合<https://github.com/cq674350529/deflat>的解混淆修改即可简单实现

# **二、间接跳转还原**

分析间接跳转如下，通过手动计算跳转地址（这里是模拟执行获取跳转地址）再根据条件判断将br指令进行替换即可手动还原

![]()

替换指令为br指令以及前一条指令，根据条件指令替换为ture和false的分支跳转

![]()

# 三、混淆全开

先处理间接跳转，通过汇编代码特征找到判断分支csel的两个寄存器值并获取条件指令，条件true和false的值，通过条件获取ldr的两个值，add固定值，然后替换br和上一条指令：b+条件指令true的地址，bfalse地址，找找前人造的轮子<https://bbs.kanxue.com/thread-277086.htm>进行修改即可

while (!finish && !instructions.empty())

{

instructions.pop();

ins = instructions.peek().getIns();

if(ins.getMnemonic().toLowerCase(Locale.ROOT).equals(“add”))

{

String[] split = ins.getOpStr().split(“,”);

if(split.length == 4)

{

//split[0].toLowerCase(Locale.ROOT).trim().equals(“x12”) &&

if(split[3].toLowerCase(Locale.ROOT).trim().equals(“sxtw”))

{

String reg = split[2].trim().toLowerCase(Locale.ROOT);

base = getRegValue(reg,instructions.peek().getRegs()).longValue();

addinstaddr = instructions.peek().getAddr() – module.base;

}

// else {

// break;

// }

}

// else

// {

// break;

// }

}

if(ins.getMnemonic().toLowerCase(Locale.ROOT).equals(“ldr”))

{

String[] sp = ins.getOpStr().toLowerCase().split(“,”);

if(sp.length == 4)

{

//sp[0].trim().toLowerCase(Locale.ROOT).equals(“x12”) &&

if(sp[3].trim().toLowerCase(Locale.ROOT).equals(“uxtw #3]”))

{

String reg = sp[1].toLowerCase(Locale.ROOT).trim().substring(1);

listoffset = getRegValue(reg,instructions.peek().getRegs()).longValue()-module.base;

ldaaddr = instructions.peek().getAddr()- module.base;

}

}

}

if(ins.getMnemonic().trim().toLowerCase(Locale.ROOT).equals(“csel”) || ins.getMnemonic().trim().toLowerCase(Locale.ROOT).equals(“csinc”))

{

String[] sp = ins.getOpStr().toLowerCase(Locale.ROOT).split(“,”);

if(sp.length == 4)

{

cond = sp[3].trim();

if(sp[0].trim().equals(“w10”)&& !sp[2].trim().equals(“wzr”))

{

String reg1 = sp[1].trim();

String reg2 = sp[2].trim();

cond1 = getRegValue(reg1,instructions.peek().getRegs()).longValue();

cond2 = getRegValue(reg2,instructions.peek().getRegs()).longValue();

selectaddr = instructions.peek().getAddr() – module.base;

}

if(sp[0].trim().equals(“w10”)&& sp[2].trim().equals(“wzr”))

{

String reg1 = sp[1].trim();

cond1 = getRegValue(reg1,instructions.peek().getRegs()).longValue();

cond2 = 1;

selectaddr = instructions.peek().getAddr() – module.base;

}

}

}

if(ins.getMnemonic().trim().toLowerCase(Locale.ROOT).equals(“subs”) && ins.getOpStr().trim().toLowerCase(Locale.ROOT).equals(“w8, w9, w8”))

{

if(base == -1 || listoffset == -1 || cond1 == -1 || cond2 == -1 || cond.equals(“”) || addinstaddr == -1 || ldaaddr == -1 || selectaddr == -1)

{

break;

}

else

{

long offset1 = base + readInt64(emulator.getBackend(), module.base+listoffset+cond1\*8) – module.base;

long offset2 = base + readInt64(emulator.getBackend(),module.base+listoffset+cond2\*8) – module.base;

if( brinsaddr – addinstaddr != 4)

{

System.out.println(“add ins and br ins gap more than 4 size,may make mistake”);

}

String condBr = “b”+cond.toLowerCase(Locale.ROOT) + ” 0x”+ Integer.toHexString((int) (offset1 – addinstaddr));

String br = “b 0x” + Integer.toHexString((int)(offset2 – brinsaddr));

还原前不能f5：

![]()

还原后还存在平坦化：

![]()

获取执行流

![]()

再根据执行流patch之后即可还原

![]()

#

# **四、总结**

符号执行在处理类似ollvm每个块都已经初始化好的比较好处理，模拟执行处理复杂运算的跳转好用，发现都得结合手动还原，工具只是代替手动部分的批量实现，所以本质还是手动还原的结果；或许ai训练总结算式自动编写d810的配置可能效果更要好一些

参考：

<https://github.com/cq674350529/deflat>

<https://bbs.kanxue.com/thread-277086.htm>

<https://github.com/amimo/goron>

本文翻译自 原文链接。如若转载请注明出处。

商务合作，文章发布请联系 anquanke@360.cn

本文由**360安全应急响应中心**原创发布

转载，请参考[转载声明](https://www.anquanke.com/note/repost)，注明出处： [https://www.anquanke.com/post/id/302515](/post/id/302515)

安全KER - 有思想的安全新媒体

本文转载自:

如若转载,请注明出处：

安全KER - 有思想的安全新媒体

分享到：![微信](https://p0.ssl.qhimg.com/sdm/28_28_100/t01e29062a5dcd13c10.png)

* [混淆还原](/tag/%E6%B7%B7%E6%B7%86%E8%BF%98%E5%8E%9F)

**+1**12赞

收藏

![](https://p3.ssl.qhmsg.com/dm/200_200_100/t01b5d8fecc4d01072b.jpg)360安全应急响应中心

分享到：![微信](https://p0.ssl.qhimg.com/sdm/28_28_100/t01e29062a5dcd13c10.png)

## 发表评论

您还未登录，请先登录。

[登录](/login/index.html)

![](https://p2.ssl.qhimg.com/t014757b72460d855bf.png)

[![](https://p3.ssl.qhmsg.com/dm/200_200_100/t01b5d8fecc4d01072b.jpg)](/member.html?memberId=122586)

[360安全应急响应中心](/member.html?memberId=122586)

360安全应急响应中心（360 Security Response Center，简称360SRC）是360公司致力于保障产品及业务安全，促进白帽专家合作与交流的平台。诚邀白帽专家向我们反馈360产品安全漏洞、威胁情报，共筑数字安全基石，保障数亿用户业务和产品的安全。

* 文章
* **67**

* 粉丝
* **13**

### TA的文章

* ##### [Python代码保护之重置操作码映射的攻与防探究（一）](/post/id/311484)

  2025-08-26 10:49:47
* ##### [诚邀莅临|三六零天御·亚马逊云科技安全合规沙龙](/post/id/308420)

  2025-06-13 14:18:45
* ##### [360 MCP 生态安全风险治理实践与思考](/post/id/307934)

  2025-05-29 11:07:56
* ##### [ingress-nightmare 漏洞利用分析与 k8s 相关组件理解](/post/id/306494)

  2025-04-14 15:24:44
* ##### [基于 RAG 提升大模型安全运营效率](/post/id/306214)

  2025-04-03 19:07:23

### 相关文章

* ##### [为AI Agent行为立“规矩”——字节跳动提出Jeddak AgentArmor智能体安全框架](/post/id/312426)

  2025-09-28 13:43:32
* ##### [教你打造一款AI安全助手 | 安全MCP的实践指南](/post/id/311884)

  2025-09-05 10:40:51
* ##### [当数字世界的“万能钥匙”被滥用，谁来守护核心资产？火山的 MCP 安全授权新范式](/post/id/311597)

  2025-08-28 09:50:41
* ##### [Python代码保护之重置操作码映射的攻与防探究（一）](/post/id/311484)

  2025-08-26 10:49:47
* ##### [广汽集团×火山引擎：出海合规助力企业新增长](/post/id/311498)

  2025-08-26 10:17:09
* ##### [从技术到安全：中科固源拆解车载以太网的演进路径与防护策略](/post/id/310094)

  2025-08-21 21:48:41
* ##### [智能体防御 | 一文了解3种系统提示词加固方法](/post/id/311279)

  2025-08-18 16:34:50

### 热门推荐

文章目录

![](https://p0.qhimg.com/t11098f6bcd5614af4bf21ef9b5.png)

安全KER

* [关于我们](/about)
* [联系我们](/note/contact)
* [用户协议](/note/protocol)
* [隐私协议](/note/privacy)

商务合作

* [合作内容](/note/business)
* [联系方式](/note/contact)
* [友情链接](/link)

内容需知

* [投稿须知](https://www.anquanke.com/contribute/tips)
* [转载须知](/note/repost)
* 官网QQ群：568681302

合作单位

* [![安全KER](https://p0.ssl.qhimg.com/t01592a959354157bc0.png)](http://www.cert.org.cn/)
* [![安全KER](https://p0.ssl.qhimg.com/t014f76fcea94035e47.png)](http://www.cnnvd.org.cn/)

Copyright © 北京奇虎科技有限公司 三六零数字安全科技集团有限公司 安全KER All Rights Reserved [京ICP备08010314号-66](https://beian.miit.gov.cn/)[![](https://icon.cnzz.com/img/pic.gif)](https://www.cnzz.com/stat/website.php?web_id=1271278035 "站长统计")

微信二维码

**X**![安全KER](https://p0.ssl.qhimg.com/t0151209205b47f2270.jpg)