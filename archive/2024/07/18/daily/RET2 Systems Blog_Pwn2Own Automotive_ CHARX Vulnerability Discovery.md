---
title: Pwn2Own Automotive: CHARX Vulnerability Discovery
url: https://blog.ret2.io/2024/07/17/pwn2own-auto-2024-charx-bugs/
source: RET2 Systems Blog
date: 2024-07-18
fetch_date: 2025-10-06T17:43:16.753629
---

# Pwn2Own Automotive: CHARX Vulnerability Discovery

# [![](/assets/img/logo-full.svg)](/) ENGINEERING BLOG

[# Pwn2Own Automotive: CHARX Vulnerability Discovery](/2024/07/17/pwn2own-auto-2024-charx-bugs/)

## Abusing Subtle C++ Destructor Behavior for a UAF July 17, 2024 / Jack Dates

---

The first [Pwn2Own Automotive](https://www.zerodayinitiative.com/blog/2023/8/28/revealing-the-targets-and-rules-for-the-first-pwn2own-automotive) introduced an interesting category of targets: electric vehicle chargers. This post will detail some of our research on the Phoenix Contact [CHARX SEC-3100](https://www.phoenixcontact.com/en-us/products/ac-charging-controller-charx-sec-3100-1139012) and the bugs we discovered, with a [2nd separate post](https://blog.ret2.io/2024/07/24/pwn2own-auto-2024-charx-exploit/) covering the actual exploit.

Weâve adapted the fundamental bug pattern into a challenge hosted on our in-browser WarGames platform [here](https://wargames.ret2.systems/level/charxpost_destructors), if you want a hands-on attempt at exploiting the rather interesting C++ issue we discovered.

Although an EV charger may initially seem like an âexoticâ target with non-standard protocols and physical interfaces, once those are figured out, everything eventually boils down to some binary consuming untrusted input (e.g. from the network), and all the classic memory corruption principles apply.

[![](/assets/img/pwn2own_auto24_charx_header.jpg)](/assets/img/pwn2own_auto24_charx_header.jpg)

## Why the CHARX?

The CHARX was an appealing target for two primary reasons. The first was simply how different it is as a product compared to the other chargers. While the rest of the targets seemed more retail / consumer facing, the CHARX is more âindustrial,â a DIN-rail mounted unit seemingly more for infrastructure than actual charging. Its status as an outlier immediately piqued our interest.

Another more practical reason was that the firmware could be easily downloaded from the manufacturerâs website, and was not encrypted. The provided `.raucb` bundle is intended for use with [rauc](https://github.com/rauc/rauc), but can also be treated as a squashfs filesystem image for mounting or extracting directly.

## Recon - Mapping Attack Surface

Once we had decided to actively perform research against the CHARX, we began by enumerating and evaluating potential attack surface.

The CHARX runs a custom embedded version of Linux for 32-bit ARM. SSH is enabled by default, with the unprivileged user `user-app` having default password `user`.

In terms of physical ports, the two of interest to us were the two ethernet ports, labeled ETH0 and ETH1. ETH0 is intended to provide a connection to the âoutside world,â most likely a larger network and/or the Internet, whereas ETH1 is intended to connect to the ETH0 port of an additional CHARX. In this manner, CHARX units can be daisy-chained such that they all communicate.

Firewall rules within `/etc/firewall/rules` define which ports (and therefore services) are accessible on these two interfaces. With these rules, some time poking around the system via ssh, and brief reverse engineering, we ended up with the following rough âmapâ of services, a guide indicating possible attack surface:

[![](/assets/img/pwn2own_auto24_charx_services.svg)](/assets/img/pwn2own_auto24_charx_services.svg)

CHARX remote attack surface

Some services can be interfaced with directly through their TCP servers, while several can only be addressed indirectly through [MQTT](https://mqtt.org/) messages. MQTT employs a publish-subscribe model where a client can subscribe to any number of topics, and when any client publishes a message to a topic, the message will be forwarded to all subscribers.

Most of the binaries for these services are located at `/usr/sbin/Charx*`. Most services are [Cython](https://cython.org/) based, where python code (with some extra syntax for native functionality) is compiled into native binaries / shared objects instead of being interpreted.

Reverse engineering Cython proved tedious, so we chose to focus mostly on the Controller Agent service, a native C++ binary.

## Controller Agent Overview

The controller agent is represented towards the upper left of the attack-surface diagram, and is reachable over the eth1 port / interface.
This port is intended to connect to an additional CHARX, but in our attack scenario weâll be connecting a machine directly.

To provide some context, we came across three main functions of the controller agent:

* manage communication between other daisy-chained CHARX units
* manage the AC controller (a separate MCU on the board)
* V2G (vehicle-to-grid) protocol messaging (related to vehicles selling electricity back to the grid)

In terms of actual interaction, the agent can be talked to over UDP, TCP, and the HomePlug Green PHY protocol.
Weâll give a brief overview of each communication channel, and discuss specifics later as they become relevant.

### TCP JSON Messaging

The TCP server is conceptually the simplest method of communication. The agent listens on port 4444, accepts messages in JSON format, and provides JSON responses.

Each message is a JSON object with the following format:

{

"operationName": "deviceInfo", // operation requested

"deviceUid": "root",           // target device of operation

"operationId": 0,              // reference ID to echo in response

"operationParameters": {}      // optional operation-specific params

}

The `deviceUid` field specifies the target device in a âdevice treeâ of sorts maintained by the agent. For our purposes, this will mostly be `root` to indicate the controller agent itself, but there is also a device node representing the AC controller MCU, and there would be other nodes for daisy-chained units if they existed and had performed the proper âhandshake.â

Some of the supported operations are:

* `deviceInfo` : obtain info for specified device
* `childDeviceList` : list children in device tree
* `dataAccess` : generic hardware data e.g. reading temperature of AC controller (unsupported by root agent)
* `configAccess` : read/write configuration variables
* `heartbeat`
* `v2gMessage` : proxies / handles V2G messages / responses

If the target device is the agent itself, the message is handled directly. Otherwise it gets forwarded to the proper device (e.g. proxied to a daisy-chained CHARX).

### UDP Broadcast Discovery

UDP is primarily used for autodiscovery of daisy-chained units, after which communication would occur over TCP. This is done with UDP broadcast packets on port 4444.

The basic idea is:

* root agent broadcasts a `deviceInfo` JSON request message
* daisy-chained sub-agent responds
* root agent gets IP from response, uses it to connect to sub-agent over TCP port 4444

There isnât much complexity here, since itâs simply for initial discovery.

### HomePlug

[HomePlug](https://en.wikipedia.org/wiki/HomePlug) is a family of protocols for powerline communications (PLC). That is, transmitting data over electrical wiring.
Specifically, the HomePlug Green PHY protocol is the one relevant here.

The protocol is defined in terms of standard ethernet packets. In practice, a dedicated SoC (e.g. some Qualcomm chip) would perform the translation of ethernet packets into raw powerline signals, and vice versa.
It would seem these chips are present on certain CHARX models (although not the 3100 model we had for the contest), intended to be exposed to Linux userspace as interface `eth2` (compared to the physical ethernet ports for `eth0` and `eth1`).

The usage of PLC is interesting and provides some background, but is ultimately irrelevant, since the protocol is just ethernet, and we only need to concern ourselves with sending / receiving raw packets.
Ethernet / layer-2 packets have a 10-byte header followed by the data payload.

[![](https://upload.wikimedia.org/wikipedia/commons/thumb/1/13/Ethernet_Type_II_Frame_format.svg/2880px-Ethernet_Type_II_Frame_format.svg.png)](ht...