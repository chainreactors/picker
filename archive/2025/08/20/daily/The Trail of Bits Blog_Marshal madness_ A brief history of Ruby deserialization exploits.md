---
title: Marshal madness: A brief history of Ruby deserialization exploits
url: https://blog.trailofbits.com/2025/08/20/marshal-madness-a-brief-history-of-ruby-deserialization-exploits/
source: The Trail of Bits Blog
date: 2025-08-20
fetch_date: 2025-10-07T00:47:50.634335
---

# Marshal madness: A brief history of Ruby deserialization exploits

[The Trail of Bits Blog](/ "The Trail of Bits Blog")

[![Trail of Bits Logo](/img/tob.png)](https://trailofbits.com "Trail of Bits")

# Marshal madness: A brief history of Ruby deserialization exploits

Matt Schwager

August 20, 2025

[vulnerabilities](/categories/vulnerabilities/), [exploits](/categories/exploits/), [ruby](/categories/ruby/)

Page content

* [Understanding Marshal deserialization vulnerabilities](#understanding-marshal-deserialization-vulnerabilities)
* [The beginning: An unassuming bug tracker issue](#the-beginning-an-unassuming-bug-tracker-issue)
* [The explosion: Security researchers riffing](#the-explosion-security-researchers-riffing)
* [The modern era: Robust gadget discovery](#the-modern-era-robust-gadget-discovery)
* [The future: Ending Marshal madness](#the-future-ending-marshal-madness)

Documenting the evolution of exploitation techniques serves a crucial purpose in security engineering: it helps us understand not just individual vulnerabilities but the systemic patterns that resist conventional fixes. The story of deserialization exploits in Ruby’s [Marshal module](https://ruby-doc.org/3.4.1/Marshal.html) offers a uniquely well-documented case study of this phenomenon. That is, a decade-long cycle of patches and bypasses that reveals the futility of addressing symptoms rather than root causes.

This history matters because it demonstrates why certain classes of vulnerabilities persist despite our best efforts. By tracing how we got here, we can better understand why fundamental changes to the Ruby ecosystem are necessary, rather than continued reliance on the patch-and-hope approach that has thus far failed to solve the problem.

It’s worth noting that Trail of Bits has been [documenting Ruby deserialization bugs](https://trailofbits.github.io/rubysec/) since at least 2015, although these are in JSON and YAML data formats. Hal Brodigan, a Trail of Bits employee from 2012 to 2015, documented even [earlier Ruby examples](https://ronin-rb.dev/blog/2013/01/09/rails-pocs.html) as well. Additionally, [Java has CVEs](https://nvd.nist.gov/vuln/detail/CVE-2011-2894) going back to 2011 and [PHP to 2007](https://nvd.nist.gov/vuln/detail/cve-2007-1701) regarding deserialization of untrusted data. For this reason, I’ve decided to focus primarily on Ruby Marshal deserialization in this post and avoid the long-tail of *all* serialization formats and programming languages. And with that, here is a brief look at the evolution of Marshal deserialization exploits:

![A timeline of Ruby deserialization exploits](/img/ruby-deserialization-exploits-timeline.svg)

## Understanding Marshal deserialization vulnerabilities

It’s December 12, 2024. Somewhere in the Ruby language’s CI servers version [3.4.0-rc1](https://github.com/ruby/ruby/releases/tag/v3_4_0_rc1) has just been released. Unbeknownst to Ruby developers, a subtle bug exists that allows for Marshal deserialization exploitation. This code had not been touched for [16 years](https://github.com/ruby/ruby/blame/v3_4_0_rc1/lib/rubygems/version.rb#L291), so there’s no reason to suspect a thing. However, a few weeks prior Luke Jahnke had published a [new Marshal exploitation technique](https://nastystereo.com/security/ruby-3.4-deserialization.html), but word had not gotten around yet. Just before Christmas day a [patch is merged](https://github.com/ruby/ruby/pull/12444) and Ruby 3.4.0 is eventually released without the vulnerable code. Crisis averted.

If the unpatched code were released, then a Rails controller like the following would have been vulnerable:

```
class UserRestoreController < ApplicationController
  def show
    # A user data restoration controller somewhere...
    user_data = params[:data]
    if user_data.present?
      deserialized_user = Marshal.load(Base64.decode64(user_data))
      user_object = UserObject.new(data: deserialized_user)
      user_object.save!
      render plain: "User data saved successfully: #{deserialized_user.inspect}"
    else
      render plain: "No data provided", status: :bad_request
    end
  end
end
```

Figure 1: A Rails controller performing Marshal deserialization

Generally, you will not see code as contrived as the snippet above, but the Marshal format often makes its way into back-end systems like [caching layers](https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf) or when [storing Ruby objects on the filesystem](https://hackerone.com/reports/473888). Simply put, passing untrusted input to `Marshal.load` should be considered an arbitrary code execution vulnerability. Building exploits for this type of vulnerability is beyond the scope of this post and has been exhaustively covered in sources linked below (see Jahnke 2024). However, generally it would require sending a Marshal-formatted sequence of bytes like the following to the Rails controller in figure 1:

```
"\x04\b[\ac\x15Gem::SpecFetcherU:\x11Gem::Version[\x06o:\x1EGem::RequestSet::Lockfile\n:\t@seto:\x14Gem::RequestSet\x06:\x15@sorted_requests[\ao:%Gem::Resolver::SpecSpecification\x06:\n@speco:$Gem::Resolver::GitSpecification\a:\f@sourceo:\x15Gem::Source::Git\n:\t@gitI\"\bzip\x06:\x06ET:\x0F@referenceI\"\x10/etc/passwd\x06;\x10T:\x0E@root_dirI\"\t/tmp\x06;\x10T:\x10@repositoryI\"\bany\x06;\x10T:\n@nameI\"\bany\x06;\x10T;\vo:!Gem::Resolver::Specification\a;\x14I\"\bany\x06;\x10T:\x12@dependencies[\x00o;\n\x06;\vo;\f\a;\ro;\x0E\n;\x0FI\"\bzip\x06;\x10T;\x11I\"*-TmTT=\"$(id>/tmp/marshal-poc)\"any.zip\x06;\x10T;\x12I\"\t/tmp\x06;\x10T;\x13I\"\bany\x06;\x10T;\x14I\"\bany\x06;\x10T;\vo;\x15\a;\x14I\"\bany\x06;\x10T;\x16[\x00;\x16[\x00:\x13@gem_deps_fileI\"\x11/private/tmp\x06;\x10T:\x12@gem_deps_dirI\"\r/private\x06;\x10T:\x0F@platforms[\x00"
```

Figure 2: An example Marshal deserialization exploit payload

Thankfully the new exploitation vector mentioned earlier was patched before Ruby 3.4.0 was released, but, as we’ll see, patching eventually becomes an exercise in futility. To understand how we got here, first we must understand where we’ve been.

## The beginning: An unassuming bug tracker issue

In the beginning, Charlie Somerville (now [Hailey](https://github.com/haileys)) created a [Ruby bug tracker issue](https://bugs.ruby-lang.org/issues/7759) on January 31, 2013. It discusses the dangers of [`Marshal.load`](https://ruby-doc.org/core-2.0.0/Marshal.html#module-Marshal-label-Security+considerations) in Ruby version 2.0.0. There may have been some private correspondence between Hailey and the Ruby team on the security mailing list before this issue was created, but I’ll call this issue the beginning of the Marshal deserialization exploitation lineage.

Before running off to find earlier examples, consider the point I’m trying to make here: that there is a direct link between Hailey’s issue and modern Ruby deserialization exploit development. This post is not about finding the earliest reference to Marshal deserialization bugs—it’s instead about tracing an evolution of thought and development of exploits.

From here, the story picks back up on May 6, 2016 in [Phrack #69](https://phrack.org/issues/69/12.html). Ahh Phrack, our old friend. It’s a good thing this Phile made it into #69 because [#70](https://phrack.org/issues/70/1) would come out over five years later. The concept of Marshal deserialization exploitation finds its way into a subsection of a section of a Phile of a Phrack Issue. It targeted Marshal deserialization in Ruby on Rails versions 3 and 4. The Phile’s author, joernchen, directly credits Hailey Somerville and then immediately states that the technique is patched in Rails 4.1 unless you modify the default behavior. The life and death of an exploit. This marks the end of the beginning. From here on out, Ruby deserialization exploitation will explode in both popularity and creativity.

## The explosion: Security researchers riffing

On November 8, 2018, Luke Jahnke published a blog...