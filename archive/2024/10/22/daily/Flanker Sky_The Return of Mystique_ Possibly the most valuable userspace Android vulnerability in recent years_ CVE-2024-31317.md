---
title: The Return of Mystique? Possibly the most valuable userspace Android vulnerability in recent years: CVE-2024-31317
url: https://blog.flanker017.me/cve-2024-31317/
source: Flanker Sky
date: 2024-10-22
fetch_date: 2025-10-06T18:50:19.633905
---

# The Return of Mystique? Possibly the most valuable userspace Android vulnerability in recent years: CVE-2024-31317

# [Flanker Sky](https://blog.flanker017.me/ "Flanker Sky")

## About security and coding

Menu
[Skip to content](#content "Skip to content")

* [Home](https://blog.flanker017.me/)
* [An online source browsing site](https://blog.flanker017.me/an-online-source-browsing-site/)
* [Contact & GPG](https://blog.flanker017.me/contact-gpg/)
* [Publications & Presentations](https://blog.flanker017.me/publications-presentations/)
* [关于我 & My CVEs](https://blog.flanker017.me/about-me/)
* [微信公众号，欢迎关注](https://blog.flanker017.me/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%8C%E6%AC%A2%E8%BF%8E%E5%85%B3%E6%B3%A8/)

# The Return of Mystique? Possibly the most valuable userspace Android vulnerability in recent years: CVE-2024-31317

[3 Replies](https://blog.flanker017.me/cve-2024-31317/#comments)

# Abstract

This article analyzes the cause of CVE-2024-31317, an Android user-mode universal vulnerability, and shares our exploitation research and methods. Through this vulnerability, we can obtain code-execution for any uid, similar to breaking through the Android sandbox to gain permissions for any app. This vulnerability has effects similar to [the Mystique vulnerability discovered by the author years ago (which is the little horse in the title image – the Pwnie Award for Best Privilege Escalation Bug at the hacker Oscars)](https://dawnslab.jd.com/mystique/), but each has its own merits.

# Origin of the Vulnerability

A few months ago, [Meta X Red Team](https://rtx.meta.security/exploitation/2024/06/03/Android-Zygote-injection.html) published two very interesting Android Framework vulnerabilities that could be used to escalate privileges to any UID. Among them, CVE-2024-0044, due to its simplicity and directness, has already been widely analyzed in the technical community with public exploits available (it’s worth mentioning that people were later surprised to find that [the first fix for this vulnerability was actually ineffective](https://github.com/canyie/CVE-2024-0044)). Meanwhile, CVE-2024-31317 still lacks a public detailed analysis and exploit, although the latter has greater power than the former (able to obtain system-uid privileges). This vulnerability is also quite surprising, because it’s already 2024, and we can still find command injection in Android’s core component (Zygote).

This reminds us of the [Mystique vulnerability](https://dawnslab.jd.com/mystique/) we discovered years ago, which similarly allowed attackers to obtain privileges for any uid. It’s worth noting that both vulnerabilities have certain prerequisites. For example, CVE-2024-31317 requires the `WRITE_SECURE_SETTINGS` permission. Although this permission is not particularly difficult to obtain, it theoretically still requires an additional vulnerability, as ordinary `untrusted_app`s cannot obtain this permission (however, it seems that on some branded phones, regular apps may have some methods to directly obtain this permission). ADB shell natively has this permission, and similarly, some special pre-installed signed apps also have this permission.

However, the exploitation effect and universality of this logical vulnerability are still sufficient to make us believe that it is the most valuable Android user-mode vulnerability in recent years since Mystique. Meta’s original article provides an excellent analysis of the cause of this vulnerability, but it only briefly touches on the exploitation process and methods, and is overall rather concise. This article will provide a detailed analysis and introduction to this vulnerability, and introduce some new exploitation methods, which, to our knowledge, are the first of their kind.

Attached is an image demonstrating the exploit effect, successfully obtaining system privilege on major phone brand’s June patch version:

![demo](https://i2.wp.com/s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2024-08-22-11-358KzyvzGbYs9Ce11Z.gif?w=625&ssl=1)![demo](https://i2.wp.com/s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2024-08-22-11-358KzyvzGbYs9Ce11Z.gif?w=625&ssl=1)

## Analysis of this vulnerability

Although the core of this vulnerability is command injection, exploiting it requires a considerable understanding of the Android system, especially how Android’s cornerstone—the Zygote fork mechanism—works, and how it interacts with the system\_server.

### Zygote and system\_server bootstrap process

Every Android developer knows that Zygote forks all processes in Android’s Java world, and system\_server is no exception, as shown in the figure below.

![zygoteandsystemserver](https://i1.wp.com/s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2024-08-21-14-34fzSmVTWa34tDZZYP.png?w=625&ssl=1)![zygoteandsystemserver](https://i1.wp.com/s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2024-08-21-14-34fzSmVTWa34tDZZYP.png?w=625&ssl=1)

The Zygote process actually receives instructions from system\_server and spawns child processes based on these instructions. This is implemented through the poll mechanism in [ZygoteServer.java](https://cs.android.com/android/platform/superproject/main/%2B/main%3Aframeworks/base/core/java/com/android/internal/os/ZygoteServer.java;l=521;drc=efb735f4d5a2f04550e33e8aa9485f906018fe4e):

```
 Runnable runSelectLoop(String abiList) {
 //...
 if (pollIndex == 0) {
                        // Zygote server socket
                        ZygoteConnection newPeer = acceptCommandPeer(abiList);
                        peers.add(newPeer);
                        socketFDs.add(newPeer.getFileDescriptor());
                    } else if (pollIndex < usapPoolEventFDIndex) {
                        // Session socket accepted from the Zygote server socket

                        try {
                            ZygoteConnection connection = peers.get(pollIndex);
                            boolean multipleForksOK = !isUsapPoolEnabled()
                                    && ZygoteHooks.isIndefiniteThreadSuspensionSafe();
                            final Runnable command =
                                    connection.processCommand(this, multipleForksOK);

                            // TODO (chriswailes): Is this extra check necessary?
                            if (mIsForkChild) {
                                // We're in the child. We should always have a command to run at
                                // this stage if processCommand hasn't called "exec".
                                if (command == null) {
                                    throw new IllegalStateException("command == null");
                                }

                                return command;
                            } else {
                                // We're in the server - we should never have any commands to run.
                                if (command != null) {
                                    throw new IllegalStateException("command != null");
                                }

                                // We don't know whether the remote side of the socket was closed or
                                // not until we attempt to read from it from processCommand. This
                                // shows up as a regular POLLIN event in our regular processing
                                // loop.
                                if (connection.isClosedByPeer()) {
                                    connection.closeSocket();
                                    peers.remove(pollIndex);
                                    socketFDs.remove(pollIndex);
                                }
                            }
                        }

                        //...
      Runnable processCommand(ZygoteServer zygoteServer, boolean multipleOK) {
        ZygoteArguments parsedArgs;
```

Then it enters the `processCommand` function, which is the core function for parsing the command buffer and extracting parameters. The specific format is defined in `ZygoteArguments`, and much of our subsequent work will need to revo...