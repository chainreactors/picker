---
title: Trivial C# Random Exploitation
url: https://blog.doyensec.com/2025/08/19/trivial-exploit-on-C-random.html
source: Over Security - Cybersecurity news aggregator
date: 2025-08-20
fetch_date: 2025-10-07T00:49:45.295200
---

# Trivial C# Random Exploitation

[

](https://doyensec.com/img/home-video.mp4)

[![](/public/images/doyensec-logo.svg)](/index.html)

[![](/public/images/logo.svg)](/index.html)

#### ABOUT US

We are [**security engineers**](https://doyensec.com) who break bits and tell stories.

Visit us
[doyensec.com](https://doyensec.com)

Follow us
[@doyensec](https://twitter.com/doyensec)

Engage us
info@doyensec.com

#### Blog Archive

* 2025
* 2024
* 2023
* 2022
* 2021
* 2020
* 2019
* 2018
* 2017

© 2025 [Doyensec LLC](https://doyensec.com) [![](/public/images/rss.png)](/atom.xml "RSS")

# Trivial C# Random Exploitation

19 Aug 2025 - Posted by Dennis Goodlett

Exploiting random number generators requires math, right? Thanks to C#âs
`Random`, that is not necessarily the case! I ran into an HTTP 2.0 web service
issuing password reset tokens from a custom encoding of `(new Random()).Next(min, max)` output.
This led to a critical account takeover.
Exploitation did not require scripting, math or libraries. Just several clicks
in Burp. While I had source code, I will show a method of discovering and
exploiting this vulnerability in a black-box or bug-bounty style engagement.

The exploit uses no math, but I do like math. So, there is a bonus section on how to
optimize and invert `Random`.

## The Vulnerability

I canât share the client code, but it was something like this:

```
var num = new Random().Next(min, max);
var token = make_password_reset_token(num);
save_reset_token_to_db(user, token);
return issue_password_reset(user.email, token);
```

This represents a typical password reset. The token is created using `Random()`, and there is no
seed. This gets encoded to an alphanumeric token. The token is sent to the user
in email. The user can then log in with their email and token.

This may be trivially exploitable.

## How the C# PRNG Works

Somehow documentation linked me to the following reference implementation. This
is not the real implementation, but itâs good enough. Donât get into
the weeds here, the `Random(int Seed)` is only displayed for the sake of
context.

[Git link](https://github.com/microsoft/referencesource/blob/f7df9e2399ecd273e90908ac11caf1433e142448/mscorlib/system/random.cs#L52-L82)

```
      public Random()
        : this(Environment.TickCount) {
      }

      public Random(int Seed) {
        int ii;
        int mj, mk;

        //Initialize our Seed array.
        //This algorithm comes from Numerical Recipes in C (2nd Ed.)
        int subtraction = (Seed == Int32.MinValue) ? Int32.MaxValue : Math.Abs(Seed);
        mj = MSEED - subtraction;
        SeedArray[55]=mj; // [2]
        mk=1;
        for (int i=1; i<55; i++) {  //Apparently the range [1..55] is special (Knuth) and so we're wasting the 0'th position.
          ii = (21*i)%55;
          SeedArray[ii]=mk;
          mk = mj - mk;
          if (mk<0) mk+=MBIG;
          mj=SeedArray[ii];
        }
        for (int k=1; k<5; k++) {
          for (int i=1; i<56; i++) {
        SeedArray[i] -= SeedArray[1+(i+30)%55];
        if (SeedArray[i]<0) SeedArray[i]+=MBIG;
          }
        }
        inext=0;
        inextp = 21;
        Seed = 1;
      }
```

This whole system hinges on the 32 bit `Seed`. This builds the internal state
(`SeedArray[55]`) with some ugly math. If `Random` is initialized without an
argument, the `Environment.TickCount` is used as `Seed`. All output of a PRNG
is determined by its seed. In this case, itâs the
[TickCount](https://learn.microsoft.com/en-us/dotnet/api/system.environment.tickcount?view=net-9.0)

* essentially just time. So you can think of this whole algorithm as
  emailing you the time, just with a very odd encoding.

In some sense, you can even submit a time to encode. You do this, not with a
URL parameter but by waiting. Wait for the right time and you get the encoding
you want. What time, or event, should we wait for?

## The Exploit

The [documentation](https://learn.microsoft.com/en-us/dotnet/api/system.random.-ctor?view=net-9.0) says it best.

> In .NET Framework, the default seed value is derived from the system clock, which has finite resolution. As a result, different `Random` objects that are created in close succession by a call to the parameterless constructor have identical default seed values and, therefore, produce identical sets of random numbers.

If we submit two requests in the same 1ms window, we get the same `Seed`, same
seed same output, same reset token sent to two email addresses. One email we own
of course, the other belongs to an admin.

How do we hit the 1ms window? We use the [single packet attack](https://portswigger.net/research/the-single-packet-attack-making-remote-race-conditions-local).

Will it really work though?

## Blackbox Methodology

You donât want to go spamming admins with reset emails before you even verify
the vulnerability. So make two accounts on the website that you control. While
you can do the attack with one account, itâs prone to false positives. Youâre
sending two account resets in rapid succession. The second request may write a
different reset token to the DB before the email service reads the first,
resulting in a false positive.

Use Burpâs repeater groups to perform the single packet attack to reset both
accounts. Check your email for duplicate tokens. If you fail, go on testing
other stuff until the lockout window dies. Then just hit send again, likely you
donât need to worry about keeping a session token alive.

Note: Burp displays round trip time in the lower-right corner of Repeater.

![Route Trip Time of request 4 in Race group](../../../public/images/csharp_prng_repeater_time.png)

Keep an eye on that number. Each request has its own time. For me, it took
about 10 requests before I got a duplicate token. That only occurred when the
difference in round trip times was 1ms or less.

When launching the actual exploit, the only way to check if your token matches
the victim accountâs, is to log in. Login requests tend to be rate limited and
guarded. So first verify with testing accounts. Use that to obtain a delta time
window that works. Then, when launching the actual exploit, only attempt to log in
when the delta time is within your testing bounds.

**Ahâ¦ I guess subtracting two times counts as math. Exploiting PRNGâs always
require math.**

## Wrapping Up

This attack is not completely novel. I have seen similar attacks used in CTFs.
Itâs a nice lesson on time though. We control time by
waiting, or not waiting. If a secret token is just an encoded time, you can
duplicate them by duplicating time.

If you look into the .NET runtime enough, you can convince yourself this attack
wonât work. `Random` has more then one implementation, the one my client should have used [does not seed by
time](https://github.com/dotnet/runtime/blob/6454b4c4b99c39fa896367a85a1367adc789a7c0/src/libraries/System.Private.CoreLib/src/System/Random.Xoshiro128StarStarImpl.cs#L38).
I can even prove this with [dotnetfiddle](https://dotnetfiddle.net/5xlOSj).
This is like the security version of âit works on my computerâ. This is why we
test âsecureâ code and why we fuzz with random input. So try this exploit next
time you see a security token.

This applies to more then just C#âs `Random`. Consider Pythonâs `uuid`?
The [documentation](https://docs.python.org/3/library/uuid.html) warns of potential
collisions due to lack of âsynchronizationâ depending on âunderlying platformâ,
unless `safeUUID` is used. I wonder if the attack will work there? Only one way
to find out.

The fix for weak PRNG vulnerabilities is always to check the documentation.
In this case you have to click the âSupplemental API remarks for Random.â in the â[Remarks](https://learn.microsoft.com/en-us/dotnet/api/system.random?view=net-9.0#remarks)â section to get to the [security info](https://learn.microsoft.com/en-us/dotnet/fundamentals/runtime-libraries/system-random) where it says:

> To generate a cryptographically secure ...