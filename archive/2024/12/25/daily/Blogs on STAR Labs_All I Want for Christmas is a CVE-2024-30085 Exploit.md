---
title: All I Want for Christmas is a CVE-2024-30085 Exploit
url: https://starlabs.sg/blog/2024/all-i-want-for-christmas-is-a-cve-2024-30085-exploit/
source: Blogs on STAR Labs
date: 2024-12-25
fetch_date: 2025-10-06T19:36:10.882038
---

# All I Want for Christmas is a CVE-2024-30085 Exploit

[![logo](https://starlabs.sg/logo-white.png)](https://starlabs.sg/ "  (Alt + H)")

* [Home](https://starlabs.sg/ "Home")
* [About](https://starlabs.sg/about/ "About")
* [Advisories](https://starlabs.sg/advisories/ "Advisories")
* [Blog](https://starlabs.sg/blog/ "Blog")
* [Achievements](https://starlabs.sg/achievements/ "Achievements")
* [Publications](https://starlabs.sg/publications/ "Publications")
* [Search](https://starlabs.sg/search/ "Search (Alt + /)")

[Home](https://starlabs.sg/) » [Blogs](https://starlabs.sg/blog/)

# All I Want for Christmas is a CVE-2024-30085 Exploit

December 24, 2024 · 21 min · Cherie-Anne Lee

Table of Contents

* [TLDR](#tldr)
  + [Table of Contents](#table-of-contents)
  + [Introduction to cldflt.sys](#introduction-to-cldfltsys)
  + [Vulnerability Analysis and Patch](#vulnerability-analysis-and-patch)
  + [Reparse Point Structure](#reparse-point-structure)
  + [Triggering the Vulnerability](#triggering-the-vulnerability)
  + [Exploitation Overview](#exploitation-overview)
  + [Obtaining a Kernel Pointer Leak](#obtaining-a-kernel-pointer-leak)
  + [Arbitrary Read](#arbitrary-read)

    * [Privilege Escalation](#privilege-escalation)
  + [Exploit Demo](#exploit-demo)
  + [Acknowledgements](#acknowledgements)
  + [References](#references)

# TLDR[#](#tldr)

CVE-2024-30085 is a heap-based buffer overflow vulnerability affecting the Windows Cloud Files Mini Filter Driver `cldflt.sys`. By crafting a custom reparse point, it is possible to trigger the buffer overflow to corrupt an adjacent `_WNF_STATE_DATA` object. The corrupted `_WNF_STATE_DATA` object can be used to leak a kernel pointer from an ALPC handle table object. A second buffer overflow is then used to corrupt another `_WNF_STATE_DATA` object, which is then used to corrupt an adjacent `PipeAttribute` object. By forging a `PipeAttribute` object in userspace, we are able to leak the token address and override privileges to escalate privileges to NT AUTHORITY\SYSTEM.

## Table of Contents[#](#table-of-contents)

1. [Introduction to cldflt.sys](#introduction-to-cldfltsys)
2. [Vulnerability Analysis and Patch](#vulnerability-analysis-and-patch)
3. [Reparse Point Structure](#reparse-point-structure)
4. [Triggering the Vulnerability](#triggering-the-vulnerability)
5. [Exploitation Overview](#exploitation-overview)
6. [Obtaining a Kernel Pointer Leak](#obtaining-a-kernel-pointer-leak)
7. [Arbitrary Read](#arbitrary-read)
8. [Privilege Escalation](#privilege-escalation)
9. [Exploit Demo](#exploit-demo)
10. [Acknowledgements](#acknowledgements)
11. [References](#references)

## Introduction to cldflt.sys[#](#introduction-to-cldfltsys)

`cldflt.sys` is the Windows Cloud Files Mini Filter Driver, which allows users to manage and sync files between a remote server and a local client. `cldflt.sys` works by creating placeholder files and directories, which are implemented as reparse points. Placeholders allow the actual contents of a file to reside somewhere else and be retrieved (known as “hydration”) on demand, while looking and behaving like a normal file on the system. Placeholders can be created and managed by users via the Cloud Files API.

## Vulnerability Analysis and Patch[#](#vulnerability-analysis-and-patch)

[CVE-2024-30085](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-30085) is a heap-based buffer overflow vulnerability discovered by Alex Birnberg from SSD Secure Disclosure, as well as Gwangun Jung and Junoh Lee from Theori. For Windows 10 22H2, this vulnerability was fixed in the [KB5039211](https://support.microsoft.com/en-gb/topic/june-11-2024-kb5039211-os-builds-19044-4529-and-19045-4529-f7e528c9-5e9f-4cd8-9161-704708448517) update.

![Patch diff](/blog/2024/images/CVE-2024-30085_patch_diff.jpg)

Looking at the patch diff, it is clear that the `HsmIBitmapNORMALOpen` function has been modified.

![Patch diff HsmIBitmapNORMALOpen](/blog/2024/images/CVE-2024-30085_patch_diff2.jpg)

The vulnerable driver binary is displayed on the left, and the patched driver binary is on the right. From here, we can see that an additional code block `cmp r14d, 0x1000` has been added. Taking a look at part of the decompilation of the unpatched function:

```
if (local_70 == 0x0) || (0xffe < memcpy_size - 1) {
    Dst = ExAllocatePoolWithTag(1, 0x1000, 0x6d427348);
    if (Dst == 0x0) {
        HsmDbgBreakOnStatus(-0x3fffff66);
        ... // Go to error path
    }
    memcpy(Dst, local_70, memcpy_size);
} else {
    iVar13 = *(int *)((memcpy_size - 4) + (longlong)local_70);
    if (iVar13 == -1) && (memcpy_size == 4) {
        *(uint *)(Dst + 2) = *(uint *)(Dst + 2) | 0x10;
    } else {
        Dst = ExAllocatePoolWithTag(1, 0x1000, 0x6d427348); // Allocate a HsBm object
        if (Dst == 0x0) {
            HsmDbgBreakOnStatus(-0x3fffff66);
            ... // Go to error path
        }
    }
    memcpy(Dst, local_70, memcpy_size); // Vulnerable memcpy, we control local_70 and memcpy_size!
    ...
}
```

The driver allocates a HsBm object of size 0x1000 in the paged pool, and copies data of `memcpy_size` to the allocated buffer. As the user is able to control the data copied, as well as the value of `memcpy_size`, if `memcpy_size` is greater than 0x1000, a heap-based buffer overflow in the paged pool will occur!

```
if (((int)uVar7 != 0) && (0x1000 < memcpy_size)) {
    HsmDbgBreakOnStatus(-0x3fff30fe);
    ... // Go to error path
}
```

To patch the vulnerability, a check to determine if `memcpy_size` is less than or equal to 0x1000 was added, and the memcpy would only be called if this check passes.

## Reparse Point Structure[#](#reparse-point-structure)

However, in order to understand how to trigger this vulnerability, we must first understand the structure of the reparse points that the cldflt driver uses to store data.

A reparse point comprises of a reparse tag, which identifies the file system driver that owns the reparse point, and user-defined data. In this case, when we create the file used for exploitation, we will use `IO_REPARSE_TAG_CLOUD_6` (0x9000601a) as the reparse tag.

The user-defined data has the following structure:

```
typedef struct _REPARSE_DATA_BUFFER {
    ULONG  ReparseTag;
    USHORT ReparseDataLength;
    USHORT Reserved;
    struct {
        UCHAR DataBuffer[1];
    } GenericReparseBuffer;
} REPARSE_DATA_BUFFER, *PREPARSE_DATA_BUFFER;
```

`DataBuffer` has a variable size, and contains custom data set by the cloud filter driver, which takes the following format:

```
struct _HSM_REPARSE_DATA {
    USHORT Flags;
    USHORT Length;
    HSM_DATA FileData;
} HSM_REPARSE_DATA, *PHSM_REPARSE_DATA;
```

When `cldflt.sys` creates a reparse point, if the size of the data is greater than 0x100 bytes, it will compress the data using `RtlCompressBuffer` with `COMPRESSION_FORMAT_LZNT1`. `Flags` is set to 0x1 if no compression is involved, and 0x8001 if compression is used. `Length` refers to the size of the entire `_HSM_REPARSE_DATA` structure. `FileData` takes the following form:

```
typedef struct _HSM_DATA
{
    ULONG  Magic;
    ULONG  Crc32;
    ULONG  Length;
    USHORT Flags;
    USHORT NumberOfElements;
    HSM_ELEMENT_INFO ElementInfos[1];
} HSM_DATA, *PHSM_DATA;
```

`Magic` is set to 0x70527442 (“BtRp”) for bitmap data, and 0x70526546 (“FeRp”) for file data. If the CRC32 exists, it will be included in the structure. The CRC32 is calculated using `RtlComputeCrc32`. `Length` refers to the size of the entire `_HSM_DATA` object. `Flags` will be set to 0x2 if a CRC32 checksum value exists. A `_HSM_DATA` struct can include a number of elements, which take the following form:

```
typedef struct _HSM_ELEMENT_INFO
{
    USHORT Type;
    USHORT Length;
    ULONG  Offset;
} HSM_ELEMENT_INFO, *PHSM_ELEMENT_INFO;
```

Elements can have the following types:

```
#define HSM_ELEMENT_TYPE_NONE           0x00
#define HSM_ELEMENT_TYPE_UINT64         0x06
#define HSM_ELEMENT_TYPE_BYTE           0x07
#define HSM_ELEMENT_TYPE_UINT32         0x0a
#...