---
title: A Case Study of Local Privilege Escalation from Vulnerability Discovery to Vulnerability Exploitation – Lenovo Dolby API
url: http://x9090.blogspot.com/2024/12/a-case-study-of-local-privilege.html
source: x9090's Blog
date: 2024-12-13
fetch_date: 2025-10-06T19:38:10.884243
---

# A Case Study of Local Privilege Escalation from Vulnerability Discovery to Vulnerability Exploitation – Lenovo Dolby API

# [x9090's Blog](http://x9090.blogspot.com/)

Dedicated to computer security, pentesting and vulnerabilities, malware updates and analysis

## Thursday, December 12, 2024

### [A Case Study of Local Privilege Escalation from Vulnerability Discovery to Vulnerability Exploitation – Lenovo Dolby API](http://x9090.blogspot.com/2024/12/a-case-study-of-local-privilege.html)

\* Update 25/May/2025 - Updated github URL to the POC

# Background

##

This blog post is aimed to provide the
reader the end-to-end explanation on how I conduct vulnerability research
when given a whole new target – the scopes, the challenges, and the workarounds
for the challenges I took along the way.

In this research, I’m focusing on the
Windows system service running by default on Lenovo laptop, which is identified as **Dolby DAX API**
service hosted by **DAX3API.exe.**

# Vulnerable Target

#

The vulnerable target is known as Realtek Audio Driver which can be downloaded
from Lenovo support page <https://download.lenovo.com/pccbbs/mobiles/n3qa118w.exe>. It consists of the checksum hash de32823d245c296e5d3ca24a824fa63468d7653c153a319ce0d92f343a5ab530

The DAX3API.exe used in the following
analysis has version **3.30508.581.0** with SHA256 D59E6CDD07532B89EC7E575D85B15DAACFB7BBE66D54414924D09C3EC1DFC5FB

This vulnerability has
been assigned with CVE-2024-44102 whilst the Lenovo's security advisory can
be found [here](https://support.lenovo.com/us/en/product_security/LEN-167314).

# Scopes

#

Depending on the scopes you or the vendor
defined, assuming if you are doing this for some bug bounty program vendor
typically define the scopes, it is always a good idea to limit the scope so
that you can list out the possible or the attack vectors that you are aware of
on the target.

In this case, I’m intended to look for an
exploitable bug that I’m comfortable to exploit with. Because of my prior
experience, I have exploited local privilege escalation for logical bugs caused
by access control issues – more specifically the security issue that allows low
privileged users to use symbolic link/hard link to attack a world-writable
folder that will be manipulated by a system service. Just a side-note, creation
hard link is disallowed for non-admin users starting on Windows 11 (technically
some later version of Windows 10 has this mitigation in placed, which I lost
track. That is also the reason why I stopped looking for arbitrary file
creation/deletion vulnerability using hard link attack when this feature was implemented in Insider Preview as it was no longer a security issue and
therefore no more bounty from MSRC for all these low-hanging fruit issues.

To my surprised, I revisit the development
of symlink attack and realized that arbitrary file deletion is still a thing. One of the reasons is because the development of the generic exploitation method shared by researcher [Abdelhamid
Naceri](https://github.com/thezdi/PoC/tree/master/FilesystemEoPs). So, I decided to look for this class of vulnerability as a start
for the scope of this research.

#

# Who Doesn't Like Debug Messages?

When reverse-engineering a binary, one
common difficulty that most of the researchers faced is probably the lack of debug
symbol that provides names for the function or variables in the binary.
Without the debug symbol you will need to either guess what the particular
function is trying to do or spend time to do the debugging to understand its
functionality.

Fortunately, the target binary in question
has the debug messages available including the name of the function.

# ![](data:image/png;base64...)

Obviously, this is going to be helpful for
reverse engineers to have the context of the inspecting function. As a perceptive reader, you have probably realized that this is the
vulnerable function where local privilege escalation will occur. I do not
realize this function directly at first. As I mentioned earlier, this blog post
is aimed to give the reader end-to-end insight on how I define the scope and the
attack vector of the vulnerability for a whole new target therefore I will walk
through the steps I took to identify the attack vector.

# From Arbitrary File Delete to Arbitrary File Execution

If this is not the first local privilege
escalation vulnerability analysis blog post that you have seen, you should be
familiar with how the researchers typically identify the potential arbitrary
file delete using dynamic analysis tools like Process Monitor, which is an easy
approach even for those who do not know how to do reverse engineering.
Apparently, the drawback of this approach is that if the target application
requires certain criteria, for example, some configuration found in some
specific configuration file, then only trigger the vulnerable code, dynamic
analysis tools will not be able to capture anything interesting before these
criteria are fulfilled. So, I decided to go for static-analysis approach.

In static analysis, the common strategy to
look for attack vectors for vulnerability is to locate the user-controlled
input that will be ingested and manipulated by the target binary. When it comes
to the logical bugs related to access control issues, one of the plausible user-controlled
input is the file name or folder name. Having said that, I directly navigate to
the import table and look for the relevant APIs like *CreateFile*, *CreateDirectory* and etc.

![](data:image/png;base64...)

![](data:image/png;base64...)

##

When looking into the caller functions from
the screenshots above, these appear to be C++ runtime routines that will
eventually call the Windows APIs. Further examination reveals these C++ runtime
routines are imported from *std::filesystem.* Following the caller
tree leads us to the runtime routine that is responsible to create directory from
a given file path. The proximity view from IDA Pro below shows the code path
from the offending function to the *CreateDirectoryW* API function where we started our analysis at first.

![](data:image/png;base64...)

At this point, I was able to narrow down
the target function from a pool of functions and then only focus and reverse
engineer on the target function, *PluginManager::StartSoundRadarHost*, which
reveals a few interesting facts about the vulnerability:

1. Determine if the host machine
   is compatible with the supported SKUs as defined in the following:

·
Gaming

·
Mainstream

·
SnG

·
DolbyAudio

·
DolbyAudioPremium

·
DolbyAtmosSpeakerSystem

·
DolbyAtmosSpeakerSystemForGaming

2. Determine if DSRHost.exe has been executed and running on the host machine
3. If no existing DSRHost.exe process is found, it attempts to locate and find Radar
   Host package which turns out to be bundled with UWP applications in **Dolby Access** and **Dolby Atoms for Gaming** that can be downloaded and installed from
   Microsoft Store. To determine the existence of these UWP applications, it
   checks from the registry *HKEY\_CLASSES\_ROOT\Local
   Settins\Software\Microsoft\Windows\CurrentVersion\AppModel\PackageRepository\Packages*. For
   example, the *Path* value contains the location of where the UWP is
   installed on the file system.
   ![](data:image/png;base64...)
4. In my host machine, the Radar Host package can be found under  *C:\Program
   Files\WindowsApps\DolbyLaboratories.DolbyAccess\_3.23.1378.0\_x64\_\_rz1tebttyb220\Assets\RadarHost\Res.dat.*The
   file itself is a ZIP archive with the following contents including DSRHost.exe,
   which is what the function routine intended to launch later.

   ![](data:image/png;base64...)
5. A
   new directory will be created under *C:\ProgramData\Dolby\DAX3\RADARHOST* if it does not exist. If the folder already
   exists, the folder and its contents will be removed before creating a new one. Once
   the folder has been setup, *Res.dat* will be copied to this folder as *Res.zip* and the contents in the ZIP archive will be extracted
   to this folder.
6. *Res.zip* will be deleted before it proceeds to ...