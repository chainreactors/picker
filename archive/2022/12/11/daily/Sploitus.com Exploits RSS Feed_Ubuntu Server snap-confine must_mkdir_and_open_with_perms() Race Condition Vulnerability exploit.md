---
title: Ubuntu Server snap-confine must_mkdir_and_open_with_perms() Race Condition Vulnerability exploit
url: https://sploitus.com/exploit?id=1337DAY-ID-38096&utm_source=rss&utm_medium=rss
source: Sploitus.com Exploits RSS Feed
date: 2022-12-11
fetch_date: 2025-10-04T01:11:57.228735
---

# Ubuntu Server snap-confine must_mkdir_and_open_with_perms() Race Condition Vulnerability exploit

[x]
Dark Mode

[##### SPLOITUS](/)

# Exploit for Ubuntu Server snap-confine must\_mkdir\_and\_open\_with\_perms() Race Condition Vulnerability CVE-2021-3995 CVE-2021-3996 CVE-2021-44731 CVE-2022-3328 CVE-2022-41973 CVE-2022-41974

2022-12-10 | CVSS 7.8

Copy
Download
Source
[Share](#share-url)

```
## https://sploitus.com/exploit?id=1337DAY-ID-38096
Race condition in snap-confine's must_mkdir_and_open_with_perms()
(CVE-2022-3328)

========================================================================
Contents
========================================================================

Summary
Background
Exploitation
Acknowledgments
Timeline

    I can't help but feel a missed opportunity to integrate lyrics from
    one of the best songs ever: [SNAP! - The Power (Official Video)]
        -- https://twitter.com/spendergrsec/status/1494420041076461570

========================================================================
Summary
========================================================================

We discovered a race condition (CVE-2022-3328) in snap-confine, a
SUID-root program installed by default on Ubuntu. In this advisory, we
tell the story of this vulnerability (which was introduced in February
2022 by the patch for CVE-2021-44731) and detail how we exploited it in
Ubuntu Server (a local privilege escalation, from any user to root) by
combining it with two vulnerabilities in multipathd (an authorization
bypass and a symlink attack, CVE-2022-41974 and CVE-2022-41973):

https://www.qualys.com/2022/10/24/leeloo-multipath/leeloo-multipath.txt

========================================================================
Background
========================================================================

    Like the crack of the whip, I Snap! attack
    Radical mind, day and night all the time
        -- SNAP! - The Power

In February 2022, we published CVE-2021-44731 in our "Lemmings" advisory
(https://www.qualys.com/2022/02/17/cve-2021-44731/oh-snap-more-lemmings.txt):
to set up a snap's sandbox, snap-confine created the temporary directory
/tmp/snap.$SNAP_NAME or reused it if it already existed, even if it did
not belong to root; a local attacker could race against snap-confine,
retain control over /tmp/snap.$SNAP_NAME, and eventually obtain full
root privileges.

This vulnerability was patched by commit acb2b4c ("cmd/snap-confine:
Prevent user-controlled race in setup_private_mount"), which introduced
a new helper function, must_mkdir_and_open_with_perms():

------------------------------------------------------------------------
142 static void setup_private_mount(const char *snap_name)
...
169         sc_must_snprintf(base_dir, sizeof(base_dir), "/tmp/snap.%s", snap_name);
...
176         base_dir_fd = must_mkdir_and_open_with_perms(base_dir, 0, 0, 0700);
------------------------------------------------------------------------
 55 static int must_mkdir_and_open_with_perms(const char *dir, uid_t uid, gid_t gid,
 56                                           mode_t mode)
 ..
 61  mkdir:
 ..
 67         if (mkdir(dir, 0700) < 0 && errno != EEXIST) {
 ..
 70         fd = open(dir, O_RDONLY | O_DIRECTORY | O_CLOEXEC | O_NOFOLLOW);
 ..
 81         if (fstat(fd, &st) < 0) {
 ..
 84         if (st.st_uid != uid || st.st_gid != gid
 85             || st.st_mode != (S_IFDIR | mode)) {
...
130                 if (rename(dir, random_dir) < 0) {
...
135                 goto mkdir;
------------------------------------------------------------------------

- the temporary directory /tmp/snap.$SNAP_NAME is created at line 67, if
  it does not exist already;

- if it already exists, and if it does not belong to root (at line 84),
  then it is moved out of the way (at line 130) by rename()ing it to a
  random directory in /tmp, and its creation is retried (at line 135).

When we reviewed this patch back in December 2021, we felt very nervous
about this rename() call (because it allows a local attacker to rename()
a directory they do not own), and we advised the Ubuntu Security Team to
either not reuse the directory /tmp/snap.$SNAP_NAME at all, or to create
it in a non-world-writable directory instead of /tmp, or at least to use
renameat2(RENAME_EXCHANGE) instead of rename(). Unfortunately, all of
these ideas were deemed impractical (for example, renameat2() is not
supported by older kernel and glibc versions); moreover, we (Qualys)
failed to come up with a feasible attack plan against this rename()
call, so the patch was kept in its current form.

After the release of Ubuntu 22.04 in April 2022, we decided to revisit
snap-confine and its recent hardening changes, and we finally found a
way to exploit the rename() call in must_mkdir_and_open_with_perms().

========================================================================
Exploitation
========================================================================

    It's getting, it's getting, it's getting kinda heavy
    It's getting, it's getting, it's getting kinda hectic
        -- SNAP! - The Power

The three key ideas to exploit the rename() of /tmp/snap.$SNAP_NAME are:

1/ snap-confine operates in /tmp to create a snap's temporary directory
(/tmp/snap.$SNAP_NAME in setup_private_mount()), but it also operates in
/tmp to create the snap's *root* directory (/tmp/snap.rootfs_XXXXXX in
sc_bootstrap_mount_namespace(), where all of the Xs are randomized by
mkdtemp()), and the string rootfs_XXXXXX is accepted as a valid snap
instance name by sc_instance_name_validate() (when all of the Xs are
lowercase alphanumeric):

------------------------------------------------------------------------
286 static void sc_bootstrap_mount_namespace(const struct sc_mount_config *config)
...
288         char scratch_dir[] = "/tmp/snap.rootfs_XXXXXX";
...
291         if (mkdtemp(scratch_dir) == NULL) {
...
303         sc_do_mount(scratch_dir, scratch_dir, NULL, MS_BIND, NULL);
...
319         sc_do_mount(config->rootfs_dir, scratch_dir, NULL, MS_REC | MS_BIND,
...
331         for (const struct sc_mount * mnt = config->mounts; mnt->path != NULL;
...
342                 sc_must_snprintf(dst, sizeof dst, "%s/%s", scratch_dir,
343                                  mnt->path);
...
352                         sc_do_mount(mnt->path, dst, NULL, MS_REC | MS_BIND,
------------------------------------------------------------------------

2/ We therefore execute two instances of snap-confine in parallel:

- we block the first snap-confine immediately after it creates its root
  directory /tmp/snap.rootfs_XXXXXX at line 291 (we reliably win this
  race condition by "single-stepping" snap-confine, as explained in our
  "Lemmings" advisory);

- we execute the second snap-confine with a snap instance name of
  rootfs_XXXXXX -- i.e., the temporary directory /tmp/snap.$SNAP_NAME of
  this second snap-confine is the root directory /tmp/snap.rootfs_XXXXXX
  of the first snap-confine;

- we kill this second snap-confine immediately after it rename()s its
  temporary directory /tmp/snap.$SNAP_NAME -- i.e., the root directory
  /tmp/snap.rootfs_XXXXXX of the first snap-confine -- at line 130 (we
  reliably win this race condition with inotify, as explained in our
  "Lemmings" advisory);

- we re-create the directory /tmp/snap.rootfs_XXXXXX ourselves, and
  resume the execution of the first snap-confine, whose root directory
  now belongs to us.

3/ We can therefore create an arbitrary symlink
/tmp/snap.rootfs_XXXXXX/tmp, and sc_bootstrap_mount_namespace() will
bind-mount the real /tmp directory (which is world-writable) onto any
directory in the filesystem (because mount() will follow our arbitrary
symlink at line 352).

This ability will eventually allow us to obtain full root privileges,
but we must first solve three problems:

------------------------------------------------------------------------
Problem a/ We cannot trick snap-confine into rename()ing
/tmp/snap.rootfs_XXXXXX, because this directory belongs to root and
must_mkdir_and_open_with_p...