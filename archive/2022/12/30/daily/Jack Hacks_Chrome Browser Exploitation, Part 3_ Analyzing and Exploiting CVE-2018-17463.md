---
title: Chrome Browser Exploitation, Part 3: Analyzing and Exploiting CVE-2018-17463
url: https://jhalon.github.io/chrome-browser-exploitation-3/
source: Jack Hacks
date: 2022-12-30
fetch_date: 2025-10-04T02:46:34.176917
---

# Chrome Browser Exploitation, Part 3: Analyzing and Exploiting CVE-2018-17463

* [Jack Hacks](https://jhalon.github.io/)
* [Posts](https://jhalon.github.io/posts.html)
* [Categories](https://jhalon.github.io/categories.html)
* [About](https://jhalon.github.io/about.html)

# Chrome Browser Exploitation, Part 3: Analyzing and Exploiting CVE-2018-17463

![Jack Halon](https://jhalon.github.io/images/bio_chibi.png)

### Jack Halon

I like to break into things; both physically and virtually.

Follow

* United States
* Email
* [Twitter](https://twitter.com/jack_halon)
* [LinkedIn](https://www.linkedin.com/in/jacek-halon-683912b0)
* [Github](https://github.com/jhalon/)
* [YouTube](https://www.youtube.com/user/../JackHacks)

Welcome to the third and final installment of the “Chrome Browser Exploitation” series. The main objective of this series has been to provide an introduction to browser internals and delve into the topic of Chrome browser exploitation on Windows in greater depth.

In [Part 1](https://jhalon.github.io/chrome-browser-exploitation-1/) of the series, we examined the inner workings of JavaScript and V8. This included an exploration of objects, maps, and shapes, as well as an overview of memory optimization techniques such as pointer tagging and pointer compression.

In [Part 2](https://jhalon.github.io/chrome-browser-exploitation-2/) of the series, we took a more in-depth look at the V8 compiler pipeline. We examined the role of Ignition, Sparkplug, and TurboFan in the pipeline and covered topics such as V8’s bytecode, code compilation, and code optimization.

In today’s blog post, we will be focusing on the analysis and exploitation of [CVE-2018-17463](https://chromereleases.googleblog.com/2018/10/stable-channel-update-for-desktop.html) which was a JIT Compiler Vulnerability in TurboFan. This vulnerability arose from the improper side-effect modeling of the [`JSCreateObject`](https://source.chromium.org/chromium/chromium/src/%2B/main%3Av8/src/compiler/js-create-lowering.cc;l=1342?q=JSCreateObject%20&ss=chromium%2Fchromium%2Fsrc) operation during the lowering optimization phase. Before we delve into exploiting this bug, we will first learn about fundamental browser exploitation primitives, such as `addrOf` and `fakeObj`, and how we can use our bug to exploit type confusions.

**Warning**: Please be aware that this blog post is a detailed, in-depth read, as it goes through the exploitation process step by step. As such, it is a very heavy read. If you only want to read a specific part of the blog, there is a table of contents provided for your convenience.

#### Index

* [Understanding Patch Gapping](#understanding-patch-gapping)
* [Root Cause Analysis of CVE-2018-17463](#root-cause-analysis-of-cve-2018-17463)
* [Setting Up Our Environment](#setting-up-our-environment)
* [Generating a Proof of Concept](#generating-a-proof-of-concept)
* [Exploiting a Type Confusion for `JSCreateObject`](#exploiting-a-type-confusion-for-jscreateobject)
* [Understanding Browser Exploit Primitives](#understanding-browser-exploit-primitives)
  + [The `addrOf` Read Primitive](#the-addrof-read-primitive)
  + [The `fakeObj` Write Primitive](#the-fakeobj-write-primitive)
* [Gaining Memory Read + Write](#gaining-memory-read--write)
* [Gaining Code Execution](#gaining-code-execution)
  + [Basic WebAssembly Internals](#basic-webassembly-internals)
  + [Abusing WebAssembly Memory](#abusing-webassembly-memory)
* [Closing](#closing)
* [Kudos](#kudos)
* [References](#references)

The following topics will be discussed in this post:

* Understanding Patch Gapping
* Root Cause Analysis of CVE-2018-17463
* Setting Up Our Environment
* Generating a Proof of Concept
* Exploiting a Type Confusion for `JSCreateObject`
* Understanding Browser Exploit Primitives
  + The `addrOf` Read Primitive
  + The `fakeObj` Write Primitive
* Gaining Memory Read + Write Access
* Gaining Code Execution within V8
  + Basic WebAssembly Internals
  + Abusing WebAssembly Memory

Alright, with that being said, let’s jump in and do this!

# Understanding Patch Gapping

In September 2018, [Issue 888923](https://bugs.chromium.org/p/chromium/issues/detail?id=888923) was reported to Google’s Security Team through the Beyond Security’s SecuriTeam Secure Disclosure program. The bug was discovered by [Samuel Gross](https://twitter.com/5aelo?lang=en) through source code review and was used as part of the [Hack2Win](https://ssd-disclosure.com/hack2win-extreme-warm-up/) competition. A month after the bug was fixed, it was made public via an SSD Advisory titled “[Chrome Type Confusion in JSCreateObject Operation to RCE](https://ssd-disclosure.com/ssd-advisory-chrome-type-confusion-in-jscreateobject-operation-to-rce/)” which provided some details about the bug and released a detailed proof of concept for its exploitation.

Within the same month, Samuel gave a talk at BlackHat 2018 called “[Attacking Client-Side JIT Compilers](https://www.youtube.com/watch?v=emt1yf2Fg9g)” in which he discussed vulnerabilities in JIT compilers, particularly those related to redundancy elimination and the modeling of side effects within IR. It wasn’t until 2021 that Samuel released a Phrack article titled “[Exploiting Logic Bugs in JavaScript JIT Engines](http://phrack.org/issues/70/9.html#article)” which provided a more in-depth explanation of how CVE-2018-17463 was discovered and exploited.

It’s worth noting that a significant amount of information about this bug was made public within a few weeks of its discovery. This means that attackers could have used this information to reverse engineer and exploit the bug. However, the issue with this is that most, if not all, Chrome browsers would have already been patched automatically within a few days or even weeks after the initial commit for the fix was pushed, rendering the bug useless.

Instead of relying on publicly available information about potential bugs, many attackers and exploit engineers track commits looking for specific keywords. When they find a commit that looks promising, they will try to figure out the underlying bug, a practice known as “**patch gapping**”.

As explained within [Exodus’s](https://twitter.com/exodusintel?lang=en) post “[Patch Gapping Google Chrome](https://blog.exodusintel.com/2019/09/09/patch-gapping-chrome/)” they detail patch-gapping as being “the practice of exploiting vulnerabilities in open-source software that are already fixed (or are in the process of being fixed) by the developers before the actual patch is shipped to users”.

Why is this relevant to our discussion of Chrome browser exploitation? Well, by understanding the concept of patch gapping it allows us to adopt more of an “adversary mindset.” After learning so much about the internals of V8, we now should have a good enough understanding to be able to spot a potential bug in Chrome’s code from an initial commit.

By taking this approach, we can widen the window of opportunity for exploiting a bug, as well as broaden our knowledge of Chrome’s codebase. Additionally, by observing locations in the code that are frequently patched, we can get a sense of where we should look for potential 0-day vulnerabilities in Chrome.

With that in mind, let’s begin our root analysis by looking at the initial commit that was pushed to fix the bug we’re examining. We’ll try to reverse engineer the fix and figure out how to trigger the bug using the knowledge we acquired. If we get stuck, we’ll use the already existing public resources to help us. After all, this is a journey through browser exploitation, and sometimes a journey is never an easy one!

# Root Cause Analysis of CVE-2018-17463

Looking into [Issue 888923](https://bugs.chromium.org/p/chromium/issues/detail?id=888923) we can see that the initial patch for this bug was pushed with commit `52a9e67a477bdb67ca893c25c145ef5191976220` with the message of “[turbofan] Fix ObjectCreate’s side effect annotation”. Knowing this, let’s use the `git show` command within our V8 directory to see what that commit fixed.

```
C:\dev\v8\v8>...