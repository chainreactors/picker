---
title: 用CodeQL分析漏洞_CVE-2022-42889
url: https://l3yx.github.io/2022/12/17/%E7%94%A8CodeQL%E5%88%86%E6%9E%90%E6%BC%8F%E6%B4%9E-CVE-2022-42889/
source: l3yx's blog
date: 2022-12-18
fetch_date: 2025-10-04T01:51:05.656254
---

# 用CodeQL分析漏洞_CVE-2022-42889

[l3yx's blog](/)

* [首页](/)
* [归档](/archives/)
* [标签](/tags/)
* 搜索

* 文章目录
* 站点概览

1. [1. 漏洞原理](#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86)
2. [2. CodeQL分析](#CodeQL%E5%88%86%E6%9E%90)
   1. [2.1. 测试环境](#%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83)
   2. [2.2. Sink](#Sink)
   3. [2.3. Source](#Source)
   4. [2.4. 额外的污点步骤](#%E9%A2%9D%E5%A4%96%E7%9A%84%E6%B1%A1%E7%82%B9%E6%AD%A5%E9%AA%A4)
   5. [2.5. 完整查询](#%E5%AE%8C%E6%95%B4%E6%9F%A5%E8%AF%A2)

![淚笑](/resources/avatar.jpg)

淚笑

学的越多，懂的越少

[GitHub](https://github.com/l3yx "GitHub → https://github.com/l3yx")

E-Mail

# 用CodeQL分析漏洞\_CVE-2022-42889

发表于
2022-12-17

更新于
2022-12-24

本文字数：
919

阅读时长 ≈
3 分钟

Apache Commons Text 是专门用来处理文本的一个库，据文档介绍其支持[变量插值](https://commons.apache.org/proper/commons-text/apidocs/org/apache/commons/text/lookup/StringLookupFactory.html)。在1.5 - 1.9版本默认支持”script”类型的插值，于是可以造成任意代码执行，也就是CVE-2022-42889。

## 漏洞原理

该工具库使用示例如下：

|  |  |
| --- | --- |
| ``` 1 2 3 4 5 6 7 ``` | ``` StringSubstitutor interpolator = StringSubstitutor.createInterpolator(); String text = interpolator.replace(         "Base64 Decoder:${base64Decoder:SGVsbG9Xb3JsZCE=}\n"                 + "Date:                  ${date:yyyy-MM-dd}\n"                 + "Environment Variable:  ${env:USER}\n"                 + "Script:                ${script:javascript:3 + 4}\n"); System.out.println(text); ``` |

执行结果为：

> Base64 Decoder:HelloWorld!
> Date: 2022-12-17
> Environment Variable: leixiao
> Script: 7

很容易发现安全问题，所以漏洞原理其实也很简单。

命令执行POC为：

> ${script:js:new java.lang.ProcessBuilder("open", "-a", "calculator").start()}

## CodeQL分析

### 测试环境

* CodeQL 2.11.6
* Commons Text 1.9

### Sink

调试跟踪，最后的触发点在

org.apache.commons.text.lookup.ScriptStringLookup#lookup

|  |  |
| --- | --- |
| ``` 1 ``` | ``` Objects.toString(scriptEngine.eval(script), (String)null); ``` |

可以写出如下Sink点

|  |  |
| --- | --- |
| ``` 1 2 3 4 5 6 7 8 9 ``` | ``` class ScriptEngineEval extends DataFlow::Node {   ScriptEngineEval() {     exists(MethodAccess ma |       ma.getCallee().hasName("eval") and       ma.getCallee().getDeclaringType().getASupertype*().hasQualifiedName("javax.script", "ScriptEngine") and       this.asExpr() = ma.getArgument(0)     )   } } ``` |

### Source

可以将该库所有公有类的字符串类型公有方法参数作为Source点

|  |  |
| --- | --- |
| ``` 1 2 3 4 5 6 7 8 9 10 11 ``` | ``` class PublicMethodParameter extends DataFlow::Node {   PublicMethodParameter() {     exists(Method m, Parameter p |       m.getDeclaringType().isPublic() and       m.isPublic() and       p = m.getAParameter() and       p.getType().hasName("String") and       this.asParameter() = p     )   } } ``` |

### 额外的污点步骤

发现直接使用上面的Source和Sink会没有查询结果，说明从Source到Sink的路径上缺少了一步，可以使用[PartialPathGraph](https://codeql.github.com/docs/writing-codeql-queries/debugging-data-flow-queries-using-partial-flow/)来Debug

先将Source的范围缩小，否则查询会耗非常长时间，然后逐步将Source定义替换为沿路径出现的合适的Node

最后我的Source定义为函数`org.apache.commons.text.StringSubstitutor#resolveVariable`的参数，并且发现了污点传播中断的地方，完整查询如下：

|  |  |
| --- | --- |
| ``` 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 ``` | ``` /**  * @kind path-problem  */  import java import semmle.code.java.dataflow.DataFlow import semmle.code.java.dataflow.TaintTracking import DataFlow::PartialPathGraph  class ResolveVariable extends DataFlow::Node {   ResolveVariable() {     exists(Method resolveVariable |       resolveVariable           .getDeclaringType()           .hasQualifiedName("org.apache.commons.text", "StringSubstitutor") and       resolveVariable.hasName("resolveVariable") and       this.asParameter() = resolveVariable.getParameter(0)     )   } }  class TaintTrackingConfig extends TaintTracking::Configuration {   TaintTrackingConfig() { this = "TaintTrackingConfig" }    override predicate isSource(DataFlow::Node source) { source instanceof ResolveVariable }    override int explorationLimit() { result = 10 } }  from TaintTrackingConfig cfg, DataFlow::PartialPathNode source, DataFlow::PartialPathNode sink where cfg.hasPartialFlow(source, sink, _) select sink, source, sink, "-" ``` |

![](/2022/12/17/%E7%94%A8CodeQL%E5%88%86%E6%9E%90%E6%BC%8F%E6%B4%9E-CVE-2022-42889/image-20221217154807090.png "image-20221217154807090")

污点传播止于`resolver.lookup(variableName)`的参数`variableName`，这里的`resolver`是`StringLookup`接口。我期望的是污点继续流向`StringLookup`的具体实现类中，其实CodeQL一般是支持Java这种多态特性的，但是就该项目来看，~~这一部分的写法比较特殊，导致CodeQL不支持~~。（后面搜到了一条相关的issue：<https://github.com/github/codeql/issues/11385> ，然后我又去做了对照实验，确实当接口名为`org.apache.commons.text.lookup.StringLookup`就会有这个bug）

最后解决办法比较粗暴，如果调用抽象方法，那么直接将污点传播到对应的所有具体方法上

|  |  |
| --- | --- |
| ``` 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ``` | ``` class TaintStep extends TaintTracking::AdditionalTaintStep {   override predicate step(DataFlow::Node pred, DataFlow::Node succ) {     exists(MethodAccess ma, Method m, RefType baseClass |       //pred为调用抽象方法时传入的参数,succ为传入到具体方法的参数       (         ma.getCallee().isAbstract() and         pred.asExpr() = ma.getAnArgument() and         not m.isAbstract() and         succ.asParameter() = m.getAParameter()       ) and       //调用的抽象方法需要和具体方法名字一样       ma.getCallee().getName() = m.getName() and       //调用的抽象方法所属的类和具体方法所属的类应该继承自同一抽象类       (         baseClass.isAbstract() and         ma.getCallee().getDeclaringType().hasSupertype*(baseClass) and         m.getDeclaringType().hasSupertype*(baseClass)       )     )   } } ``` |

### 完整查询

最后完整查询如下

|  |  |
| --- | --- |
| ``` 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 ``` | ``` /**  * @kind path-problem  */  import java import semmle.code.java.dataflow.DataFlow import semmle.code.java.dataflow.TaintTracking import DataFlow::PathGraph  class PublicMethodParameter extends DataFlow::Node {   PublicMethodParameter() {     exists(Method m, Parameter p |       m.getDeclaringType().isPublic() and       m.isPublic() and       p = m.getAParameter() and       p.getType().hasName("String") and       this.asParameter() = p     )   } }  class ScriptEngineEval extends DataFlow::Node {   ScriptEngineEval() {     exists(MethodAccess ma |       ma.getCallee().hasName("eval") and       ma.getCallee().getDeclaringType().getASupertype*().hasQualifiedName("javax.script", "ScriptEngine") and       this.asExpr() = ma.getArgument(0)     )   } }  class TaintStep extends TaintTracking::AdditionalTaintStep {   override predicate step(DataFlow::Node pred, DataFlow::Node succ) {     exists(MethodAccess ma, Method m, RefType baseClass |       (         ma.getCallee().isAbstract() and         pred.asExpr() = ma.getAnArgument() and         not m.isAbstract() and         succ.asParameter() = m.getAParameter()       ) and       ma.getCallee().getName() = m.getName() and       (         baseClass.isAbstract() and         ma.getCallee().getDeclaringType().hasSupertype*(baseClass) and         m.getDeclaringType().hasSupertype*(baseClass)       )     )   } }  class TaintTrackingConfig extends TaintTracking::Configuration {   TaintTrackingConfig() { this = "TaintTrackingConfig" }    override predicate isSource(DataFlow::Node source) { source instanceof PublicMethodParameter }    override predicate isSink(DataFlow::Node sink) { sink instanceof ScriptEngineEval } }  from TaintTrackingConfig cfg, DataFlow::PathNode source, DataFlow::PathNode sink where cfg.hasFlowPath(source, sink) select sink, source, sink,   "Source: " + source.getNode().asParameter().getCallable().getDeclaringType() + "." +     source.getNode().asParameter().getCallable() ``` |

[# Web安全](/tags/Web%E5%AE%89%E5%85%A8/)
[# Java](/tags/Java/)
[# 漏洞分析](/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/)
[# 静态分析](/tags/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/)
[# CodeQL](/tags/CodeQL/)

[Spring Framework 代码执行(CVE-2010-1622)](/2022/07/21/Spring-Framework-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C-CVE-2010-1622/ "Spring Framework 代码执行(CVE-2010-1622)")

[Apache Archiva 任意目录删除(CVE-2022-40309) 和 任意文件读取(CVE-2022-40308)](/20...