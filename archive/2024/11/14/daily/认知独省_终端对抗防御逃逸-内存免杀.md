---
title: 终端对抗防御逃逸-内存免杀
url: https://mp.weixin.qq.com/s?__biz=MzU0NTI4MDQwMQ==&mid=2247484184&idx=1&sn=101b31368a5a3b3f2d1f3c1b68ecb628&chksm=fb6e1be6cc1992f0bcc5750e1a14ccf4002e5f3f4280051ce92af958f4609778291ceb544fd5&scene=58&subscene=0#rd
source: 认知独省
date: 2024-11-14
fetch_date: 2025-10-06T19:19:50.464562
---

# 终端对抗防御逃逸-内存免杀

![cover_image](https://mmbiz.qpic.cn/sz_mmbiz_jpg/gS0DP6tuCtI5HicgrSfwj6kTH64hjLXkF9RdEXPZ477IBmH9NoS0Ga5Ra8IrZGnGpfm11A6xjNw1PE66rYOFDTw/0?wx_fmt=jpeg)

# 终端对抗防御逃逸-内存免杀

原创

hunter

认知独省

Author: hunter@深蓝攻防实验室

本文为ADConf 原创议题

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/gS0DP6tuCtI5HicgrSfwj6kTH64hjLXkF1NUHa2CEgdibHqQzS47hpjwicFpcMjxSAdKEQPRE0m27BmDbmricaSNDA/640?wx_fmt=jpeg)

**关于终端对抗**

![](https://mmbiz.qpic.cn/sz_mmbiz_png/gS0DP6tuCtI5HicgrSfwj6kTH64hjLXkFuWJA38SQMZDpo3d1OlqG3oicMDRCbYglUicbQMkb1aPvvtNQ7JMx1ibow/640?wx_fmt=png)

---

**内存免杀的意义**

Q：在当前BYOVD技术已经成熟且武器化且EDR检测能力也逐渐完善的环境下，为什么还要研究内存检测逃逸相关的技术？

A：首先要明确：高压环境下的EDR致盲目的不再是“一键卸载安全卫士/电脑管家”，而是要在企业级EDR控制端没有察觉的情况下致盲终端Agent的检测。

然而有些场景是不能完全依赖BYOVD的，我们的木马要被迫和完全体EDR共存

1. 加载驱动的黑白名单。
2. EDR的R3/R0组件中有类暗桩的存在。
3. 与EDR控制端通信的模块直接做在了R0里面，卸载驱动等同于直接切断通信。
4. 部分场景下，根本没有系统的高权限且无法提权。
5. 机器重启后，被致盲的EDR会恢复正常，权限维持的木马必须有一定存活能力。
6. ......

木马“内存免杀”需要聚焦的两个阶段：

1. Loader载入Shellcode并释放植入体的整个过程。
2. 植入体成功释放，核心代码线程在“运行——休眠”的过程中长期与EDR共存。

---

**Loader原理**

1. Loader外壳从某个地方（云端/本地/PE资源节等...）获取Shellcode（PIE代码），申请一段内存，将Shellcode写入并执行。Shellcode本体是通过转换工具（PengCode/donut等）将原C2客户端的PE转换成一个反射加载器。

   ![](https://mmbiz.qpic.cn/sz_mmbiz_png/gS0DP6tuCtI5HicgrSfwj6kTH64hjLXkFCgungDuPhb4EWtG996EYzqtWu5kDu3mXL5hRxa2jMmhQ3S5YDnCamQ/640?wx_fmt=png)
2. Shellcode执行内置的反射加载器，重新申请内存空间，将打包的PE（植入体）释放到新内存区域。反射加载器会负责解析打包的PE文件头信息，完成重建导入表、重定位等工作。

   ![](https://mmbiz.qpic.cn/sz_mmbiz_png/gS0DP6tuCtI5HicgrSfwj6kTH64hjLXkF5iaqvh6Fs27FoGdrmZibqKGF6Xen8QMTYV8H3LuRiaxrGR72fwicbsrJ9A/640?wx_fmt=png)
3. 通过反射加载的dll导出表找到木马植入体，执行。木马植入体进入执行——休眠周期。

 ![](https://mmbiz.qpic.cn/sz_mmbiz_png/gS0DP6tuCtI5HicgrSfwj6kTH64hjLXkFLmBcbjraw70myso6KQQh3kdFCuOcgxCvnNtqWZiasjMOzCREn0oyjiaQ/640?wx_fmt=png)

---

**EDR检测原理**

**EDR的标准实现方案**

**R3：**借助API HOOK拦截敏感函数调用，跟踪参数和返回值。

主要在行为检测中应用，在内存检测中是个可选项，通过HOOK不同API实现不同的监控偏好（如NtAllocateVirtualMemory）。

**R0：**

* 内核回调-Windows / 内核探针（Kprobes）-Linux
* 内核钩子 - SSDT系统调用表、全局描述符表GDT、中断描述符表（IDT）钩子会和x64下的patch guard冲突，但依然有绕过方式。
* 借助ETW实现对底层调用的监控 - ETW是Windows提供的一个强大的消息跟踪机制，允许收集包括内核事件在内的各种系统级事件。通过订阅特定的ETW提供者和事件，EDR可以获得关于系统行为的详细信息。
* 硬件辅助 - Intel VT-x或AMD-V，在更低的硬件级别提供对执行环境的控制和监视。

下图为依赖内核回调触发R3 API Hook的函数调用检测方案，也是最通用的。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/gS0DP6tuCtI5HicgrSfwj6kTH64hjLXkFsnoicT2KDdsHSjicL35Xmiak0jic1kuUAz319YmG6UpodmsibBJ9cue1iaqQ/640?wx_fmt=png)

---

**内存扫描关键技术**

**策略① - 偏向精准检测**

* R3 Hook，初筛敏感API调用；
* 利用ETW/硬件虚拟化/内核钩子等技术检测底层调用；
* 触发规则立即启动栈回溯；
* 重点扫描栈回溯过程中发现的可疑地址对应的内存。

精准检测策略主打快准狠，第一时间阻止植入体的释放或运行。但为考虑到误报和性能开销等实际问题，相对固定的规则可能会导致漏报。

**策略② - 偏向持续检测**

* 监控线程状态（包含线程的堆栈、运行状态等）；
* 对私有内存页进行扫描（通常在线程休眠时）；
* 搜索高熵区域、RWX等区域，重点标记；
* 对重点标记区提升扫描频率或重点监控该区域的读写、访问行为（可利用API Hook或底层调用的检测），直到探测到植入体相关特征。

主要为避免漏报。但同时为了降低误报，其规则可能不再是固定的模板而是个权重（或结合本地/云端AI模型来综合判定）。因此响应有一定延迟，这也就是为什么有些EDR的内存扫描开启后会允许木马正常运行一段时间再杀的原因。

**32/64位程序的栈回溯**

* 32位程序由于完全依赖栈实现参数传递，因此标准的栈结构是保存EBP作为基指针来访问局部变量和参数。栈回溯依赖于链式栈帧，通过保存在栈上的EBP寄存器链接，通过遍历这些链式栈帧精准可以找到每个调用的返回地址和调用者的栈帧。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/gS0DP6tuCtI5HicgrSfwj6kTH64hjLXkFfiasjjryoW1ZkScZzCnpM0PNeOTWHrh9ibzJTXuicEwkOHtWHCMjVHGxQ/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/gS0DP6tuCtI5HicgrSfwj6kTH64hjLXkFEMYl44KWAtrBiaxUvv1sfRQpO4jqKax76ru2Pvq72NPGyDoSSbFfjNQ/640?wx_fmt=png)

* 64位下由于主要使用寄存器传参，对栈的依赖减小，并且调用约定做了优化，只使用当前RSP的偏移来访问局部变量和参数，不再保存RBP。这种优化称为“省略帧指针”（FPO），但这也给栈回溯提升了难度，通常情况下为了降低算法复杂度，栈回溯需要借助.pdata节中的RUNTIME\_FUNCTION结构（动态插桩或编译器插桩等精准回溯的方式对EDR来说不现实），不过这也给攻击者带来了便利。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/gS0DP6tuCtI5HicgrSfwj6kTH64hjLXkFQsVkGgnSbFC1vmeKyCOFOlXISnMgDA0txxP3tRibr4kU6rIibH1eOsqw/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/gS0DP6tuCtI5HicgrSfwj6kTH64hjLXkFZpf0ppwVia4bfNJSscbgagaPAvRJtYM0ibCibq7LrLqfc9ATax2ZjBa2w/640?wx_fmt=png)

**一个64位栈回溯的案例**

![](https://mmbiz.qpic.cn/sz_mmbiz_png/gS0DP6tuCtI5HicgrSfwj6kTH64hjLXkFVTFfeAMJCMiabDdXMYo2JBcpEw2dxIJfexwUofKL76lHYQHKiaxS7xXw/640?wx_fmt=png)

---

**对抗方案-精准检测**

**SYSCALL**

可参考开源项目：GitHub - Dec0ne/HWSyscalls: HWSyscalls is a new method to execute indirect syscalls using HWBP, HalosGate and a synthetic trampoline on kernel32 with HWBP.

![](https://mmbiz.qpic.cn/sz_mmbiz_png/gS0DP6tuCtI5HicgrSfwj6kTH64hjLXkFgTsQ08QxR3WYn2giac5alDPic8ARgOJY1qgaoh067YuJghKNGWGdJDlA/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/gS0DP6tuCtI5HicgrSfwj6kTH64hjLXkFoSMdKpPWaz7icglxowujUcj5ibWdW07uZpO4Epo8vJdJBibdyldwet4uQ/640?wx_fmt=png)

**Unhook**

* 方法1：将磁盘上“干净”的dll映射到当前进程中，读取.text节并覆盖被hook的dll的.text节。
* 方法2：创建一个白名单进程，读取其未被hook的dll，覆盖当前进程中dll的.text节。
* 方法3：没有白名单程序的情况下，在新进程启动加载完成dll时将其挂起，保留其中“干净”的dll快照，覆盖当前进程dll的.text节。
* ......

总结一句话：用一个“干净”的副本覆盖掉被Hook部分的代码。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/gS0DP6tuCtI5HicgrSfwj6kTH64hjLXkFNsLrRgpa2bfMMwvqaSA1EQJ4e3pWo6owk4orE74Wia8H3QpsP1N34Qw/640?wx_fmt=png)

Unhook效果如下：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/gS0DP6tuCtI5HicgrSfwj6kTH64hjLXkFViagmyCT9KsXm3hiaXPvicFfynbMYGEaJNiakEicrwfqAWPicW7Ge1gDqprA/640?wx_fmt=png)

**栈回溯欺骗**

注意：由于栈帧伪造是对应局部函数调用的，因此在反射加载器与核心植入体代码中实现才能达到效果最大化，因为绝大多数敏感函数的调用都在这两层的代码中；仅在“外壳”Loader中实现效果并不好。

1. 重写系统API替换高风险函数，如NtAllocateVirtualMemory()等；
2. 在重写的函数中，先保存现场存储当前线程上下文到一个全局结构体中，然后抬高栈顶，并PUSH 0，将真实的栈帧截断并隐藏起来；
3. 在这之上部署一个假栈（伪造一些常见的返回地址制作一个栈底和看上去合理的调用链）；
4. 在假栈上方部署一个Gadget Frame用来做跳转（跳转回高风险函数调用前的位置，比如预先从内存中找好的JMP [RBX]片段）；
5. 为跳转和堆栈恢复做准备，将真正的返回地址、RBX寄存器值放入结构体暂存，然后将堆栈恢复函数fixup()的地址给RBX，最后JMP到真正的函数调用；
6. 真正的函数调用完毕后会将部署的Gadget当作返回地址跳转至JMP [RBX]执行，而此时时RBX保存的是自定义方法中fixup()的地址，进入堆栈恢复函数，恢复帧栈和前面保存的寄存器，最后JMP回到原来高风险函数调用的位置。

**概括：**使用汇编重写敏感函数调用，在我们自己编写的调用约定中对栈进行布局，将原始栈帧隐藏在构造的假栈下面，干扰栈回溯算法的判断。在函数执行完成返回的时候再借助之前构造的gadget精准返回到原本的返回地址。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/gS0DP6tuCtI5HicgrSfwj6kTH64hjLXkF0gaekjrxRpwGqgVb982w2XxgibTviaV9bjkzxxW3oQUEUUjh6Xia50CmQ/640?wx_fmt=png)

直接调用与栈帧伪造的对比如下。

直接调用：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/gS0DP6tuCtI5HicgrSfwj6kTH64hjLXkFv6BNE8rgw4BAhk1U7cKIliajHYicwxBWeSfyYare1qytNfGNn7oIyBDg/640?wx_fmt=png)

栈帧伪造：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/gS0DP6tuCtI5HicgrSfwj6kTH64hjLXkFOYqWSNmTStB0ufvpiaDIg078SlqJd0fs8b0QGicQyKokeKnk9e7IpZIw/640?wx_fmt=png)

![](https://mmbiz.qpic.cn/sz_mmbiz_png/gS0DP6tuCtI5HicgrSfwj6kTH64hjLXkFgfZicib0JSibUcxWmzVrykmZDudibooibeBoibr8Ae8NAiamqPliavs08wjVgA/640?wx_fmt=png)

---

**对抗方案-持续检测**

**思路整理**

1. 防止反射加载器特征被扫描识别

1. –自动探测并移除反射加载器在内存中的残留

2. 对抗线程休眠期间的栈回溯和内存扫描

1. –实现休眠期间栈欺骗
2. –休眠期间植入体内存页不可执行
3. –休眠期间针对植入体做内存转储

可参考的经验

**参考案例-1：**

https://github.com/mgeeky/ThreadStackSpoofer/tree/master；

1. 其利用hook Sleep()截断栈帧，以对抗线程休眠期间的栈回溯探测。该项目使用的inline hook内存特征明显，主动扫描很容易发现；
2. 该项目的MySleep()中没有对内存中的植入体和加载器残留做处理。

**参考案例-2：**

https://github.com/vxunderground/VXUG-Papers/blob/main/GpuMemoryAbuse.cpp；利用CUDA将内存转储至VRAM。

1. 该项目利用CUDA API仅适用于NVIDIA平台，通用性较低；
2. 该项目是一个测试Demo，仅实现了VRAM读写功能，无法直接整合到Loader中。

---

**关键技术说明**

**“无内存特征”hook**

简单对常见的R3 hook技术做个总结。

**Win32 hook（Windows提供的API，局限性很强）**

Windows提供了一套API，允许插入钩子来监视特定类型的事件，如键盘输入、鼠标移动等。这些钩子可以是全局的或特定于线程的。

**回调函数hook（可以理解为Win32 hook的扩充，功能强大但并不能用于WinAPI）**

可用于监控和干预许多系统级和应用级事件。除了监控键盘和鼠标事件之外，它们还可以用于
监控消息队列：通过设置消息钩子（例如，WH\_GETMESSAGE和WH\_CALLWNDPROC），可以监控和修改应用程序的消息队列中的消息。
监测系统状态变化：如设置WH\_SHELL钩子来监控系统的各种状态变化，例如窗口的创建和销毁、系统的休眠和唤醒等。
截获窗口活动：例如，通过WH\_CBT（计算机基础训练钩子）可以监控窗口的创建、移动、大小调整等事件。
监控低级别的鼠标和键盘输入：如之前例子中的WH\_KEYBOARD\_LL和WH\_MOUSE\_LL，这些钩子可以用来实现全局的键盘和鼠标输入监控，甚至在应用程序处理它们之前拦截这些输入。

**Inline hook（最通用，但需要对内存作hot patch）**

通过修改目标函数的首部字节（通常是替换为跳转指令），将执行流重定向到钩子处理函数。当执行到达目标函数时，会跳转执行自定义的钩子函数。这种方式需要处理原始指令的备份和执行恢复，以确保目标函数的正常执行。

**IAT/EAT hook（对动态加载的库不适用，且影响DLL的签名校验，针对ASLR还需要重定位）**

通过修改应用程序的导入地址表（IAT）/DLL的导出地址表（EAT），将导入/导出的函数地址改为钩子函数的地址。主要用于拦截应用程序对DLL导出函数的调用/影响所有调用该DLL函数的应用程序。

**局限**

上面常见的hook多多少少都有一些缺陷，大家都在用的inline hook也因为需要修改内存而导致非常容易被检测到，不管是前面提到过的线程调用堆栈混淆的项目中使用到的hook还是minhook这类开源的hook框架都是用的这种传统的方式。
其实还有一种hook方式被忽略但又几乎天天都在用，那就是调试器。我们使用调试器的时候下个断点，轻轻松松就可以单步调试并且任意修改内存，这不也就实现了hook的效果？那么我们就需要研究一下调试器是怎么做到拦截程序执行流程的，并尝试模拟这一过程。

**软件断点**

软件断点主要通过修改目标程序的代码来实现，具体来说是通过替换目标地址处的指令字节为特定的断点指令。在x86架构下，这个特定的断点指令通常是INT 3（0xCC），当程序执行到达目标地址时，INT 3指令会触发一个异常，通常是一个断点异常（EXCEPTION\_BREAKPOINT）。在替换目标地址处的指令之前，需要由调试器来保存该地址处的原始指令字节。
当断点触发时，控制权会转移到调试器，也可以是自定义的处理程序，在这个处理程序中可以执行自定义逻辑。
下图说明了软件断点的实现原理。

![](https...