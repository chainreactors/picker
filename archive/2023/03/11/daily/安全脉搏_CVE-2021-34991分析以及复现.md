---
title: CVE-2021-34991分析以及复现
url: https://www.secpulse.com/archives/197309.html
source: 安全脉搏
date: 2023-03-11
fetch_date: 2025-10-04T09:12:46.016549
---

# CVE-2021-34991分析以及复现

[![](https://www.secpulse.com/wp-content/themes/secpulse2017/img/logo-header.png)](https://www.secpulse.com "安全脉搏")

* [首页](https://www.secpulse.com/)
* [分类阅读](https://www.secpulse.com/archives/category/category)

  #### 脉搏文库

  - [内网渗透](https://www.secpulse.com/archives/category/articles/intranet-penetration)
  - |
  - [代码审计](https://www.secpulse.com/archives/category/articles/code-audit)
  - |
  - [安全文献](https://www.secpulse.com/archives/category/articles/sec-doc)
  - |
  - [Web安全](https://www.secpulse.com/archives/category/articles/web)
  - |
  - [移动安全](https://www.secpulse.com/archives/category/articles/mobile-security)
  - |
  - [系统安全](https://www.secpulse.com/archives/category/articles/system)
  - |
  - [工控安全](https://www.secpulse.com/archives/category/articles/industrial-safety)
  - |
  - [CTF](https://www.secpulse.com/archives/category/exclusive/ctf-writeup)
  - |
  - [IOT安全](https://www.secpulse.com/archives/category/iot-security)
  - |

#### 安全建设

+ [业务安全](https://www.secpulse.com/archives/category/construction/businesssecurity)
+ |
+ [安全管理](https://www.secpulse.com/archives/category/construction/securityissue)
+ |
+ [数据分析](https://www.secpulse.com/archives/category/construction/bigdata)
+ |

#### 其他

+ [资讯](https://www.secpulse.com/archives/category/news)
+ |
+ [漏洞](https://www.secpulse.com/archives/category/vul)
+ |
+ [工具](https://www.secpulse.com/archives/category/tools)
+ |
+ [人物志](https://www.secpulse.com/archives/category/people)
+ |
+ [区块链安全](https://www.secpulse.com/archives/category/exclusive/block_chain_security)
+ |
+ [安全招聘](https://www.secpulse.com/archives/category/hiring)
+ |

- [安全问答](https://www.secpulse.com/newpage/question_list)
- [金币商城](https://www.secpulse.com/shop?donotcachepage=c010349fd98847cb9d6e07d3cbc19288)
- [安全招聘](https://www.secpulse.com/archives/category/hiring)
- [活动日程](https://www.secpulse.com/newpage/activity)
- [live课程](https://www.secpulse.com/live)
- [企业服务](https://duoyinsu.com/service.html)
- [插件社区](https://x.secpulse.com/)

小程序

![脉搏小程序](https://www.secpulse.com/wp-content/themes/secpulse2017/img/wxchat.jpg)
[登录](https://www.secpulse.com/user_login)
|
[注册](https://www.secpulse.com/user-register)

# CVE-2021-34991分析以及复现

[漏洞复现](https://www.secpulse.com/archives/category/articles/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0)

[星盟安全团队](https://www.secpulse.com/newpage/author?author_id=26965)
![]( https://www.secpulse.com/wp-content/themes/secpulse2017/img/renzheng0.png)

2023-03-10

11,110

0x00.  前言Greater Snow

![](https://secpulseoss.oss-cn-shanghai.aliyuncs.com/wp-content/uploads/1970/01/beepress-image-197309-1678430732.png)

CVE-2021-34991漏洞可以在Netgear SOHO个别设备中获取root权限，进行远程代码执行。该漏洞发生于upnp服务程序中没有严格检查字符串拷贝的长度，导致可以栈溢出控制程序的执行流。

本次复现所采用的固件版本为R6400v2-1.0.4.118，可在这里进行下载。

https://www.netgear.com/support/download/?model=R6400v2

0x01.  相关汇编知识Greater Snow

![](https://secpulseoss.oss-cn-shanghai.aliyuncs.com/wp-content/uploads/1970/01/beepress-image-197309-1678430735.png)

固件中程序所采用的是32位ARM架构，这里仅是讲讲复现过程中的重要内容，并没有对整个体系进行讲解。

常用的寄存器有R0、R1、R2、···、R15，R0/R1/R2/R3用于函数的参数传递，函数返回时用R0保存返回值。这里使用的顺序编号，其中一些寄存器还使用了其它标识。

其中：

R11为FP，为栈底指针寄存器，如同X86下的EBP;

R13为SP，为栈顶指针寄存器；

R14为LR，在调用函数时保存下个指令的地址；

R15为PC，指向CPU执行的指令；

下面来看看arm函数调用和函数返回的过程：

```
.text:0001DEC8 05 00 A0 E1                   MOV             R0, R5        ; int
.text:0001DECC 08 10 A0 E1                   MOV             R1, R8        ; needle
.text:0001DED0 84 21 9F E5                   LDR             R2, =(aSslHttpSocketC+0x20) ; "\r\n"
.text:0001DED4 06 30 A0 E1                   MOV             R3, R6
.text:0001DED8 91 BD FF EB                   BL              find_token_get_val
.text:0001DED8
.text:0001DEDC 00 00 50 E3                   CMP             R0, #0
```

、

上面为调用find\_token\_get\_val的汇编代码，使用BL跳转时，会先保存下一指令的地址(即0x0001DEDC)到LR中，然后进行跳转。如果是指令B，则直接进行跳转。

```
// find_token_get_val首条指令.text:0000D524 F0 47 2D E9                   PUSH            {R4-R10,LR}
// find_token_get_val返回时.text:0000D538 04 00 A0 E1                   MOV             R0, R4.text:0000D53C F0 87 BD E8                   POP             {R4-R10,PC}
```

从上面可见，在进入find\_token\_get\_val后，首先使用PUSH把父函数的寄存器信息保存，返回时，再使用POP进行恢复。现在来看看这两条指令，里面的”R4-R10”，指的是R4、R5、···、R9、R10寄存器。

如果以X86的视角进行分析: 首先push R4，然后R5, 直到LR；返回时pop R4, R5…诶？不太对，从右往左试试~? 仅按括号中的左右顺序进行分析，无论怎样，始终感觉奇怪。其实，ARM采用了更加简单直接的方式：

![](https://secpulseoss.oss-cn-shanghai.aliyuncs.com/wp-content/uploads/1970/01/beepress-image-197309-1678430736.png)

![](https://secpulseoss.oss-cn-shanghai.aliyuncs.com/wp-content/uploads/1970/01/beepress-image-197309-1678430740.png)

从官方手册的描述中，我们可以知道是以寄存器的编号大小为PUSH/POP的顺序，大编号对应高地址，小编号对应低地址。以前面的指令为例，并且我们已知栈是从高地址往低地址发展的。PUSH {R4-R10, LR}：先把LR(R14)压栈，再到R10、R9、···、R4。POP {R4-R10, PC}：先出栈给R4，再到R5，···，最后是LR。

0x02.  漏洞分析Greater Snow

![](https://secpulseoss.oss-cn-shanghai.aliyuncs.com/wp-content/uploads/1970/01/beepress-image-197309-1678430741.png)

该栈溢出漏洞发生在upnpd程序的gena\_response\_unsubscribe函数中：

```
char needle[10240]; // [sp+8h] [bp-2C68h] BYREF  char http_msg[512]; // [sp+2808h] [bp-468h] BYREF  char v14[512]; // [sp+2A08h] [bp-268h] BYREF  char uuid_buffer[104]; // [sp+2C08h] [bp-68h] BYREF
  memset(v14, 0, sizeof(v14));  memset(http_msg, 0, sizeof(http_msg));  memset(uuid_buffer, 0, 0x40);  (likePrint)(2, "%s(%d)\n", "gena_response_unsubscribe");  strncpy(http_msg, a1, 511u);                  // a1 -> v13  strlwr(http_msg);                             // 转换成小写  if ( !strstr(http_msg, "sid:") )              // strstr(str1, str2) 判断str2是否为str1的子串    return (send_error_response)(a2);  if ( !strstr(http_msg, "host:") )    return (send_error_response)(a2);  if ( !stristr(http_msg, "uuid:") )    return (send_error_response)(a2);  memset(uuid_buffer, 0, 0x40u);                // 用于存储从http_msg中获取的uuid值  memset(needle, 0, sizeof(needle));  strncpy(needle, "uuid:", 0x3FFu);  if ( !(find_token_get_val)(http_msg, needle) )    return (send_error_response)(a2);
```

gena\_response\_unsubscribe函数用于处理http中的UNSUBSCRIBE请求，使用strncpy将传入的http报文信息拷贝到数组http\_msg中，然后使用strlwr将http\_msg中的大写字母转换为小写。

在下面调用find\_token\_get\_val函数获取uuid的值时，可以赋给uuid\_buffer过多的值导致栈溢出：

```
uuid_value_end = strstr(a1, a3);            // 指向uuid值的结束
    v4 = uuid_value_end;
    if ( uuid_value_end )
    {
      if ( uuid_value_end - uuid_value_start < 1024 )  // 1024
          strncpy(a4, uuid_value_start, uuid_value_end - uuid_value_start);
      else
```

要想控制执行流进行getshell，首先我们需要知道如何构造uuid的值，使得返回地址覆盖为gadget的地址，从而控制执行流。需要注意的是：

(1)strncpy拷贝数据是有x00字节截断的，如果我们构造uuid值中带有x00，

那么前面strncpy(http\_msg, a1, 511u)

这里将导致报文缺失，从而获取uuid时，找不到rn而引起程序退出；

(2)前面有大小写转换，那么gadget中不能含有A-Z对应的ascii码值；

对于第一点分析，指令地址的高字节是有x00的，但由于程序是小端序，我们可以用rn绕过，rn替代掉高字节的x00。作为代价是我们uuid值中，只能带有一个gadget地址。

对于第二点，

虽然在gena\_response\_unsubscribe函数的栈帧空间中，http报文会转换为小写，但在调用gena\_response\_unsubscribe函数的父函数的栈帧空间中报文还是原始的格式。我们可以增加SP的值，使其指向该处。

大概思路：

控制执行流后先add sp，使其指向getshell gadget，然后pop pc；getshell指令是BL system，不过要先把参数放入R0。至于system的参数，可以通过另外一个请求传入全局变量0x66AD0处。

0x03.  编写EXPGreater Snow

![](https://secpulseoss.oss-cn-shanghai.aliyuncs.com/wp-content/uploads/1970/01/beepress-image-197309-1678430742.png)

首先说一下idaF5反编译的问题：

从汇编指令来看

find\_token\_get\_val(http\_msg, needle)

其实是为

find\_token\_get\_val(http\_msg, needle, "rn", uuid\_buffer)。

然后，至于uuid\_buffer的大小:

```
// 进入gena_response_unsubscribe后：.text:0001DDAC F0 4F 2D E9                   PUSH            {R4-R11,LR}.text:0001DDB0 B1 DD 4D E2                   SUB             SP, SP, #0x2C40.text:0001DDB4 0C D0 4D E2                   SUB             SP, SP, #0xC
// uuid_buffer第一次memset:.text:0001DE04 02 3A 8D E2                   ADD             R3, SP, #0x2C70+var_C70.text:0001DE08 0B 0B 8D E2                   ADD             R0, SP, #0x2C70+var_70.text:0001DE0C 04 10 A0 E1                   MOV             R1, R4        ; c.text:0001DE10 3C 20 A0 E3                   MOV             R2, #0x3C ; '<' ; n.text:0001DE14 08 4C 83 E5                   STR             R4, [R3,#0xC08].text:0001DE18 0C 00 80 E2                   ADD             R0, R0, #0xC ...