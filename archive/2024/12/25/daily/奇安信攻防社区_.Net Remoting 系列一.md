---
title: .Net Remoting 系列一
url: https://forum.butian.net/share/3989
source: 奇安信攻防社区
date: 2024-12-25
fetch_date: 2025-10-06T19:33:05.906374
---

# .Net Remoting 系列一

#

[问答](https://forum.butian.net/questions)

*发起*

* [提问](https://forum.butian.net/question/create)
* [文章](https://forum.butian.net/share/create)

[攻防](https://forum.butian.net/community)
[活动](https://forum.butian.net/movable)

Toggle navigation

* [首页 (current)](https://forum.butian.net)
* [问答](https://forum.butian.net/questions)
* [商城](https://forum.butian.net/shop)
* [实战攻防技术](https://forum.butian.net/community)
* [漏洞分析与复现](https://forum.butian.net/articles)
  NEW
* [活动](https://forum.butian.net/movable)
* [摸鱼办](https://forum.butian.net/questions/Play)

搜索

* [登录](https://forum.butian.net/login)
* [注册](https://user.skyeye.qianxin.com/user/register?next=http://forum.butian.net/btlogin)

### .Net Remoting 系列一

* [安全工具](https://forum.butian.net/topic/53)

前言：笔者在代码审计时碰到许多以.Net Remoting技术开发的应用如SolarWinds、VeeamBackup、Ivanti等产品，尽管随着 WCF 和 gRPC 等更现代化技术的兴起，.NET Remoting 已逐渐淡出主流，但是依然有其研究的价值，本次主要以TcpChannel为主分析其工作原理、应用场景，后续会通过两个漏洞介绍.Net Remoting在不同场景下的利用姿势和挖掘思路

简介
--
.NET Remoting 是通过通道（Channel）实现不同应用程序域（AppDomain）之间对象通信的技术核心，依赖程序集 \*\*System.Runtime.Remoting.dll\*\* 提供支持。通道负责在进程间或网络上传输序列化后的对象数据，是 Remoting 架构的关键组件。
在 .NET Remoting 中，主要支持以下几种通道类型：
1. \*\*TcpChannel\*\*
位于命名空间 `System.Runtime.Remoting.Channels.Tcp`，提供高效的二进制传输，适合局域网内低延迟、高吞吐的场景。
2. \*\*HttpChannel\*\*
位于命名空间 `System.Runtime.Remoting.Channels.Http`，基于 HTTP 协议传输数据，支持 SOAP 格式化，适合跨防火墙或需要更通用通信协议的应用。
3. \*\*IpcChannel\*\*
位于命名空间 `System.Runtime.Remoting.Channels.Ipc`，基于命名管道（Named Pipe），为同一台机器上的进程间通信提供高效、轻量级的解决方案。
4. \*\*自定义通道（Custom Channel）\*\*
通过实现 `IChannelReceiver`、`IChannel` 和 `ISecurableChannel` 接口，开发者可以设计满足特定需求的自定义通道，例如支持特殊传输协议或安全策略的通信。
通过上述通道类型，.NET Remoting 为分布式应用提供了灵活的通信方式，并允许根据场景需求选择合适的传输层。
.Net Remoting demo
------------------
以TcpChannel为例写一个服务端（TcpServerChannel）和客户端（TcpClientChannel）
### 远程对象MBR
```php
using System;
using System.Runtime.Serialization;
namespace RemotableServer
{
[Serializable]
public class RemoteObject1 : MarshalByRefObject
{
private int callCount = 0;
public Guid Id { get; private set; }
public string Tag { get; private set; }
public RemoteObject1(Guid id, string hint, string tag)
{
this.Id = id;
this.Tag = tag;
}
public RemoteObject1()
{
}
public int GetCount()
{
Console.WriteLine("GetCount was called.");
callCount++;
return callCount;
}
protected RemoteObject1(SerializationInfo info, StreamingContext context)
{
this.Id = (Guid)info.GetValue("Id", typeof(Guid));
this.Tag = "tag";
}
public void GetObjectData(SerializationInfo info, StreamingContext context)
{
info.AddValue("Id", this.Id);
info.AddValue("Tag", this.Tag);
}
}
}
```
### 服务端
1. Channel Sink Provider（实现IServerChannelSinkProvider）并指定TypeFilterLevel值
2. ChannelServices.RegisterChannel()注册ServerChannel（实现IChannelReceiver, IChannel）可自定义。
3. RemotingConfiguration.RegisterWellKnownServiceType注册ObjectUri以及绑定的对象
```php
using System;
using System.Collections;
using System.IO;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Channels;
using System.Runtime.Remoting.Channels.Tcp;
using System.Runtime.Serialization.Formatters;
namespace RemotableServer
{
class RemoteType : MarshalByRefObject
{
}
internal class Program
{
public static void Main(string[] args)
{
BinaryServerFormatterSinkProvider binary = new BinaryServerFormatterSinkProvider()
{
TypeFilterLevel = TypeFilterLevel.Low
};
IDictionary hashtables = new Hashtable();
hashtables["port"] = 9999;
String object\_uri = "RemotableServer";
TcpServerChannel tcpServerChannel = new TcpServerChannel(hashtables, binary);
ChannelServices.RegisterChannel(tcpServerChannel, false);
// RemotingConfiguration.RegisterWellKnownServiceType(typeof(RemoteType), "RemotableServer", WellKnownObjectMode.Singleton);
RemotingConfiguration.RegisterWellKnownServiceType(typeof(RemoteObject1), object\_uri, WellKnownObjectMode.Singleton);
Console.WriteLine("Server Activated at tcp://localhost:{0}/{1}",hashtables["port"], object\_uri);
Console.ReadKey();
}
}
}
```
### 客户端
客户端调用可通过TcpClientChannel、Activator、TcpChannel等方式调用远程对象
```php
//Activator调用
string serverAddress = "tcp://localhost:9999/RemotableServer";
RemotableServer.RemoteObject1 obj1 = (RemotableServer.RemoteObject1)Activator.GetObject(typeof(RemotableServer.RemoteObject1), serverAddress);
Console.WriteLine("get string:\t{0}", obj1.GetCount());
Console.WriteLine("get string:\t{0}", obj1.GetCount());
Console.WriteLine("get string:\t{0}", obj1.GetCount());
//TcpClientChannel
TcpClientChannel clientChannel = new TcpClientChannel();
ChannelServices.RegisterChannel(clientChannel);
RemotingConfiguration.RegisterWellKnownClientType(
typeof(RemotableServer.RemoteObject1), "tcp://localhost:9999/RemotableServer"
);
RemotableServer.RemoteObject1 remoteObject1 = new RemotableServer.RemoteObject1();
Console.WriteLine(remoteObject1.GetCount());
// TcpChannel
TcpChannel channel = new TcpChannel();
ChannelServices.RegisterChannel(channel, false);
RemotableServer.RemoteObject1 remoteObject = (RemotableServer.RemoteObject1)RemotingServices.Connect(typeof(RemotableServer.RemoteObject1), "tcp://localhost:9999/RemotableServer");
Console.WriteLine(remoteObject.GetCount());
```
运行效果：
```php
&gt;RemotableObjects.exe
get string: 1
get string: 2
get string: 3
```
.Net Remoting 实现
----------------
这里大致分析下其代码实现，如果碰上自定义的ServerChannel能够快速理清代码逻辑。
TcpServerChannel和TcpClientChannel分别实现了IChannelReceiver、IChannelSender，首先来看看TcpServerChannel，其构造函数调用SetupChannel方法开启Channel
```php
private void SetupChannel()
{
//是否需要认证
if (this.authSet &amp;&amp; !this.\_secure)
{
throw new RemotingException(CoreChannel.GetResourceString("Remoting\_Tcp\_AuthenticationConfigServer"));
}
//存储远程通道的通道数据。
this.\_channelData = new ChannelDataStore(null);
if (this.\_port &gt; 0)
{
this.\_channelData.ChannelUris = new string[1];
this.\_channelData.ChannelUris[0] = this.GetChannelUri();
}
//sinkprovider为空使用默认的sinkProviderChain
if (this.\_sinkProvider == null)
{
this.\_sinkProvider = this.CreateDefaultServerProviderChain();
}
CoreChannel.CollectChannelDataFromServerSinkProviders(this.\_channelData, this.\_sinkProvider);
//配置sinkProviderChain
IServerChannelSink nextSink = ChannelServices.CreateServerChannelSinkChain(this.\_sinkProvider, this);
this.\_transportSink = new TcpServerTransportSink(nextSink, this.\_impersonate);
//监听
this.\_acceptSocketCallback = new AsyncCallback(this.AcceptSocketCallbackHelper);
if (this.\_port &gt;= 0)
{
this.\_tcpListener = new ExclusiveTcpListener(this.\_bindToAddr, this.\_port);
this.StartListening(null);
}
}
```
如上，主要关注Channel Sinks( transport sink-&gt;formatter sinks-&gt;dispatch sink )，这里引用一张图
![Pasted image 20240920150422.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/12/attach-770e4d3af87c6446835e8dd7bc92aed630fbe3bf.png)
TcpServerChannel的默认链
`TcpServerTransportSink → BinaryServerFormatterSink → SoapServerFormatterSink → DispatchChannelSink`
TcpClientChannel的默认链是`BinaryClientFormatterSink` → `TcpClientTransportSink`，代码如下
```php
private IClientChannelSinkProvider CreateDefaultClientProviderChain()
{
IClientChannelSinkProvider clientProviderChain = (IClientChannelSinkProvider) new BinaryClientFormatterSinkProvider();
clientProviderChain.Next = (IClientChannelSinkProvider) new TcpClientTransportSinkProvider(this.\_prop);
return clientProviderChain;
}
```
利用[ExploitRemotingService](https://github.com/tyranid/ExploitRemotingService/tree/master)打一遍，调用堆栈如图
![187124316260468.png](https://cdn-yg-zzbm.yun.qianxin.com/attack-forum/2024/12/attach-2f8d7c6a7f32be141a02f3d3c8137aee2f6462bb.png)
整个调用过程在经过Channel Sinks处理之后最终反序列化RCE，看下大致数据流
```php
//TcpServerTransportSink
internal void ServiceRequest(object state)
{
TcpServerSocketHandler state1 = (TcpServerSocketHandler) state;
ITransportHeaders requestHeaders = state1.ReadHeaders();
Stream requestStream = state1.GetRequestStream();
......
serverProcessing = this.\_nextSink.ProcessMessage((IServerChannelSinkStack) sinkStack, (IMessage) null, requestHeaders, requestStream, out IMessage \_, out responseHeaders, out responseStream);
// BinaryServerFormatterSink
public ServerProcessing ProcessMessage(
IServerC...